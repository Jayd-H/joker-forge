# Parsed codebase for the project: src


## Directory Structure
- src/
- src\App.tsx (46654 bytes)
- src\components/
- src\components\codeGeneration/
- src\components\codeGeneration\boosters.ts (12178 bytes)
- src\components\codeGeneration\Card/
- src\components\codeGeneration\Card\conditions/
- src\components\codeGeneration\Card\conditions\AnteLevelCondition.ts (1109 bytes)
- src\components\codeGeneration\Card\conditions\BlindRequirementsCondition.ts (1291 bytes)
- src\components\codeGeneration\Card\conditions\BlindTypeCondition.ts (661 bytes)
- src\components\codeGeneration\Card\conditions\CardEditionCondition.ts (623 bytes)
- src\components\codeGeneration\Card\conditions\CardIndexCondition.ts (822 bytes)
- src\components\codeGeneration\Card\conditions\CardRankCondition.ts (1194 bytes)
- src\components\codeGeneration\Card\conditions\CardSealCondition.ts (634 bytes)
- src\components\codeGeneration\Card\conditions\CardSuitCondition.ts (931 bytes)
- src\components\codeGeneration\Card\conditions\CheckFlagCondition.ts (577 bytes)
- src\components\codeGeneration\Card\conditions\DeckSizeCondition.ts (1272 bytes)
- src\components\codeGeneration\Card\conditions\FirstPlayedHandCondition.ts (122 bytes)
- src\components\codeGeneration\Card\conditions\GenericCompareCondition.ts (1162 bytes)
- src\components\codeGeneration\Card\conditions\HandLevelCondition.ts (1834 bytes)
- src\components\codeGeneration\Card\conditions\HandSizeCondition.ts (1114 bytes)
- src\components\codeGeneration\Card\conditions\InternalVariableCondition.ts (1255 bytes)
- src\components\codeGeneration\Card\conditions\JokerCountCondition.ts (1737 bytes)
- src\components\codeGeneration\Card\conditions\PlayerMoneyCondition.ts (1137 bytes)
- src\components\codeGeneration\Card\conditions\PokerHandCondition.ts (1500 bytes)
- src\components\codeGeneration\Card\conditions\RemainingDiscardsCondition.ts (1139 bytes)
- src\components\codeGeneration\Card\conditions\RemainingHandsCondition.ts (1126 bytes)
- src\components\codeGeneration\Card\conditions\SpecificJokerCondition.ts (1076 bytes)
- src\components\codeGeneration\Card\conditions\SystemCondition.ts (286 bytes)
- src\components\codeGeneration\Card\conditions\TriggeredBossBlindCondition.ts (109 bytes)
- src\components\codeGeneration\Card\conditions\VoucherRedeemedCondition.ts (466 bytes)
- src\components\codeGeneration\Card\conditionUtils.ts (6527 bytes)
- src\components\codeGeneration\Card\effects/
- src\components\codeGeneration\Card\effects\AddChipsEffect.ts (971 bytes)
- src\components\codeGeneration\Card\effects\AddExpChipsEffect.ts (991 bytes)
- src\components\codeGeneration\Card\effects\AddExpMultEffect.ts (987 bytes)
- src\components\codeGeneration\Card\effects\AddHyperChipsEffect.ts (1361 bytes)
- src\components\codeGeneration\Card\effects\AddHyperMultEffect.ts (1355 bytes)
- src\components\codeGeneration\Card\effects\AddMultEffect.ts (966 bytes)
- src\components\codeGeneration\Card\effects\AddXChipsEffect.ts (985 bytes)
- src\components\codeGeneration\Card\effects\AddXMultEffect.ts (981 bytes)
- src\components\codeGeneration\Card\effects\BalanceEffect.ts (420 bytes)
- src\components\codeGeneration\Card\effects\ChangePokerHandVariableEffect.ts (2819 bytes)
- src\components\codeGeneration\Card\effects\ChangeRankVariableEffect.ts (1977 bytes)
- src\components\codeGeneration\Card\effects\ChangeSuitVariableEffect.ts (1646 bytes)
- src\components\codeGeneration\Card\effects\CopyConsumableEffect.ts (4593 bytes)
- src\components\codeGeneration\Card\effects\CopyJokerEffect.ts (3225 bytes)
- src\components\codeGeneration\Card\effects\CreateConsumableEffect.ts (5447 bytes)
- src\components\codeGeneration\Card\effects\CreateJokerEffect.ts (3493 bytes)
- src\components\codeGeneration\Card\effects\CreateLastPlayedPlanetEffect.ts (1955 bytes)
- src\components\codeGeneration\Card\effects\DestroyCardEffect.ts (1095 bytes)
- src\components\codeGeneration\Card\effects\DestroyConsumableEffect.ts (3443 bytes)
- src\components\codeGeneration\Card\effects\DestroyJokerEffect.ts (3018 bytes)
- src\components\codeGeneration\Card\effects\DrawCardsEffect.ts (1114 bytes)
- src\components\codeGeneration\Card\effects\EditDollarsEffect.ts (2792 bytes)
- src\components\codeGeneration\Card\effects\EditPlayingCardEffect.ts (3778 bytes)
- src\components\codeGeneration\Card\effects\EmitFlagEffect.ts (920 bytes)
- src\components\codeGeneration\Card\effects\LevelUpHandEffect.ts (3606 bytes)
- src\components\codeGeneration\Card\effects\ModifyInternalVariableEffect.ts (3461 bytes)
- src\components\codeGeneration\Card\effects\PlaySoundEffect.ts (616 bytes)
- src\components\codeGeneration\Card\effects\RetriggerEffect.ts (1701 bytes)
- src\components\codeGeneration\Card\effects\ShowMessageEffect.ts (462 bytes)
- src\components\codeGeneration\Card\effects\SwapChipsMultEffect.ts (428 bytes)
- src\components\codeGeneration\Card\effectUtils.ts (19670 bytes)
- src\components\codeGeneration\Card\index.ts (38473 bytes)
- src\components\codeGeneration\Card\triggerUtils.ts (1398 bytes)
- src\components\codeGeneration\Consumables/
- src\components\codeGeneration\Consumables\conditions/
- src\components\codeGeneration\Consumables\conditions\AnteLevelCondition.ts (1145 bytes)
- src\components\codeGeneration\Consumables\conditions\CardsSelectedCondition.ts (1105 bytes)
- src\components\codeGeneration\Consumables\conditions\CheckFlagCondition.ts (577 bytes)
- src\components\codeGeneration\Consumables\conditions\ConsumableCountCondition.ts (3072 bytes)
- src\components\codeGeneration\Consumables\conditions\HandSizeCondition.ts (1143 bytes)
- src\components\codeGeneration\Consumables\conditions\InBlindCondition.ts (357 bytes)
- src\components\codeGeneration\Consumables\conditions\PlayerMoneyCondition.ts (1079 bytes)
- src\components\codeGeneration\Consumables\conditions\RemainingHandsCondition.ts (1204 bytes)
- src\components\codeGeneration\Consumables\conditions\SystemCondition.ts (286 bytes)
- src\components\codeGeneration\Consumables\conditions\VoucherRedeemedCondition.ts (333 bytes)
- src\components\codeGeneration\Consumables\conditionUtils.ts (3699 bytes)
- src\components\codeGeneration\Consumables\effects/
- src\components\codeGeneration\Consumables\effects\AddCardsToHandEffect.ts (5871 bytes)
- src\components\codeGeneration\Consumables\effects\AddDollarsFromJokersEffect.ts (1596 bytes)
- src\components\codeGeneration\Consumables\effects\ConvertAllCardsToRankEffect.ts (4295 bytes)
- src\components\codeGeneration\Consumables\effects\ConvertAllCardsToSuitEffect.ts (4288 bytes)
- src\components\codeGeneration\Consumables\effects\ConvertLeftToRightEffect.ts (3000 bytes)
- src\components\codeGeneration\Consumables\effects\CopyRandomJokerEffect.ts (3400 bytes)
- src\components\codeGeneration\Consumables\effects\CopySelectedCardsEffect.ts (4445 bytes)
- src\components\codeGeneration\Consumables\effects\CreateConsumableEffect.ts (2460 bytes)
- src\components\codeGeneration\Consumables\effects\CreateJokerEffect.ts (3327 bytes)
- src\components\codeGeneration\Consumables\effects\CreateTagEffect.ts (2527 bytes)
- src\components\codeGeneration\Consumables\effects\DestroyConsumableEffect.ts (3046 bytes)
- src\components\codeGeneration\Consumables\effects\DestroyRandomCardsEffect.ts (1663 bytes)
- src\components\codeGeneration\Consumables\effects\DestroyRandomJokerEffect.ts (2488 bytes)
- src\components\codeGeneration\Consumables\effects\DestroySelectedCardsEffect.ts (1113 bytes)
- src\components\codeGeneration\Consumables\effects\DoubleDollarsEffect.ts (1305 bytes)
- src\components\codeGeneration\Consumables\effects\DrawCardsEffect.ts (1247 bytes)
- src\components\codeGeneration\Consumables\effects\EditBoosterSlotsEffect.ts (3703 bytes)
- src\components\codeGeneration\Consumables\effects\EditCardsEffect.ts (9722 bytes)
- src\components\codeGeneration\Consumables\effects\EditCardsInHandEffect.ts (9016 bytes)
- src\components\codeGeneration\Consumables\effects\EditDiscardsEffect.ts (3902 bytes)
- src\components\codeGeneration\Consumables\effects\EditDiscardSizeEffect.ts (3648 bytes)
- src\components\codeGeneration\Consumables\effects\EditDollarsEffect.ts (3565 bytes)
- src\components\codeGeneration\Consumables\effects\EditHandsEffect.ts (3819 bytes)
- src\components\codeGeneration\Consumables\effects\EditHandSizeEffect.ts (3595 bytes)
- src\components\codeGeneration\Consumables\effects\EditionRandomJokerEffect.ts (3224 bytes)
- src\components\codeGeneration\Consumables\effects\EditJokerSlotsEffect.ts (3572 bytes)
- src\components\codeGeneration\Consumables\effects\EditPlaySizeEffect.ts (3620 bytes)
- src\components\codeGeneration\Consumables\effects\EditVoucherSlotsEffect.ts (3703 bytes)
- src\components\codeGeneration\Consumables\effects\EmitFlagEffect.ts (1295 bytes)
- src\components\codeGeneration\Consumables\effects\FoolEffect.ts (1214 bytes)
- src\components\codeGeneration\Consumables\effects\IncrementRankEffect.ts (2956 bytes)
- src\components\codeGeneration\Consumables\effects\LevelUpHandEffect.ts (7408 bytes)
- src\components\codeGeneration\Consumables\effects\PermaBonusEffect.ts (3171 bytes)
- src\components\codeGeneration\Consumables\effects\PlaySoundEffect.ts (616 bytes)
- src\components\codeGeneration\Consumables\effects\RedeemVoucherEffect.ts (1312 bytes)
- src\components\codeGeneration\Consumables\effectUtils.ts (16365 bytes)
- src\components\codeGeneration\Consumables\gameVariableUtils.ts (3714 bytes)
- src\components\codeGeneration\Consumables\index.ts (16773 bytes)
- src\components\codeGeneration\entry.ts (17114 bytes)
- src\components\codeGeneration\ImageProcessor.ts (11044 bytes)
- src\components\codeGeneration\Jokers/
- src\components\codeGeneration\Jokers\conditions/
- src\components\codeGeneration\Jokers\conditions\AnteLevelCondition.ts (979 bytes)
- src\components\codeGeneration\Jokers\conditions\BlindNameCondition.ts (623 bytes)
- src\components\codeGeneration\Jokers\conditions\BlindRequirementsCondition.ts (1154 bytes)
- src\components\codeGeneration\Jokers\conditions\BlindTypeCondition.ts (542 bytes)
- src\components\codeGeneration\Jokers\conditions\BossBlindTypeCondition.ts (633 bytes)
- src\components\codeGeneration\Jokers\conditions\CardEditionCondition.ts (1379 bytes)
- src\components\codeGeneration\Jokers\conditions\CardEnhancementCondition.ts (1375 bytes)
- src\components\codeGeneration\Jokers\conditions\CardIndexCondition.ts (872 bytes)
- src\components\codeGeneration\Jokers\conditions\CardSealCondition.ts (1096 bytes)
- src\components\codeGeneration\Jokers\conditions\CheckFlagCondition.ts (577 bytes)
- src\components\codeGeneration\Jokers\conditions\ConsumableCountCondition.ts (2932 bytes)
- src\components\codeGeneration\Jokers\conditions\ConsumableTypeCondition.ts (2610 bytes)
- src\components\codeGeneration\Jokers\conditions\CountHandCondition.ts (2222 bytes)
- src\components\codeGeneration\Jokers\conditions\CumulativeChipsCondition.ts (1453 bytes)
- src\components\codeGeneration\Jokers\conditions\DeckCountCondition.ts (3350 bytes)
- src\components\codeGeneration\Jokers\conditions\DeckSizeCondition.ts (1138 bytes)
- src\components\codeGeneration\Jokers\conditions\EditionCountCondition.ts (1674 bytes)
- src\components\codeGeneration\Jokers\conditions\EnhancementCountCondition.ts (1731 bytes)
- src\components\codeGeneration\Jokers\conditions\FirstDiscardedHandCondition.ts (126 bytes)
- src\components\codeGeneration\Jokers\conditions\FirstHandPlayedCondition.ts (122 bytes)
- src\components\codeGeneration\Jokers\conditions\FirstLastScoredCondition.ts (3316 bytes)
- src\components\codeGeneration\Jokers\conditions\GenericCompareCondition.ts (1060 bytes)
- src\components\codeGeneration\Jokers\conditions\GlassCardDestroyedCondition.ts (266 bytes)
- src\components\codeGeneration\Jokers\conditions\HandLevelCondition.ts (1692 bytes)
- src\components\codeGeneration\Jokers\conditions\HandSizeCondition.ts (981 bytes)
- src\components\codeGeneration\Jokers\conditions\InternalVariableCondition.ts (1087 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerCountCondition.ts (1594 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerFlippedCondition.ts (317 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerKeyCondition.ts (479 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerPositionCondition.ts (1417 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerRarityCondition.ts (647 bytes)
- src\components\codeGeneration\Jokers\conditions\JokerStickerCondition.ts (658 bytes)
- src\components\codeGeneration\Jokers\conditions\LuckyCardTriggeredCondition.ts (126 bytes)
- src\components\codeGeneration\Jokers\conditions\PlayerMoneyCondition.ts (1027 bytes)
- src\components\codeGeneration\Jokers\conditions\PokerHandBeenPlayedCondition.ts (190 bytes)
- src\components\codeGeneration\Jokers\conditions\PokerHandCondition.ts (1848 bytes)
- src\components\codeGeneration\Jokers\conditions\ProbabilityIdentifierCondition.ts (589 bytes)
- src\components\codeGeneration\Jokers\conditions\ProbabilityPartCompareCondition.ts (1043 bytes)
- src\components\codeGeneration\Jokers\conditions\ProbabilitySucceededCondition.ts (349 bytes)
- src\components\codeGeneration\Jokers\conditions\RandomChanceCondition.ts (530 bytes)
- src\components\codeGeneration\Jokers\conditions\RankCardCondition.ts (10078 bytes)
- src\components\codeGeneration\Jokers\conditions\RemainingDiscardsCondition.ts (997 bytes)
- src\components\codeGeneration\Jokers\conditions\RemainingHandsCondition.ts (991 bytes)
- src\components\codeGeneration\Jokers\conditions\SealCountCondition.ts (1612 bytes)
- src\components\codeGeneration\Jokers\conditions\SpecificJokerCondition.ts (1042 bytes)
- src\components\codeGeneration\Jokers\conditions\SuitCardCondition.ts (8137 bytes)
- src\components\codeGeneration\Jokers\conditions\SystemCondition.ts (286 bytes)
- src\components\codeGeneration\Jokers\conditions\TriggeredBossBlindCondition.ts (116 bytes)
- src\components\codeGeneration\Jokers\conditions\VoucherRedeemedCondition.ts (333 bytes)
- src\components\codeGeneration\Jokers\conditions\WhichTagCondition.ts (703 bytes)
- src\components\codeGeneration\Jokers\conditionUtils.ts (12360 bytes)
- src\components\codeGeneration\Jokers\effects/
- src\components\codeGeneration\Jokers\effects\AddCardToDeckEffect.ts (5525 bytes)
- src\components\codeGeneration\Jokers\effects\AddCardToHandEffect.ts (5410 bytes)
- src\components\codeGeneration\Jokers\effects\AddChipsEffect.ts (822 bytes)
- src\components\codeGeneration\Jokers\effects\AddDollarsEffect.ts (837 bytes)
- src\components\codeGeneration\Jokers\effects\AddMultEffect.ts (809 bytes)
- src\components\codeGeneration\Jokers\effects\AddPlanetCardEffect.ts (4536 bytes)
- src\components\codeGeneration\Jokers\effects\AddSellValueEffect.ts (3508 bytes)
- src\components\codeGeneration\Jokers\effects\AddSpectralCardEffect.ts (4664 bytes)
- src\components\codeGeneration\Jokers\effects\AddTarotCardEffect.ts (3173 bytes)
- src\components\codeGeneration\Jokers\effects\AllowDebtEffect.ts (789 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyExpChipsEffect.ts (838 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyExpMultEffect.ts (834 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyHyperChipsEffect.ts (1177 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyHyperMultEffect.ts (1171 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyXChipsEffect.ts (836 bytes)
- src\components\codeGeneration\Jokers\effects\ApplyXMultEffect.ts (815 bytes)
- src\components\codeGeneration\Jokers\effects\BalanceEffect.ts (420 bytes)
- src\components\codeGeneration\Jokers\effects\BeatCurrentBlindEffect.ts (1117 bytes)
- src\components\codeGeneration\Jokers\effects\ChangePokerHandVariableEffect.ts (2819 bytes)
- src\components\codeGeneration\Jokers\effects\ChangeRankVariableEffect.ts (1977 bytes)
- src\components\codeGeneration\Jokers\effects\ChangeSuitVariableEffect.ts (1646 bytes)
- src\components\codeGeneration\Jokers\effects\CombineRanksEffect.ts (4299 bytes)
- src\components\codeGeneration\Jokers\effects\CombineSuitsEffect.ts (2283 bytes)
- src\components\codeGeneration\Jokers\effects\ConsideredAsEffect.ts (3752 bytes)
- src\components\codeGeneration\Jokers\effects\CopyCardToDeckEffect.ts (6836 bytes)
- src\components\codeGeneration\Jokers\effects\CopyCardToHandEffect.ts (7666 bytes)
- src\components\codeGeneration\Jokers\effects\CopyConsumableEffect.ts (7523 bytes)
- src\components\codeGeneration\Jokers\effects\CopyJokerAbilityEffect.ts (1634 bytes)
- src\components\codeGeneration\Jokers\effects\CopyJokerEffect.ts (5278 bytes)
- src\components\codeGeneration\Jokers\effects\CreateConsumableEffect.ts (5095 bytes)
- src\components\codeGeneration\Jokers\effects\CreateJokerEffect.ts (4600 bytes)
- src\components\codeGeneration\Jokers\effects\CreateTagEffect.ts (2952 bytes)
- src\components\codeGeneration\Jokers\effects\DeleteCardEffect.ts (1149 bytes)
- src\components\codeGeneration\Jokers\effects\DestroyConsumableEffect.ts (5892 bytes)
- src\components\codeGeneration\Jokers\effects\DestroyJokerEffect.ts (6351 bytes)
- src\components\codeGeneration\Jokers\effects\DestroySelfEffect.ts (685 bytes)
- src\components\codeGeneration\Jokers\effects\DisableBossBlindEffect.ts (2304 bytes)
- src\components\codeGeneration\Jokers\effects\DiscountItemsEffect.ts (5119 bytes)
- src\components\codeGeneration\Jokers\effects\DrawCardsEffect.ts (904 bytes)
- src\components\codeGeneration\Jokers\effects\EditBoosterSlotsEffect.ts (4952 bytes)
- src\components\codeGeneration\Jokers\effects\EditCardEffect.ts (3678 bytes)
- src\components\codeGeneration\Jokers\effects\EditConsumableSlotsEffect.ts (5804 bytes)
- src\components\codeGeneration\Jokers\effects\EditDiscardEffect.ts (5165 bytes)
- src\components\codeGeneration\Jokers\effects\EditDiscardSizeEffect.ts (4898 bytes)
- src\components\codeGeneration\Jokers\effects\EditHandEffect.ts (4845 bytes)
- src\components\codeGeneration\Jokers\effects\EditHandSizeEffect.ts (4748 bytes)
- src\components\codeGeneration\Jokers\effects\EditJokerSlotsEffect.ts (4861 bytes)
- src\components\codeGeneration\Jokers\effects\EditPlaySizeEffect.ts (4844 bytes)
- src\components\codeGeneration\Jokers\effects\EditVoucherSlotsEffect.ts (4957 bytes)
- src\components\codeGeneration\Jokers\effects\EmitFlagEffect.ts (1100 bytes)
- src\components\codeGeneration\Jokers\effects\FixProbabilityEffect.ts (1240 bytes)
- src\components\codeGeneration\Jokers\effects\FlipJokerEffect.ts (2755 bytes)
- src\components\codeGeneration\Jokers\effects\ForceGameOverEffect.ts (968 bytes)
- src\components\codeGeneration\Jokers\effects\JuiceUpEffect.ts (2534 bytes)
- src\components\codeGeneration\Jokers\effects\LevelUpHandEffect.ts (3741 bytes)
- src\components\codeGeneration\Jokers\effects\ModifyBlindRequirementEffect.ts (4289 bytes)
- src\components\codeGeneration\Jokers\effects\ModifyInternalVariableEffect.ts (3335 bytes)
- src\components\codeGeneration\Jokers\effects\ModProbabilityEffect.ts (1349 bytes)
- src\components\codeGeneration\Jokers\effects\PermaBonusEffect.ts (1600 bytes)
- src\components\codeGeneration\Jokers\effects\PlaySoundEffect.ts (616 bytes)
- src\components\codeGeneration\Jokers\effects\RedeemVoucherEffect.ts (1312 bytes)
- src\components\codeGeneration\Jokers\effects\ReduceFlushStraightRequirementsEffect.ts (1486 bytes)
- src\components\codeGeneration\Jokers\effects\RetriggerEffect.ts (855 bytes)
- src\components\codeGeneration\Jokers\effects\SavedEffect.ts (466 bytes)
- src\components\codeGeneration\Jokers\effects\SetAnteEffect.ts (2562 bytes)
- src\components\codeGeneration\Jokers\effects\SetDollarsEffect.ts (2401 bytes)
- src\components\codeGeneration\Jokers\effects\SetSellValueEffect.ts (4517 bytes)
- src\components\codeGeneration\Jokers\effects\ShortcutEffect.ts (1018 bytes)
- src\components\codeGeneration\Jokers\effects\ShowmanEffect.ts (1040 bytes)
- src\components\codeGeneration\Jokers\effects\ShowMessageEffect.ts (462 bytes)
- src\components\codeGeneration\Jokers\effects\ShuffleJokersEffect.ts (1361 bytes)
- src\components\codeGeneration\Jokers\effects\SplashEffect.ts (401 bytes)
- src\components\codeGeneration\Jokers\effects\SwapChipsMultEffect.ts (428 bytes)
- src\components\codeGeneration\Jokers\effects\UnlockJokerEffect.ts (998 bytes)
- src\components\codeGeneration\Jokers\effectUtils.ts (36049 bytes)
- src\components\codeGeneration\Jokers\gameVariableUtils.ts (4589 bytes)
- src\components\codeGeneration\Jokers\index.ts (64037 bytes)
- src\components\codeGeneration\Jokers\triggerUtils.ts (8113 bytes)
- src\components\codeGeneration\Jokers\unlockUtils.ts (12262 bytes)
- src\components\codeGeneration\Jokers\variableUtils.ts (25670 bytes)
- src\components\Contexts.tsx (1575 bytes)
- src\components\data/
- src\components\data\BalatroUtils.ts (52040 bytes)
- src\components\data\Card/
- src\components\data\Card\Conditions.ts (15122 bytes)
- src\components\data\Card\Effects.ts (30961 bytes)
- src\components\data\Card\Triggers.ts (1577 bytes)
- src\components\data\Consumables/
- src\components\data\Consumables\Conditions.ts (10570 bytes)
- src\components\data\Consumables\Effects.ts (35328 bytes)
- src\components\data\Consumables\Triggers.ts (758 bytes)
- src\components\data\Jokers/
- src\components\data\Jokers\Conditions.ts (52763 bytes)
- src\components\data\Jokers\Effects.ts (60136 bytes)
- src\components\data\Jokers\GameVars.ts (61019 bytes)
- src\components\data\Jokers\Triggers.ts (8080 bytes)
- src\components\generic/
- src\components\generic\Alert.tsx (3283 bytes)
- src\components\generic\BalatroCard.tsx (15 bytes)
- src\components\generic\balatroTextFormatter.tsx (14639 bytes)
- src\components\generic\Button.tsx (2255 bytes)
- src\components\generic\Checkbox.tsx (1033 bytes)
- src\components\generic\ConfirmationPopup.tsx (4706 bytes)
- src\components\generic\DonationNotification.tsx (1818 bytes)
- src\components\generic\ErrorBoundary.tsx (2164 bytes)
- src\components\generic\ExportModal.tsx (15 bytes)
- src\components\generic\InfoDescriptionBox.tsx (10315 bytes)
- src\components\generic\InputDropdown.tsx (7386 bytes)
- src\components\generic\InputField.tsx (5281 bytes)
- src\components\generic\Modal.tsx (4439 bytes)
- src\components\generic\RestoreProgressModal.tsx (3881 bytes)
- src\components\generic\RuleBuilderLoading.tsx (757 bytes)
- src\components\generic\ShowcaseModal.tsx (7547 bytes)
- src\components\generic\Tooltip.tsx (2811 bytes)
- src\components\generic\validationUtils.ts (6025 bytes)
- src\components\JSONImportExport.ts (14930 bytes)
- src\components\pages/
- src\components\pages\AcknowledgementsPage.tsx (4169 bytes)
- src\components\pages\boosters/
- src\components\pages\boosters\BoosterCard.tsx (16674 bytes)
- src\components\pages\boosters\EditBoosterInfo.tsx (37771 bytes)
- src\components\pages\BoostersPage.tsx (15 bytes)
- src\components\pages\consumables/
- src\components\pages\consumables\ConsumableCard.tsx (18978 bytes)
- src\components\pages\consumables\EditConsumableInfo.tsx (30278 bytes)
- src\components\pages\ConsumablesPage.tsx (15 bytes)
- src\components\pages\DecksPage.tsx (308 bytes)
- src\components\pages\editions/
- src\components\pages\editions\EditEditionInfo.tsx (28943 bytes)
- src\components\pages\editions\EditionCard.tsx (16636 bytes)
- src\components\pages\EditionsPage.tsx (15 bytes)
- src\components\pages\enhancements/
- src\components\pages\enhancements\EditEnhancementInfo.tsx (32473 bytes)
- src\components\pages\enhancements\EnhancementCard.tsx (18610 bytes)
- src\components\pages\EnhancementsPage.tsx (15 bytes)
- src\components\pages\jokers/
- src\components\pages\jokers\EditJokerInfo.tsx (56660 bytes)
- src\components\pages\jokers\JokerCard.tsx (22968 bytes)
- src\components\pages\JokersPage.tsx (15 bytes)
- src\components\pages\KeysPage.tsx (8820 bytes)
- src\components\pages\ModMetadataPage.tsx (27705 bytes)
- src\components\pages\NotFoundPage.tsx (2187 bytes)
- src\components\pages\OverviewPage.tsx (15 bytes)
- src\components\pages\RaritiesPage.tsx (15 bytes)
- src\components\pages\seals/
- src\components\pages\seals\EditSealInfo.tsx (30285 bytes)
- src\components\pages\seals\SealCard.tsx (17516 bytes)
- src\components\pages\SealsPage.tsx (15 bytes)
- src\components\pages\SkeletonPage.tsx (9405 bytes)
- src\components\pages\SoundPage.tsx (15 bytes)
- src\components\pages\vanillareforged/
- src\components\pages\vanillareforged\BoostersVanillaReforgedPage.tsx (15 bytes)
- src\components\pages\vanillareforged\ConsumablesVanillaReforgedPage.tsx (15 bytes)
- src\components\pages\vanillareforged\EnhancementsVanillaReforgedPage.tsx (15 bytes)
- src\components\pages\vanillareforged\JokersVanillaReforgedPage.tsx (15 bytes)
- src\components\pages\vanillareforged\SealsVanillaReforgedPage.tsx (15 bytes)
- src\components\ruleBuilder/
- src\components\ruleBuilder\BlockComponent.tsx (7042 bytes)
- src\components\ruleBuilder\BlockPalette.tsx (16865 bytes)
- src\components\ruleBuilder\FloatingDock.tsx (3358 bytes)
- src\components\ruleBuilder\GameVariables.tsx (10332 bytes)
- src\components\ruleBuilder\index.ts (593 bytes)
- src\components\ruleBuilder\Inspector.tsx (59258 bytes)
- src\components\ruleBuilder\RuleBuilder.tsx (15 bytes)
- src\components\ruleBuilder\RuleCard.tsx (37017 bytes)
- src\components\ruleBuilder\types.ts (3560 bytes)
- src\components\ruleBuilder\Variables.tsx (23070 bytes)
- src\components\Sidebar.tsx (25937 bytes)
- src\index.css (7131 bytes)
- src\main.tsx (351 bytes)
- src\vite-env.d.ts (38 bytes)

## Summary
- Total files: 319
- Total directories: 25
- Total text file size (including ignored): 1804.71 KB
- Total tokens: 421542
- Analyzed text content size: 1804.71 KB

Top largest non-ignored files:
- src\components\codeGeneration\Jokers\index.ts (62.54 kB)
- src\components\data\Jokers\GameVars.ts (59.59 kB)
- src\components\data\Jokers\Effects.ts (58.73 kB)
- src\components\ruleBuilder\Inspector.tsx (57.87 kB)
- src\components\pages\jokers\EditJokerInfo.tsx (55.33 kB)
- src\components\data\Jokers\Conditions.ts (51.53 kB)
- src\components\data\BalatroUtils.ts (50.82 kB)
- src\App.tsx (45.56 kB)
- src\components\codeGeneration\Card\index.ts (37.57 kB)
- src\components\pages\boosters\EditBoosterInfo.tsx (36.89 kB)

Top largest non-ignored directories:
- src\components (1751.81 kB)
- src\components\codeGeneration (784.16 kB)
- src\components\codeGeneration\Jokers (432.43 kB)
- src\components\pages (371.68 kB)
- src\components\data (320.66 kB)
- src\components\codeGeneration\Jokers\effects (204.72 kB)
- src\components\data\Jokers (177.73 kB)
- src\components\codeGeneration\Consumables (166.00 kB)
- src\components\ruleBuilder (157.33 kB)
- src\components\codeGeneration\Card (146.34 kB)


## Ignore summary:
During the analysis, some files were ignored:
- No of files ignored during parsing: 0
- Patterns used to ignore files: {'*.tmp', '.git', 'dist', '*.log', '*.dll', '*.egg-info', '*.pyc', '*.pyo', 'bower_components', '*.pyd', '.gitignore', 'Thumbs.db', '*.bak', '.DS_Store', 'venv', 'env', '.vscode', '.hg', '*.swp', '*.dylib', '__pycache__', 'build', '.idea', '*.so', '.svn', '.venv', 'node_modules'}

## Files:
### src\App.tsx

```
import {
  useState,
  useEffect,
  useCallback,
  useRef,
  Suspense,
  lazy,
} from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  useLocation,
  useNavigate,
} from "react-router-dom";
import { motion, AnimatePresence } from "framer-motion";
import {
  PuzzlePieceIcon,
  SwatchIcon,
  CpuChipIcon,
  CakeIcon,
  StarIcon,
  DocumentTextIcon,
  GiftIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";

// Pages
import OverviewPage from "./components/pages/OverviewPage";
import ModMetadataPage from "./components/pages/ModMetadataPage";

const JokersPage = lazy(() => import("./components/pages/JokersPage"));
const RaritiesPage = lazy(() => import("./components/pages/RaritiesPage"));
const ConsumablesPage = lazy(
  () => import("./components/pages/ConsumablesPage")
);
const DecksPage = lazy(() => import("./components/pages/DecksPage"));
const EditionsPage = lazy(() => import("./components/pages/EditionsPage"));
const BoostersPage = lazy(() => import("./components/pages/BoostersPage"));
const EnhancementsPage = lazy(
  () => import("./components/pages/EnhancementsPage")
);
const SealsPage = lazy(() => import("./components/pages/SealsPage"));

const JokersVanillaReforgedPage = lazy(
  () => import("./components/pages/vanillareforged/JokersVanillaReforgedPage")
);
const ConsumablesVanillaReforgedPage = lazy(
  () =>
    import("./components/pages/vanillareforged/ConsumablesVanillaReforgedPage")
);
const BoostersVanillaReforgedPage = lazy(
  () => import("./components/pages/vanillareforged/BoostersVanillaReforgedPage")
);
const EnhancementsVanillaReforgedPage = lazy(
  () =>
    import("./components/pages/vanillareforged/EnhancementsVanillaReforgedPage")
);
const SealsVanillaReforgedPage = lazy(
  () => import("./components/pages/vanillareforged/SealsVanillaReforgedPage")
);

const AcknowledgementsPage = lazy(
  () => import("./components/pages/AcknowledgementsPage")
);
const NotFoundPage = lazy(() => import("./components/pages/NotFoundPage"));

const KeysPage = lazy(() => import("./components/pages/KeysPage"));

// Core components
import Sidebar from "./components/Sidebar";

// Data and Utils
import {
  ConsumableData,
  JokerData,
  RarityData,
  ConsumableSetData,
  BoosterData,
  updateDataRegistry,
  EnhancementData,
  SealData,
  ModMetadata,
  EditionData,
  SoundData,
} from "./components/data/BalatroUtils";
import Alert from "./components/generic/Alert";
import ConfirmationPopup from "./components/generic/ConfirmationPopup";
import ExportModal from "./components/generic/ExportModal";
import DonationNotification from "./components/generic/DonationNotification";
import RestoreProgressModal from "./components/generic/RestoreProgressModal";
import { DEFAULT_MOD_METADATA } from "./components/pages/ModMetadataPage";
import SkeletonPage from "./components/pages/SkeletonPage";
import { UserConfigProvider } from "./components/Contexts";
import SoundsPage from "./components/pages/SoundPage";
interface AlertState {
  isVisible: boolean;
  type: "success" | "warning" | "error";
  title: string;
  content: string;
}

interface ConfirmationState {
  isVisible: boolean;
  type: "default" | "warning" | "danger" | "success";
  title: string;
  description: string;
  confirmText: string;
  cancelText: string;
  confirmVariant?: "primary" | "secondary" | "danger";
  icon?: React.ReactNode;
  onConfirm: () => void;
  onCancel?: () => void;
}

interface AutoSaveData {
  modMetadata: ModMetadata;
  jokers: JokerData[];
  sounds: SoundData[];
  consumables: ConsumableData[];
  customRarities: RarityData[];
  consumableSets: ConsumableSetData[];
  boosters: BoosterData[];
  enhancements: EnhancementData[];
  seals: SealData[];
  editions: EditionData[];
  timestamp: number;
}

const AUTO_SAVE_KEY = "joker-forge-autosave";
const DONATION_DISMISSED_KEY = "joker-forge-donation-dismissed";
const DONATION_SHOW_DELAY = 1000 * 60 * 5; // 5 minutes

const FloatingTabDock: React.FC<{
  activeTab:
    | "jokers"
    | "rarities"
    | "consumables"
    | "boosters"
    | "enhancements"
    | "seals"
    | "editions";
  onTabChange: (
    tab:
      | "jokers"
      | "rarities"
      | "consumables"
      | "boosters"
      | "enhancements"
      | "seals"
      | "editions"
  ) => void;
  isVanillaMode: boolean;
}> = ({ activeTab, onTabChange, isVanillaMode }) => {
  const regularTabs = [
    {
      id: "jokers" as const,
      icon: PuzzlePieceIcon,
      label: "Jokers",
    },
    {
      id: "rarities" as const,
      icon: SwatchIcon,
      label: "Rarities",
    },
  ];

  const vanillaTabs = [
    {
      id: "jokers" as const,
      icon: DocumentTextIcon,
      label: "Jokers",
    },
    {
      id: "consumables" as const,
      icon: CakeIcon,
      label: "Consumables",
    },
    {
      id: "boosters" as const,
      icon: GiftIcon,
      label: "Boosters",
    },
    {
      id: "enhancements" as const,
      icon: StarIcon,
      label: "Enhancements",
    },
    {
      id: "seals" as const,
      icon: CpuChipIcon,
      label: "Seals",
    },
    {
      id: "editions" as const,
      icon: SparklesIcon,
      label: "Editions",
    },
  ];

  const tabs = isVanillaMode ? vanillaTabs : regularTabs;

  return (
    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-40">
      <div className="bg-black-dark border-2 border-black-lighter rounded-full px-3 py-2 shadow-2xl">
        <div className="flex items-center gap-2">
          {tabs.map((tab) => {
            const Icon = tab.icon;
            const isActive = activeTab === tab.id;

            return (
              <button
                key={tab.id}
                onClick={() => onTabChange(tab.id)}
                className={`
                  relative group p-3 rounded-full transition-all duration-200 cursor-pointer
                  ${
                    isActive
                      ? "bg-mint/20 border-2 border-mint text-mint scale-110"
                      : "bg-black-darker/50 border-2 border-black-lighter text-white-darker hover:border-mint hover:text-mint hover:scale-105"
                  }
                `}
                title={tab.label}
              >
                <Icon className="h-5 w-5" />

                <div className="absolute -top-12 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none">
                  <div className="bg-black-darker border border-black-lighter rounded-lg px-2 py-1 whitespace-nowrap">
                    <span className="text-white-light text-xs font-medium">
                      {tab.label}
                    </span>
                  </div>
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black-lighter"></div>
                </div>
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
};

function AppContent() {
  const location = useLocation();
  const navigate = useNavigate();

  const currentSection = location.pathname.slice(1) || "overview";
  const isExpanded = currentSection === "overview" || currentSection === "";

  const [boosters, setBoosters] = useState<BoosterData[]>([]);
  const [selectedBoosterId, setSelectedBoosterId] = useState<string | null>(
    null
  );

  const [editions, setEditions] = useState<EditionData[]>([]);
  const [selectedEditionId, setSelectedEditionId] = useState<string | null>(
    null
  );

  const [modMetadata, setModMetadata] =
    useState<ModMetadata>(DEFAULT_MOD_METADATA);

  const [jokers, setJokers] = useState<JokerData[]>([]);
  const [sounds, setSounds] = useState<SoundData[]>([]);
  const [consumables, setConsumables] = useState<ConsumableData[]>([]);
  const [customRarities, setCustomRarities] = useState<RarityData[]>([]);
  const [consumableSets, setConsumableSets] = useState<ConsumableSetData[]>([]);
  const [enhancements, setEnhancements] = useState<EnhancementData[]>([]);
  const [selectedEnhancementId, setSelectedEnhancementId] = useState<
    string | null
  >(null);
  const [seals, setSeals] = useState<SealData[]>([]);
  const [selectedSealId, setSelectedSealId] = useState<string | null>(null);

  const [selectedJokerId, setSelectedJokerId] = useState<string | null>(null);
  const [selectedConsumableId, setSelectedConsumableId] = useState<
    string | null
  >(null);
  const [exportLoading, setExportLoading] = useState(false);
  const [alert, setAlert] = useState<AlertState>({
    isVisible: false,
    type: "success",
    title: "",
    content: "",
  });
  const [confirmation, setConfirmation] = useState<ConfirmationState>({
    isVisible: false,
    type: "default",
    title: "",
    description: "",
    confirmText: "Confirm",
    cancelText: "Cancel",
    onConfirm: () => {},
  });
  const [autoSaveStatus, setAutoSaveStatus] = useState<
    "idle" | "saving" | "saved"
  >("idle");
  const [showRestoreModal, setShowRestoreModal] = useState(false);
  const [hasLoadedInitialData, setHasLoadedInitialData] = useState(false);
  const [showExportModal, setShowExportModal] = useState(false);
  const [jokersRaritiesTab, setJokersRaritiesTab] = useState<
    "jokers" | "rarities"
  >("jokers");
  const [showDonationNotification, setShowDonationNotification] =
    useState(false);

  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const statusTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const clearStatusTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const donationTimerRef = useRef<NodeJS.Timeout | null>(null);
  const prevDataRef = useRef<{
    modMetadata: ModMetadata;
    jokers: JokerData[];
    sounds: SoundData[];
    consumables: ConsumableData[];
    customRarities: RarityData[];
    consumableSets: ConsumableSetData[];
    boosters: BoosterData[];
    enhancements: EnhancementData[];
    seals: SealData[];
    editions: EditionData[];
  } | null>(null);

  const showConfirmation = useCallback(
    (options: {
      type?: "default" | "warning" | "danger" | "success";
      title: string;
      description: string;
      confirmText?: string;
      cancelText?: string;
      confirmVariant?: "primary" | "secondary" | "danger";
      icon?: React.ReactNode;
      onConfirm: () => void;
      onCancel?: () => void;
    }) => {
      setConfirmation({
        isVisible: true,
        type: options.type || "default",
        title: options.title,
        description: options.description,
        confirmText: options.confirmText || "Confirm",
        cancelText: options.cancelText || "Cancel",
        confirmVariant: options.confirmVariant,
        icon: options.icon,
        onConfirm: options.onConfirm,
        onCancel: options.onCancel,
      });
    },
    []
  );

  const getVanillaActiveTab = ():
    | "jokers"
    | "consumables"
    | "boosters"
    | "enhancements"
    | "seals"
    | "editions" => {
    const path = location.pathname;
    if (path.includes("/vanilla/consumables")) return "consumables";
    if (path.includes("/vanilla/boosters")) return "boosters";
    if (path.includes("/vanilla/enhancements")) return "enhancements";
    if (path.includes("/vanilla/seals")) return "seals";
    if (path.includes("/vanilla/editions")) return "editions";
    return "jokers";
  };

  const isVanillaMode = location.pathname.startsWith("/vanilla");

  const handleTabChange = (
    tab:
      | "jokers"
      | "rarities"
      | "consumables"
      | "boosters"
      | "enhancements"
      | "seals"
      | "editions"
  ) => {
    if (isVanillaMode) {
      navigate(`/vanilla/${tab}`);
    } else {
      setJokersRaritiesTab(tab as "jokers" | "rarities");
    }
  };

  const getActiveTab = () => {
    if (isVanillaMode) {
      return getVanillaActiveTab();
    }
    return jokersRaritiesTab;
  };

  const showFloatingDock = currentSection === "jokers" || isVanillaMode;

  const hideConfirmation = useCallback(() => {
    setConfirmation((prev) => ({ ...prev, isVisible: false }));
  }, []);

  const handleConfirm = () => {
    confirmation.onConfirm();
    hideConfirmation();
  };

  const handleCancel = () => {
    if (confirmation.onCancel) {
      confirmation.onCancel();
    }
    hideConfirmation();
  };

  const saveToLocalStorage = useCallback(
    (
      metadata: ModMetadata,
      jokerData: JokerData[],
      soundData: SoundData[],
      consumableData: ConsumableData[],
      raritiesData: RarityData[],
      setsData: ConsumableSetData[],
      boosterData: BoosterData[],
      enhancementsData: EnhancementData[],
      sealsData: SealData[],
      editionsData: EditionData[]
    ) => {
      try {
        const data: AutoSaveData = {
          modMetadata: metadata,
          jokers: jokerData,
          sounds: soundData,
          consumables: consumableData,
          customRarities: raritiesData,
          consumableSets: setsData,
          boosters: boosterData,
          enhancements: enhancementsData,
          seals: sealsData,
          editions: editionsData,
          timestamp: Date.now(),
        };
        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(data));
        console.log("Auto-saved project state");
      } catch (error) {
        console.warn("Failed to auto-save:", error);
      }
    },
    []
  );

  useEffect(() => {
    updateDataRegistry(
      customRarities,
      consumableSets,
      consumables,
      boosters,
      enhancements,
      seals,
      editions,
      modMetadata.prefix || ""
    );
  }, [
    customRarities,
    consumableSets,
    consumables,
    boosters,
    enhancements,
    seals,
    editions,
    modMetadata.prefix,
  ]);

  useEffect(() => {
    const checkDonationDismissal = () => {
      const stored = localStorage.getItem(DONATION_DISMISSED_KEY);
      if (!stored) return false;

      try {
        const dismissData = JSON.parse(stored);
        const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

        return dismissData.timestamp > oneWeekAgo;
      } catch {
        localStorage.removeItem(DONATION_DISMISSED_KEY);
        return false;
      }
    };

    const isDonationDismissed = checkDonationDismissal();

    if (!isDonationDismissed) {
      donationTimerRef.current = setTimeout(() => {
        setShowDonationNotification(true);
      }, DONATION_SHOW_DELAY);
    }

    return () => {
      if (donationTimerRef.current) {
        clearTimeout(donationTimerRef.current);
      }
    };
  }, []);

  const handleDonationClose = () => {
    setShowDonationNotification(false);
  };

  const handleDonationDonate = () => {
    window.open("https://ko-fi.com/jaydchw", "_blank");
    setShowDonationNotification(false);
  };

  const handleDonationDismissTemporarily = () => {
    const dismissData = {
      dismissed: true,
      timestamp: Date.now(),
    };
    localStorage.setItem(DONATION_DISMISSED_KEY, JSON.stringify(dismissData));
    setShowDonationNotification(false);
  };

  const loadFromLocalStorage = useCallback((): {
    modMetadata: ModMetadata;
    jokers: JokerData[];
    sounds: SoundData[];
    consumables: ConsumableData[];
    customRarities: RarityData[];
    consumableSets: ConsumableSetData[];
    boosters: BoosterData[];
    enhancements: EnhancementData[];
    seals: SealData[];
    editions: EditionData[];
  } | null => {
    try {
      const savedData = localStorage.getItem(AUTO_SAVE_KEY);
      if (!savedData) return null;

      const data: AutoSaveData = JSON.parse(savedData);

      if (!data.modMetadata || !Array.isArray(data.jokers)) {
        console.warn("Invalid auto-save data structure");
        localStorage.removeItem(AUTO_SAVE_KEY);
        return null;
      }

      console.log("Loaded auto-saved project state");
      return {
        modMetadata: data.modMetadata,
        jokers: data.jokers,
        sounds: data.sounds,
        consumables: data.consumables || [],
        customRarities: data.customRarities || [],
        consumableSets: data.consumableSets || [],
        boosters: data.boosters || [],
        enhancements: data.enhancements || [],
        editions: data.editions || [],
        seals: data.seals || [],
      };
    } catch (error) {
      console.warn("Failed to load auto-save:", error);
      localStorage.removeItem(AUTO_SAVE_KEY);
      return null;
    }
  }, []);

  const clearAutoSave = useCallback(() => {
    try {
      localStorage.removeItem(AUTO_SAVE_KEY);
      console.log("Cleared auto-save data");
    } catch (error) {
      console.warn("Failed to clear auto-save:", error);
    }
  }, []);

  const getAutoSaveMetadata = useCallback((): {
    timestamp: number;
    daysOld: number;
  } | null => {
    try {
      const savedData = localStorage.getItem(AUTO_SAVE_KEY);
      if (!savedData) return null;

      const data: AutoSaveData = JSON.parse(savedData);
      const daysOld = (Date.now() - data.timestamp) / (24 * 60 * 60 * 1000);

      return {
        timestamp: data.timestamp,
        daysOld: Math.floor(daysOld * 10) / 10,
      };
    } catch {
      return null;
    }
  }, []);

  const hasDataChanged = useCallback(
    (
      metadata: ModMetadata,
      jokerData: JokerData[],
      soundData: SoundData[],
      consumableData: ConsumableData[],
      raritiesData: RarityData[],
      setsData: ConsumableSetData[],
      boosterData: BoosterData[],
      enhancementsData: EnhancementData[],
      sealsData: SealData[],
      editionsData: EditionData[]
    ) => {
      if (!prevDataRef.current) return true;

      const prevData = prevDataRef.current;
      return (
        JSON.stringify(prevData.modMetadata) !== JSON.stringify(metadata) ||
        JSON.stringify(prevData.jokers) !== JSON.stringify(jokerData) ||
        JSON.stringify(prevData.sounds) !== JSON.stringify(soundData) ||
        JSON.stringify(prevData.consumables) !==
          JSON.stringify(consumableData) ||
        JSON.stringify(prevData.customRarities) !==
          JSON.stringify(raritiesData) ||
        JSON.stringify(prevData.consumableSets) !== JSON.stringify(setsData) ||
        JSON.stringify(prevData.boosters) !== JSON.stringify(boosterData) ||
        JSON.stringify(prevData.enhancements) !==
          JSON.stringify(enhancementsData) ||
        JSON.stringify(prevData.seals) !== JSON.stringify(sealsData) ||
        JSON.stringify(prevData.editions) !== JSON.stringify(editionsData)
      );
    },
    []
  );

  const isDataDifferentFromDefaults = useCallback(
    (
      metadata: ModMetadata,
      jokerData: JokerData[],
      soundData: SoundData[],
      consumableData: ConsumableData[],
      raritiesData: RarityData[],
      setsData: ConsumableSetData[],
      boosterData: BoosterData[],
      enhancementsData: EnhancementData[],
      sealsData: SealData[],
      editionsData: EditionData[]
    ) => {
      if (
        jokerData.length > 0 ||
        soundData.length > 0 ||
        consumableData.length > 0 ||
        raritiesData.length > 0 ||
        setsData.length > 0 ||
        boosterData.length > 0 ||
        enhancementsData.length > 0 ||
        sealsData.length > 0 ||
        editionsData.length > 0
      )
        return true;

      const defaultMetadata = DEFAULT_MOD_METADATA;

      const significantFields: (keyof ModMetadata)[] = [
        "name",
        "author",
        "description",
        "id",
        "prefix",
      ];

      for (const field of significantFields) {
        if (
          JSON.stringify(metadata[field]) !==
          JSON.stringify(defaultMetadata[field])
        ) {
          return true;
        }
      }

      return false;
    },
    []
  );

  const debouncedSave = useCallback(
    (
      metadata: ModMetadata,
      jokerData: JokerData[],
      soundData: SoundData[],
      consumableData: ConsumableData[],
      raritiesData: RarityData[],
      setsData: ConsumableSetData[],
      boosterData: BoosterData[],
      enhancementsData: EnhancementData[],
      sealsData: SealData[],
      editionsData: EditionData[]
    ) => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }

      saveTimeoutRef.current = setTimeout(() => {
        saveToLocalStorage(
          metadata,
          jokerData,
          soundData,
          consumableData,
          raritiesData,
          setsData,
          boosterData,
          enhancementsData,
          sealsData,
          editionsData
        );
      }, 500);
    },
    [saveToLocalStorage]
  );

  useEffect(() => {
    const loadAutoSave = () => {
      const savedData = loadFromLocalStorage();
      if (savedData) {
        setShowRestoreModal(true);
      }
      setHasLoadedInitialData(true);
    };

    loadAutoSave();
  }, [loadFromLocalStorage]);

  useEffect(() => {
    if (!hasLoadedInitialData) return;

    if (
      !isDataDifferentFromDefaults(
        modMetadata,
        jokers,
        sounds,
        consumables,
        customRarities,
        consumableSets,
        boosters,
        enhancements,
        seals,
        editions
      )
    )
      return;

    if (
      !hasDataChanged(
        modMetadata,
        jokers,
        sounds,
        consumables,
        customRarities,
        consumableSets,
        boosters,
        enhancements,
        seals,
        editions
      )
    )
      return;

    prevDataRef.current = {
      modMetadata,
      jokers,
      sounds,
      consumables,
      customRarities,
      consumableSets,
      boosters,
      enhancements,
      seals,
      editions,
    };

    setAutoSaveStatus("saving");

    debouncedSave(
      modMetadata,
      jokers,
      sounds,
      consumables,
      customRarities,
      consumableSets,
      boosters,
      enhancements,
      seals,
      editions
    );

    if (statusTimeoutRef.current) {
      clearTimeout(statusTimeoutRef.current);
    }
    if (clearStatusTimeoutRef.current) {
      clearTimeout(clearStatusTimeoutRef.current);
    }

    statusTimeoutRef.current = setTimeout(() => {
      setAutoSaveStatus("saved");
    }, 400);

    clearStatusTimeoutRef.current = setTimeout(() => {
      setAutoSaveStatus("idle");
    }, 1000);

    return () => {
      if (statusTimeoutRef.current) {
        clearTimeout(statusTimeoutRef.current);
      }
      if (clearStatusTimeoutRef.current) {
        clearTimeout(clearStatusTimeoutRef.current);
      }
    };
  }, [
    modMetadata,
    jokers,
    sounds,
    consumables,
    customRarities,
    consumableSets,
    boosters,
    enhancements,
    seals,
    editions,
    hasLoadedInitialData,
    debouncedSave,
    hasDataChanged,
    isDataDifferentFromDefaults,
  ]);

  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      if (statusTimeoutRef.current) {
        clearTimeout(statusTimeoutRef.current);
      }
      if (clearStatusTimeoutRef.current) {
        clearTimeout(clearStatusTimeoutRef.current);
      }
      if (donationTimerRef.current) {
        clearTimeout(donationTimerRef.current);
      }
    };
  }, []);

  // this is bad but i am tired
  const handleRestoreAutoSave = async () => {
    const savedData = loadFromLocalStorage();
    if (savedData) {
      try {
        // Dynamically import normalization function
        const { normalizeImportedModData } = await import(
          "./components/JSONImportExport"
        );

        const normalizedData = normalizeImportedModData({
          metadata: savedData.modMetadata,
          jokers: savedData.jokers,
          sounds: savedData.sounds,
          consumables: savedData.consumables,
          customRarities: savedData.customRarities,
          consumableSets: savedData.consumableSets,
          boosters: savedData.boosters,
          enhancements: savedData.enhancements,
          seals: savedData.seals,
          editions: savedData.editions,
        });

        setModMetadata(normalizedData.metadata);
        setJokers(normalizedData.jokers);
        setSounds(normalizedData.sounds)
        setConsumables(normalizedData.consumables);
        setCustomRarities(normalizedData.customRarities);
        setConsumableSets(normalizedData.consumableSets);
        setBoosters(normalizedData.boosters);
        setEnhancements(normalizedData.enhancements);
        setSeals(normalizedData.seals);
        setEditions(normalizedData.editions);

        setSelectedJokerId(null);
        setSelectedConsumableId(null);
        setSelectedBoosterId(null);
        setSelectedEnhancementId(null);
        setSelectedSealId(null);
        setSelectedEditionId(null);

        prevDataRef.current = {
          modMetadata: normalizedData.metadata,
          jokers: normalizedData.jokers,
          sounds: normalizedData.sounds,
          consumables: normalizedData.consumables,
          customRarities: normalizedData.customRarities,
          consumableSets: normalizedData.consumableSets,
          boosters: normalizedData.boosters,
          enhancements: normalizedData.enhancements,
          seals: normalizedData.seals,
          editions: normalizedData.editions,
        };

        showAlert(
          "success",
          "Project Restored",
          "Your auto-saved project has been restored successfully!"
        );
      } catch (error) {
        console.error("Failed to restore autosave due to invalid data:", error);
        showAlert(
          "error",
          "Restore Failed",
          "The auto-saved data is corrupted and could not be restored. Starting a fresh project."
        );
        clearAutoSave();
      }
    }
    setShowRestoreModal(false);
  };

  const handleDiscardAutoSave = () => {
    clearAutoSave();
    setShowRestoreModal(false);
  };

  const showAlert = (
    type: "success" | "warning" | "error",
    title: string,
    content: string
  ) => {
    setAlert({
      isVisible: true,
      type,
      title,
      content,
    });
  };

  const hideAlert = () => {
    setAlert((prev) => ({ ...prev, isVisible: false }));
  };

  const handleNavigate = (section: string) => {
    navigate(`/${section}`);
  };

  const handleExport = async () => {
    if (
      !modMetadata.author ||
      modMetadata.author.length === 0 ||
      !modMetadata.author[0].trim()
    ) {
      showAlert(
        "error",
        "Export Failed",
        "Please enter an author name before exporting."
      );
      return;
    }

    if (!modMetadata.name.trim()) {
      showAlert(
        "error",
        "Export Failed",
        "Please enter a mod name before exporting."
      );
      return;
    }

    const invalidJokers = jokers.filter((j) => !j.name || !j.id);
    const invalidConsumables = consumables.filter((c) => !c.name || !c.id);
    const invalidBoosters = boosters.filter((b) => !b.name || !b.id);
    const invalidEnhancements = enhancements.filter((e) => !e.name || !e.id);
    const invalidSeals = seals.filter((s) => !s.name || !s.id);
    const invalidEditions = editions.filter((e) => !e.name || !e.id);

    if (
      invalidJokers.length > 0 ||
      invalidConsumables.length > 0 ||
      invalidBoosters.length > 0 ||
      invalidEnhancements.length > 0 ||
      invalidSeals.length > 0 ||
      invalidEditions.length > 0
    ) {
      showAlert(
        "error",
        "Export Failed",
        `Some items are missing required fields (name/id). Please check all items before exporting.`
      );
      return;
    }

    setExportLoading(true);
    try {
      // Dynamically import the export function
      const { exportModCode } = await import(
        "./components/codeGeneration/entry"
      );

      await exportModCode(
        jokers,
        sounds,
        consumables,
        modMetadata,
        customRarities,
        consumableSets,
        boosters,
        enhancements,
        seals,
        editions
      );
      setShowExportModal(true);
    } catch (error) {
      console.error("Export failed:", error);

      let errorMessage = "Failed to export mod files. Please try again.";
      if (error instanceof Error) {
        if (error.message.includes("Missing required metadata")) {
          errorMessage =
            "Missing required metadata fields. Please check your mod information.";
        } else if (error.message.includes("Cannot read properties")) {
          errorMessage =
            "Some mod items have missing or invalid data. Please check all fields are filled correctly.";
        }
      }

      showAlert("error", "Export Failed", errorMessage);
    } finally {
      setExportLoading(false);
    }
  };

  const handleExportJSON = async () => {
    try {
      const { exportModAsJSON } = await import("./components/JSONImportExport");

      exportModAsJSON(
        modMetadata,
        jokers,
        sounds,
        customRarities,
        consumables,
        consumableSets,
        boosters,
        enhancements,
        seals,
        editions
      );
      showAlert(
        "success",
        "Mod Saved",
        "Your mod has been saved as a jokerforge file!"
      );
    } catch (error) {
      console.error("JSON export failed:", error);
      showAlert(
        "error",
        "Save Failed",
        "Failed to save mod as JSON. Please try again."
      );
    }
  };

  const handleImportJSON = async () => {
    try {
      // Dynamically import the import functions
      const { importModFromJSON, normalizeImportedModData } = await import(
        "./components/JSONImportExport"
      );

      const importedData = await importModFromJSON();
      if (importedData) {
        const normalizedData = normalizeImportedModData(importedData);

        setModMetadata(normalizedData.metadata);
        setJokers(normalizedData.jokers);
        setSounds(normalizedData.sounds);
        setConsumables(normalizedData.consumables);
        setCustomRarities(normalizedData.customRarities);
        setConsumableSets(normalizedData.consumableSets);
        setBoosters(normalizedData.boosters);
        setEnhancements(normalizedData.enhancements || []);
        setSeals(normalizedData.seals || []);
        setEditions(normalizedData.editions || []);
        setSounds(normalizedData.sounds)
        setSelectedJokerId(null);
        setSelectedConsumableId(null);
        setSelectedBoosterId(null);
        setSelectedEnhancementId(null);
        setSelectedSealId(null);
        setSelectedEditionId(null);
        prevDataRef.current = {
          modMetadata: normalizedData.metadata,
          jokers: normalizedData.jokers,
          sounds: normalizedData.sounds,
          consumables: normalizedData.consumables,
          customRarities: normalizedData.customRarities,
          consumableSets: normalizedData.consumableSets,
          boosters: normalizedData.boosters,
          enhancements: normalizedData.enhancements || [],
          seals: normalizedData.seals || [],
          editions: normalizedData.editions || [],
        };
        showAlert(
          "success",
          "Mod Imported",
          "Your mod has been imported successfully!"
        );
      }
    } catch (error) {
      console.error("JSON import failed:", error);
      showAlert(
        "error",
        "Import Failed",
        "Failed to import mod. Please check the file format and try again."
      );
    }
  };

  return (
    <div className="h-screen bg-black-darker flex overflow-hidden">
      <Sidebar
        selectedSection={currentSection}
        onSectionChange={handleNavigate}
        projectName={modMetadata.id || "mycustommod"}
        onExport={handleExport}
        onExportJSON={handleExportJSON}
        onImportJSON={handleImportJSON}
        exportLoading={exportLoading}
        jokers={jokers}
        modName={modMetadata.name}
        authorName={modMetadata.author.join(", ")}
      />
      <motion.div
        className="flex-1 flex flex-col overflow-y-auto custom-scrollbar"
        animate={{
          marginLeft: isExpanded ? 0 : 0,
        }}
        transition={{
          type: "spring",
          stiffness: 300,
          damping: 30,
        }}
      >
        <Routes>
          <Route
            path="/"
            element={
              <OverviewPage
                jokerCount={jokers.length}
                jokers={jokers}
                modName={modMetadata.name}
                authorName={modMetadata.author.join(", ")}
                metadata={modMetadata}
                setMetadata={setModMetadata}
                onExport={handleExport}
                onNavigate={handleNavigate}
              />
            }
          />
          <Route
            path="/overview"
            element={
              <OverviewPage
                jokerCount={jokers.length}
                jokers={jokers}
                modName={modMetadata.name}
                authorName={modMetadata.author.join(", ")}
                metadata={modMetadata}
                setMetadata={setModMetadata}
                onExport={handleExport}
                onNavigate={handleNavigate}
              />
            }
          />
          <Route
            path="/metadata"
            element={
              <Suspense fallback={<SkeletonPage variant="metadata" />}>
                <ModMetadataPage
                  metadata={modMetadata}
                  setMetadata={setModMetadata}
                />
              </Suspense>
            }
          />
          <Route
            path="/jokers"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                {jokersRaritiesTab === "jokers" ? (
                  <JokersPage
                    modName={modMetadata.name}
                    jokers={jokers}
                    setJokers={setJokers}
                    selectedJokerId={selectedJokerId}
                    setSelectedJokerId={setSelectedJokerId}
                    customRarities={customRarities}
                    modPrefix={modMetadata.prefix || ""}
                    showConfirmation={showConfirmation}
                  />
                ) : (
                  <RaritiesPage
                    modName={modMetadata.name}
                    rarities={customRarities}
                    setRarities={setCustomRarities}
                    showConfirmation={showConfirmation}
                  />
                )}
              </Suspense>
            }
          />
          <Route
            path="/sounds"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={false}
                    showFilters={true}
                  />
                }
              >
                <SoundsPage
                  modName={modMetadata.name}
                  sounds={sounds}
                  setSounds={setSounds}
                  showConfirmation={showConfirmation}
                />
              </Suspense>
            }
          />
          <Route
            path="/consumables"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <ConsumablesPage
                  modName={modMetadata.name}
                  consumables={consumables}
                  setConsumables={setConsumables}
                  selectedConsumableId={selectedConsumableId}
                  setSelectedConsumableId={setSelectedConsumableId}
                  modPrefix={modMetadata.prefix || ""}
                  consumableSets={consumableSets}
                  setConsumableSets={setConsumableSets}
                  showConfirmation={showConfirmation}
                />
              </Suspense>
            }
          />
          <Route
            path="/boosters"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <BoostersPage
                  modName={modMetadata.name}
                  boosters={boosters}
                  setBoosters={setBoosters}
                  selectedBoosterId={selectedBoosterId}
                  setSelectedBoosterId={setSelectedBoosterId}
                  modPrefix={modMetadata.prefix || ""}
                  showConfirmation={showConfirmation}
                  consumableSets={consumableSets}
                />
              </Suspense>
            }
          />
          <Route
            path="/enhancements"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <EnhancementsPage
                  modName={modMetadata.name}
                  enhancements={enhancements}
                  setEnhancements={setEnhancements}
                  selectedEnhancementId={selectedEnhancementId}
                  setSelectedEnhancementId={setSelectedEnhancementId}
                  modPrefix={modMetadata.prefix || ""}
                  showConfirmation={showConfirmation}
                />
              </Suspense>
            }
          />
          <Route
            path="/seals"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <SealsPage
                  modName={modMetadata.name}
                  seals={seals}
                  setSeals={setSeals}
                  selectedSealId={selectedSealId}
                  setSelectedSealId={setSelectedSealId}
                  modPrefix={modMetadata.prefix || ""}
                  showConfirmation={showConfirmation}
                />
              </Suspense>
            }
          />
          <Route path="/decks" element={<DecksPage />} />
          <Route
            path="/editions"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <EditionsPage
                  modName={modMetadata.name}
                  editions={editions}
                  setEditions={setEditions}
                  selectedEditionId={selectedEditionId}
                  setSelectedEditionId={setSelectedEditionId}
                  modPrefix={modMetadata.prefix || ""}
                  showConfirmation={showConfirmation}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla/jokers"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <JokersVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setJokers([...jokers, item as JokerData]);
                  }}
                  onNavigateToJokers={() => {
                    navigate("/jokers");
                  }}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla/consumables"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <ConsumablesVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setConsumables([...consumables, item as ConsumableData]);
                  }}
                  onNavigateToConsumables={() => {
                    navigate("/consumables");
                  }}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla/boosters"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <BoostersVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setBoosters([...boosters, item as BoosterData]);
                  }}
                  onNavigateToBoosters={() => {
                    navigate("/boosters");
                  }}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla/enhancements"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <EnhancementsVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setEnhancements([...enhancements, item as EnhancementData]);
                  }}
                  onNavigateToEnhancements={() => {
                    navigate("/enhancements");
                  }}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla/seals"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <SealsVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setSeals([...seals, item as SealData]);
                  }}
                  onNavigateToSeals={() => {
                    navigate("/seals");
                  }}
                />
              </Suspense>
            }
          />
          <Route
            path="/vanilla"
            element={
              <Suspense
                fallback={
                  <SkeletonPage
                    variant="grid"
                    showFloatingDock={true}
                    showFilters={true}
                  />
                }
              >
                <JokersVanillaReforgedPage
                  onDuplicateToProject={(item) => {
                    setJokers([...jokers, item as JokerData]);
                  }}
                  onNavigateToJokers={() => {
                    navigate("/jokers");
                  }}
                />
              </Suspense>
            }
          />

          <Route path="/acknowledgements" element={<AcknowledgementsPage />} />
          <Route path="*" element={<NotFoundPage />} />

          <Route
            path="/keys"
            element={
              <Suspense fallback={<SkeletonPage variant="grid" />}>
                <KeysPage />
              </Suspense>
            }
          />
          <Route
            path="/keys/:section"
            element={
              <Suspense fallback={<SkeletonPage variant="grid" />}>
                <KeysPage />
              </Suspense>
            }
          />
        </Routes>
      </motion.div>

      {showFloatingDock && (
        <FloatingTabDock
          activeTab={getActiveTab()}
          onTabChange={handleTabChange}
          isVanillaMode={isVanillaMode}
        />
      )}

      <DonationNotification
        isVisible={showDonationNotification}
        onClose={handleDonationClose}
        onDonate={handleDonationDonate}
        onDismissTemporarily={handleDonationDismissTemporarily}
      />

      <AnimatePresence>
        {autoSaveStatus !== "idle" && (
          <motion.div
            initial={{ x: 100, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 100, opacity: 0 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 30,
            }}
            className="fixed bottom-4 right-4 z-50"
          >
            <div
              className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-300 ${
                autoSaveStatus === "saving"
                  ? "bg-mint-darker text-white-light border border-mint-dark"
                  : "bg-mint-light text-black-dark border border-mint-lighter"
              }`}
            >
              {autoSaveStatus === "saving" ? "Auto-saving..." : "Auto-saved"}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      <RestoreProgressModal
        isVisible={showRestoreModal}
        onRestore={handleRestoreAutoSave}
        onDiscard={handleDiscardAutoSave}
        getAutoSaveMetadata={getAutoSaveMetadata}
      />

      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
      />

      <Alert
        isVisible={alert.isVisible}
        type={alert.type}
        title={alert.title}
        content={alert.content}
        onClose={hideAlert}
      />

      <ConfirmationPopup
        isVisible={confirmation.isVisible}
        type={confirmation.type}
        title={confirmation.title}
        description={confirmation.description}
        confirmText={confirmation.confirmText}
        cancelText={confirmation.cancelText}
        confirmVariant={confirmation.confirmVariant}
        icon={confirmation.icon}
        onConfirm={handleConfirm}
        onCancel={handleCancel}
      />
    </div>
  );
}

function App() {
  return (
    <UserConfigProvider>
      <Router>
        <AppContent />
      </Router>
    </UserConfigProvider>
  );
}

export default App;

```

### src\components\codeGeneration\boosters.ts

```
import { BoosterData, BoosterCardRule } from "../data/BalatroUtils";

export const generateBoostersCode = (
  boosters: BoosterData[],
  modPrefix: string
): { boostersCode: string } => {
  if (boosters.length === 0) {
    return { boostersCode: "" };
  }

  let code = "";

  boosters.forEach((booster, index) => {
    if (index > 0) code += "\n\n";
    code += generateSingleBooster(booster, modPrefix, index);
  });

  return { boostersCode: code };
};

const generateSingleBooster = (
  booster: BoosterData,
  modPrefix: string,
  index: number
): string => {
  const cleanKey = booster.boosterKey || sanitizeKey(booster.name);

  let code = `SMODS.Booster {\n`;
  code += `    key = '${cleanKey}',\n`;

  code += `    loc_txt = {\n`;
  code += `        name = "${booster.name}",\n`;
  code += `        text = {\n`;

  const descriptionLines = booster.description
    .replace(/\[s\]/g, "\n")
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line.length > 0);

  descriptionLines.forEach((line, lineIndex) => {
    const cleanLine = line.replace(/\{[^}]*\}/g, "").replace(/"/g, '\\"');
    code += `            "${cleanLine}"${
      lineIndex < descriptionLines.length - 1 ? "," : ""
    }\n`;
  });

  code += `        },\n`;

  const groupName = booster.group_key
    ? `"${booster.group_key}"`
    : `"${booster.name}"`;
  code += `        group_name = ${groupName}\n`;
  code += `    },\n`;

  code += `    config = { extra = ${booster.config.extra}, choose = ${booster.config.choose} },\n`;

  if (booster.cost !== undefined && booster.cost !== 4) {
    code += `    cost = ${booster.cost},\n`;
  }

  if (booster.weight !== undefined && booster.weight !== 1) {
    code += `    weight = ${booster.weight},\n`;
  }

  code += `    atlas = "CustomBoosters",\n`;

  const posX = index % 10;
  const posY = Math.floor(index / 10);
  code += `    pos = { x = ${posX}, y = ${posY} },\n`;

  if (booster.kind) {
    code += `    kind = '${booster.kind}',\n`;
  }

  if (booster.group_key) {
    code += `    group_key = "${booster.group_key}",\n`;
  }

  if (booster.draw_hand) {
    code += `    draw_hand = true,\n`;
  }

  if (booster.booster_type === "consumable" && booster.instant_use == false) {
    code += `    select_card = "consumeables",\n`;
  }

  if (booster.discovered === true) {
    code += `    discovered = true,\n`;
  }

  if (booster.hidden === true) {
    code += `    hidden = true,\n`;
  }

  code += `    loc_vars = function(self, info_queue, card)\n`;
  code += `        local cfg = (card and card.ability) or self.config\n`;
  code += `        return {\n`;
  code += `            vars = { cfg.choose, cfg.extra }\n`;
  code += `        }\n`;
  code += `    end,\n`;

  if (booster.card_rules && booster.card_rules.length > 0) {
    code += generateCreateCardFunction(booster, modPrefix);
  } else {
    code += generateDefaultCreateCardFunction(booster.booster_type);
  }

  if (booster.background_colour || booster.special_colour) {
    code += generateEaseBackgroundFunction(
      booster.background_colour,
      booster.special_colour
    );
  }

  code += generateParticlesFunction(booster.booster_type);

  code += `}\n`;

  return code;
};

const generateCreateCardFunction = (
  booster: BoosterData,
  modPrefix: string
): string => {
  const rules = booster.card_rules;
  if (!rules || rules.length === 0) {
    return generateDefaultCreateCardFunction(booster.booster_type);
  }

  let code = `    create_card = function(self, card, i)\n`;

  if (rules.length === 1) {
    const rule = rules[0];
    code += `        return {\n`;
    code += generateCardConfigFromRule(
      rule,
      booster.booster_type,
      "        ",
      modPrefix
    );
    code += `            area = G.pack_cards,\n`;
    code += `            skip_materialize = true,\n`;
    code += `            soulable = true,\n`;
    code += `            key_append = "${modPrefix}_${
      booster.boosterKey || "booster"
    }"\n`;
    code += `        }\n`;
  } else {
    const hasWeights = rules.some((rule) => rule.weight && rule.weight !== 1);

    if (hasWeights) {
      code += `        local weights = {\n`;
      rules.forEach((rule, index) => {
        code += `            ${rule.weight || 1}${
          index < rules.length - 1 ? "," : ""
        }\n`;
      });
      code += `        }\n`;
      code += `        local total_weight = 0\n`;
      code += `        for _, weight in ipairs(weights) do\n`;
      code += `            total_weight = total_weight + weight\n`;
      code += `        end\n`;
      code += `        local random_value = pseudorandom('${modPrefix}_${
        booster.boosterKey || "booster"
      }_card') * total_weight\n`;
      code += `        local cumulative_weight = 0\n`;
      code += `        local selected_index = 1\n`;
      code += `        for j, weight in ipairs(weights) do\n`;
      code += `            cumulative_weight = cumulative_weight + weight\n`;
      code += `            if random_value <= cumulative_weight then\n`;
      code += `                selected_index = j\n`;
      code += `                break\n`;
      code += `            end\n`;
      code += `        end\n`;
    } else {
      code += `        local selected_index = pseudorandom('${modPrefix}_${
        booster.boosterKey || "booster"
      }_card', 1, ${rules.length})\n`;
    }

    rules.forEach((rule, index) => {
      const condition = index === 0 ? "if" : "elseif";
      code += `        ${condition} selected_index == ${index + 1} then\n`;
      code += `            return {\n`;
      code += generateCardConfigFromRule(
        rule,
        booster.booster_type,
        "            ",
        modPrefix
      );
      code += `                area = G.pack_cards,\n`;
      code += `                skip_materialize = true,\n`;
      code += `                soulable = true,\n`;
      code += `                key_append = "${modPrefix}_${
        booster.boosterKey || "booster"
      }"\n`;
      code += `            }\n`;
    });
    code += `        end\n`;
  }

  code += `    end,\n`;
  return code;
};

const formatRarityForCode = (rarity: string, modPrefix: string): string => {
  if (!rarity || rarity === "" || rarity === "any") return "";

  if (["1", "2", "3", "4"].includes(rarity)) {
    const rarityMap: Record<string, string> = {
      "1": "Common",
      "2": "Uncommon",
      "3": "Rare",
      "4": "Legendary",
    };
    return rarityMap[rarity];
  }

  if (
    ["common", "uncommon", "rare", "legendary"].includes(rarity.toLowerCase())
  ) {
    return rarity.charAt(0).toUpperCase() + rarity.slice(1).toLowerCase();
  }

  return `${modPrefix}_${rarity}`;
};

const generateCardConfigFromRule = (
  rule: BoosterCardRule,
  boosterType: string,
  indent: string = "        ",
  modPrefix: string = ""
): string => {
  let config = "";

  if (rule.specific_key) {
    config += `${indent}key = "${rule.specific_key}",\n`;
  }

  if (boosterType === "joker") {
    if (rule.pool && rule.pool.trim()) {
      const finalPool = modPrefix
        ? `${modPrefix}_${rule.pool.trim()}`
        : rule.pool.trim();
      config += `${indent}set = "${finalPool}",\n`;
    } else {
      config += `${indent}set = "Joker",\n`;
    }

    if (rule.rarity && rule.rarity !== "" && rule.rarity !== "any") {
      const formattedRarity = formatRarityForCode(rule.rarity, modPrefix);
      if (formattedRarity) {
        config += `${indent}rarity = "${formattedRarity}",\n`;
      }
    }
  } else if (boosterType === "playing_card") {
    config += `${indent}set = "Playing Card",\n`;

    if (rule.suit && rule.suit !== "" && rule.suit !== "any") {
      config += `${indent}suit = "${rule.suit}",\n`;
    }

    if (rule.rank && rule.rank !== "" && rule.rank !== "any") {
      config += `${indent}rank = "${rule.rank}",\n`;
    }

    if (
      rule.enhancement &&
      rule.enhancement !== "" &&
      rule.enhancement !== "any" &&
      rule.enhancement !== "none"
    ) {
      config += `${indent}enhancement = "${rule.enhancement}",\n`;
    }
  } else if (boosterType === "consumable") {
    const set = rule.set || "Tarot";
    config += `${indent}set = "${set}",\n`;
  }

  if (
    rule.edition &&
    rule.edition !== "" &&
    rule.edition !== "any" &&
    rule.edition !== "none"
  ) {
    config += `${indent}edition = "${rule.edition}",\n`;
  }

  if (
    rule.seal &&
    rule.seal !== "" &&
    rule.seal !== "any" &&
    rule.seal !== "none"
  ) {
    config += `${indent}seal = "${rule.seal}",\n`;
  }

  return config;
};

const generateDefaultCreateCardFunction = (boosterType: string): string => {
  let code = `    create_card = function(self, card, i)\n`;
  code += `        return {\n`;

  switch (boosterType) {
    case "joker":
      code += `            set = "Joker",\n`;
      break;
    case "playing_card":
      code += `            set = "Playing Card",\n`;
      break;
    case "consumable":
    default:
      code += `            set = "Tarot",\n`;
      break;
  }

  code += `            area = G.pack_cards,\n`;
  code += `            skip_materialize = true,\n`;
  code += `            soulable = true\n`;
  code += `        }\n`;
  code += `    end,\n`;

  return code;
};

const generateEaseBackgroundFunction = (
  backgroundColor?: string,
  specialColor?: string
): string => {
  if (!backgroundColor && !specialColor) return "";

  let code = `    ease_background_colour = function(self)\n`;

  if (backgroundColor && specialColor) {
    const bgHex = backgroundColor.startsWith("#")
      ? backgroundColor.slice(1)
      : backgroundColor;
    const specialHex = specialColor.startsWith("#")
      ? specialColor.slice(1)
      : specialColor;
    code += `        ease_colour(G.C.DYN_UI.MAIN, HEX("${bgHex}"))\n`;
    code += `        ease_background_colour({ new_colour = HEX('${bgHex}'), special_colour = HEX("${specialHex}"), contrast = 2 })\n`;
  } else if (backgroundColor) {
    const bgHex = backgroundColor.startsWith("#")
      ? backgroundColor.slice(1)
      : backgroundColor;
    code += `        ease_background_colour({ new_colour = HEX('${bgHex}') })\n`;
  }

  code += `    end,\n`;
  return code;
};

const generateParticlesFunction = (boosterType: string): string => {
  let code = `    particles = function(self)\n`;

  switch (boosterType) {
    case "joker":
      code += `        -- No particles for joker packs\n`;
      break;
    case "consumable":
      code += `        G.booster_pack_sparkles = Particles(1, 1, 0, 0, {\n`;
      code += `            timer = 0.015,\n`;
      code += `            scale = 0.2,\n`;
      code += `            initialize = true,\n`;
      code += `            lifespan = 1,\n`;
      code += `            speed = 1.1,\n`;
      code += `            padding = -1,\n`;
      code += `            attach = G.ROOM_ATTACH,\n`;
      code += `            colours = { G.C.WHITE, lighten(G.C.PURPLE, 0.4), lighten(G.C.PURPLE, 0.2), lighten(G.C.GOLD, 0.2) },\n`;
      code += `            fill = true\n`;
      code += `        })\n`;
      code += `        G.booster_pack_sparkles.fade_alpha = 1\n`;
      code += `        G.booster_pack_sparkles:fade(1, 0)\n`;
      break;
    case "playing_card":
    default:
      code += `        G.booster_pack_sparkles = Particles(1, 1, 0, 0, {\n`;
      code += `            timer = 0.015,\n`;
      code += `            scale = 0.3,\n`;
      code += `            initialize = true,\n`;
      code += `            lifespan = 3,\n`;
      code += `            speed = 0.2,\n`;
      code += `            padding = -1,\n`;
      code += `            attach = G.ROOM_ATTACH,\n`;
      code += `            colours = { G.C.BLACK, G.C.RED },\n`;
      code += `            fill = true\n`;
      code += `        })\n`;
      code += `        G.booster_pack_sparkles.fade_alpha = 1\n`;
      code += `        G.booster_pack_sparkles:fade(1, 0)\n`;
      break;
  }

  code += `    end,\n`;
  return code;
};

const sanitizeKey = (name: string): string => {
  return (
    name
      .toLowerCase()
      .replace(/[^a-zA-Z0-9\s]/g, "")
      .replace(/\s+/g, "_")
      .replace(/^[0-9]+/, "") || "custom_booster"
  );
};

```

### src\components\codeGeneration\Card\conditions\AnteLevelCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateAnteLevelConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "ante_level") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.round_resets.ante ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\BlindRequirementsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateBlindRequirementsConditionCode = (
  rules: Rule[]
): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "blind_requirements") return "";

  const operator = (condition.params?.operator as string) || "greater_equals";
  const percentageValue =
    generateGameVariableCode(condition.params?.percentage) || 25;

  const decimal = Number(percentageValue) / 100;

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== to_big(${decimal})`;
      break;
    case "not_equals":
      comparison = `~= to_big(${decimal})`;
      break;
    case "greater_than":
      comparison = `> to_big(${decimal})`;
      break;
    case "less_than":
      comparison = `< to_big(${decimal})`;
      break;
    case "greater_equals":
      comparison = `>= to_big(${decimal})`;
      break;
    case "less_equals":
      comparison = `<= to_big(${decimal})`;
      break;
    default:
      comparison = `>= to_big(${decimal})`;
  }

  return `G.GAME.chips / G.GAME.blind.chips ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\BlindTypeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateBlindTypeConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "blind_type") return "";

  const blindType = (condition.params?.blind_type as string) || "small";

  switch (blindType) {
    case "small":
      return `G.GAME.blind:get_type() == 'Small'`;
    case "big":
      return `G.GAME.blind:get_type() == 'Big'`;
    case "boss":
      return `G.GAME.blind.boss`;
    default:
      return `G.GAME.blind.small`;
  }
};

```

### src\components\codeGeneration\Card\conditions\CardEditionCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardEditionConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "card_edition") return "";

  const editionType = (condition.params?.edition as string) || "any";

  if (editionType === "any") {
    return `card.edition ~= nil`;
  } else if (editionType === "none") {
    return `card.edition == nil`;
  } else {
    return `card.edition and card.edition.key == "${editionType}"`;
  }
};

```

### src\components\codeGeneration\Card\conditions\CardIndexCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateCardIndexConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "card_index") return "";

  const indexType = (condition.params?.index_type as string) || "number";
  const indexNumber =
    generateGameVariableCode(condition.params?.index_number) || "1";

  if (indexType === "first") {
    return `card == context.scoring_hand[1]`;
  } else if (indexType === "last") {
    return `card == context.scoring_hand[#context.scoring_hand]`;
  } else {
    return `card == context.scoring_hand[${indexNumber}]`;
  }
};

```

### src\components\codeGeneration\Card\conditions\CardRankCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { getRankId } from "../../../data/BalatroUtils";

export const generateCardRankConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "card_rank") return "";

  const rankType = (condition.params?.rank_type as string) || "specific";
  const specificRank = condition.params?.specific_rank as string;
  const rankGroup = condition.params?.rank_group as string;

  if (rankType === "specific" && specificRank) {
    const rankId = getRankId(specificRank);
    return `card:get_id() == ${rankId}`;
  } else if (rankType === "group" && rankGroup) {
    switch (rankGroup) {
      case "face":
        return `card:is_face()`;
      case "even":
        return `(card:get_id() == 2 or card:get_id() == 4 or card:get_id() == 6 or card:get_id() == 8 or card:get_id() == 10)`;
      case "odd":
        return `(card:get_id() == 14 or card:get_id() == 3 or card:get_id() == 5 or card:get_id() == 7 or card:get_id() == 9)`;
      default:
        return "";
    }
  }

  return "";
};

```

### src\components\codeGeneration\Card\conditions\CardSealCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardSealConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "card_seal") return "";

  const sealType = (condition.params?.seal as string) || "any";

  const capitalizedSealType =
    sealType === "any"
      ? "any"
      : sealType.charAt(0).toUpperCase() + sealType.slice(1).toLowerCase();

  return sealType === "any"
    ? `card.seal ~= nil`
    : `card.seal == "${capitalizedSealType}"`;
};

```

### src\components\codeGeneration\Card\conditions\CardSuitCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardSuitConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "card_suit") return "";

  const suitType = (condition.params?.suit_type as string) || "specific";
  const specificSuit = condition.params?.specific_suit as string;
  const suitGroup = condition.params?.suit_group as string;

  if (suitType === "specific" && specificSuit) {
    return `card:is_suit("${specificSuit}")`;
  } else if (suitType === "group" && suitGroup) {
    switch (suitGroup) {
      case "red":
        return `(card:is_suit("Hearts") or card:is_suit("Diamonds"))`;
      case "black":
        return `(card:is_suit("Spades") or card:is_suit("Clubs"))`;
      default:
        return "";
    }
  }

  return "";
};

```

### src\components\codeGeneration\Card\conditions\CheckFlagCondition.ts

```
import { getModPrefix } from "../../../data/BalatroUtils";
import type { Rule } from "../../../ruleBuilder/types";

export const generateCheckFlagConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const flagName = (condition.params.flag_name as string) || "custom_flag";

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore

  const modPrefix = getModPrefix()

  return `(G.GAME.pool_flags.${modPrefix}_${safeFlagName} or false)`;
};

```

### src\components\codeGeneration\Card\conditions\DeckSizeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateDeckSizeConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "deck_size") return "";

  const sizeType = (condition.params?.size_type as string) || "remaining";
  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value) || "52";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const deckSizeRef =
    sizeType === "remaining" ? "#G.deck.cards" : "#G.playing_cards";

  return `${deckSizeRef} ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\FirstPlayedHandCondition.ts

```
export const generateFirstPlayedHandConditionCode = (): string => {
  return `G.GAME.current_round.hands_played == 0`;
};

```

### src\components\codeGeneration\Card\conditions\GenericCompareCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateGenericCompareConditionCode = (
  rules: Rule[],
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const value1 =
    generateGameVariableCode(condition.params.value1, itemType) || "0";
  const operator = (condition.params.operator as string) || "equals";
  const value2 =
    generateGameVariableCode(condition.params.value2, itemType) || "0";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value2}`;
      break;
    case "not_equals":
      comparison = `~= ${value2}`;
      break;
    case "greater_than":
      comparison = `> ${value2}`;
      break;
    case "less_than":
      comparison = `< ${value2}`;
      break;
    case "greater_equals":
      comparison = `>= ${value2}`;
      break;
    case "less_equals":
      comparison = `<= ${value2}`;
      break;
    default:
      comparison = `== ${value2}`;
  }

  return `${value1} ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\HandLevelCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateHandLevelConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "hand_level") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value) || "1";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const handSelection =
    (condition?.params?.hand_selection as string) || "played";
  const specificHand =
    (condition?.params?.specific_hand as string) || "High Card";

  let handDeterminationCode = "";
  switch (handSelection) {
    case "played":
      handDeterminationCode = `hand == context.scoring_name`;
      break;
    case "specific":
      handDeterminationCode = `hand == "${specificHand}"`;
      break;
    case "any":
      handDeterminationCode = `hand`;
      break;
    default:
      handDeterminationCode = `hand == "High Card"`;
  }

  return `(function()
    for hand, data in pairs(G.GAME.hands) do
        if ${handDeterminationCode} and data.level ${comparison} then
            return true
        end
    end
    return false
end)()`;
};

```

### src\components\codeGeneration\Card\conditions\HandSizeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateHandSizeConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "hand_size") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value) || "8";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.hand.config.card_limit ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\InternalVariableCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateInternalVariableConditionCode = (
  rules: Rule[],
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const variableName = (condition.params.variable_name as string) || "var1";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "0";

  const abilityPath =
    itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";
  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `(${abilityPath}.${variableName} or 0) ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\JokerCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";
import { getAllRarities, getModPrefix } from "../../../data/BalatroUtils";

export const generateJokerCountConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "joker_count") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const rarity = (condition.params?.rarity as string) || "any";
  const value = generateGameVariableCode(condition.params?.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  if (rarity === "any") {
    return `#G.jokers.cards ${comparison}`;
  }

  const rarityData = getAllRarities().find((r) => r.key === rarity);
  const modPrefix = getModPrefix();
  const rarityValue = rarityData?.isCustom
    ? `"${modPrefix}_${rarity}"`
    : rarityData?.value;

  return `(function()
    local count = 0
    for _, joker_owned in pairs(G.jokers.cards or {}) do
        if joker_owned.config.center.rarity == ${rarityValue} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Card\conditions\PlayerMoneyCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Consumables/gameVariableUtils";

export const generatePlayerMoneyConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "player_money") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value || 0;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `G.GAME.dollars > to_big(${valueCode})`;
    case "greater_equals":
      return `G.GAME.dollars >= to_big(${valueCode})`;
    case "less_than":
      return `G.GAME.dollars < to_big(${valueCode})`;
    case "less_equals":
      return `G.GAME.dollars <= to_big(${valueCode})`;
    case "equals":
      return `G.GAME.dollars == to_big(${valueCode})`;
    case "not_equal":
      return `G.GAME.dollars ~= to_big(${valueCode})`;
    default:
      return `G.GAME.dollars > to_big(${valueCode})`;
  }
};

```

### src\components\codeGeneration\Card\conditions\PokerHandCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generatePokerHandConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const condition = rules[0].conditionGroups[0].conditions[0];
  const scope = condition.params.card_scope as string || "scoring";
  const operator = condition.params.operator as string || "contains";
  const handType = condition.params.value as string || "High Card";

    if (handType === "most_played_hand") {
      return `(function()
    local current_played = G.GAME.hands[context.scoring_name].played or 0
    for handname, values in pairs(G.GAME.hands) do
        if handname ~= context.scoring_name and values.played > current_played and values.visible then
            return false
        end
    end
    return true
end)()`;
    }

    if (handType === "least_played_hand") {
      return `(function()
    local current_played = G.GAME.hands[context.scoring_name].played or 0
    for handname, values in pairs(G.GAME.hands) do
        if handname ~= context.scoring_name and values.played < current_played and values.visible then
            return false
        end
    end
    return true
end)()`;
    }

    if (operator === "contains") {
      return `next(context.poker_hands["${handType}"])`;
    }

    if (scope === "scoring") {
      return `context.scoring_name == "${handType}"`;
    } else if (scope === "all_played") {
      return `next(context.poker_hands["${handType}"])`;
    }

    return `true`;
};

```

### src\components\codeGeneration\Card\conditions\RemainingDiscardsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateRemainingDiscardsConditionCode = (
  rules: Rule[]
): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "remaining_discards") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.current_round.discards_left ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\RemainingHandsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../../Jokers/gameVariableUtils";

export const generateRemainingHandsConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "remaining_hands") return "";

  const operator = (condition.params?.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params?.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.current_round.hands_left ${comparison}`;
};

```

### src\components\codeGeneration\Card\conditions\SpecificJokerCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateSpecificJokerConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "specific_joker") return "";

  const operator = (condition.params?.operator as string) || "has";
  const jokerKey = (condition.params?.joker_key as string) || "j_joker";

  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  if (operator === "has") {
    return `(function()
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].config.center.key == "${normalizedJokerKey}" then
            return true
        end
    end
    return false
end)()`;
  } else if (operator === "does_not_have") {
    return `(function()
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].config.center.key == "${normalizedJokerKey}" then
            return false
        end
    end
    return true
end)()`;
  }

  return "";
};

```

### src\components\codeGeneration\Card\conditions\SystemCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateSystemConditionCode = (
  rules: Rule[],
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];

  return `love.system.getOS() == "${condition.params?.system || "Windows"}"`;
};

```

### src\components\codeGeneration\Card\conditions\TriggeredBossBlindCondition.ts

```
export const generateTriggeredBossBlindConditionCode = (): string => {
  return `G.GAME.blind.triggered`;
};

```

### src\components\codeGeneration\Card\conditions\VoucherRedeemedCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateVoucherRedeemedConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "voucher_redeemed") return "";

  const voucher = (condition.params?.voucher as string) || "v_overstock_norm";

  return `G.GAME.used_vouchers["${voucher}"]`;
};

```

### src\components\codeGeneration\Card\conditionUtils.ts

```
import type { Rule, Condition, ConditionGroup } from "../../ruleBuilder/types";
import { generatePlayerMoneyConditionCode } from "./conditions/PlayerMoneyCondition";
import { generateCardRankConditionCode } from "./conditions/CardRankCondition";
import { generateCardSuitConditionCode } from "./conditions/CardSuitCondition";
import { generateCardEditionConditionCode } from "./conditions/CardEditionCondition";
import { generateCardSealConditionCode } from "./conditions/CardSealCondition";
import { generateCardIndexConditionCode } from "./conditions/CardIndexCondition";
import { generateBlindTypeConditionCode } from "./conditions/BlindTypeCondition";
import { generateAnteLevelConditionCode } from "./conditions/AnteLevelCondition";
import { generateHandSizeConditionCode } from "./conditions/HandSizeCondition";
import { generateRemainingHandsConditionCode } from "./conditions/RemainingHandsCondition";
import { generateRemainingDiscardsConditionCode } from "./conditions/RemainingDiscardsCondition";
import { generateFirstPlayedHandConditionCode } from "./conditions/FirstPlayedHandCondition";
import { generatePokerHandConditionCode } from "./conditions/PokerHandCondition";
import { generateHandLevelConditionCode } from "./conditions/HandLevelCondition";
import { generateBlindRequirementsConditionCode } from "./conditions/BlindRequirementsCondition";
import { generateJokerCountConditionCode } from "./conditions/JokerCountCondition";
import { generateSpecificJokerConditionCode } from "./conditions/SpecificJokerCondition";
import { generateDeckSizeConditionCode } from "./conditions/DeckSizeCondition";
import { generateVoucherRedeemedConditionCode } from "./conditions/VoucherRedeemedCondition";
import { generateTriggeredBossBlindConditionCode } from "./conditions/TriggeredBossBlindCondition";
import { generateInternalVariableConditionCode } from "./conditions/InternalVariableCondition";
import { generateGenericCompareConditionCode } from "./conditions/GenericCompareCondition";
import { generateCheckFlagConditionCode } from "./conditions/CheckFlagCondition";
import { generateSystemConditionCode } from "./conditions/SystemCondition";

export const generateConditionChain = (
  rule: Rule,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): string => {
  if (!rule.conditionGroups || rule.conditionGroups.length === 0) {
    return "";
  }

  const groupConditions: string[] = [];

  rule.conditionGroups.forEach((group) => {
    const conditions = generateConditionGroupCode(group, rule, itemType);
    if (conditions) {
      groupConditions.push(conditions);
    }
  });

  if (groupConditions.length === 0) {
    return "";
  }

  if (groupConditions.length === 1) {
    return groupConditions[0];
  }

  return `(${groupConditions.join(") and (")})`;
};

const generateConditionGroupCode = (
  group: ConditionGroup,
  rule: Rule,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): string => {
  if (!group.conditions || group.conditions.length === 0) {
    return "";
  }

  const conditionCodes: string[] = [];

  group.conditions.forEach((condition) => {
    const code = generateSingleConditionCode(condition, rule, itemType);
    if (code) {
      let finalCode = code;

      if (condition.negate) {
        finalCode = `not (${code})`;
      }

      conditionCodes.push(finalCode);
    }
  });

  if (conditionCodes.length === 0) {
    return "";
  }

  if (conditionCodes.length === 1) {
    return conditionCodes[0];
  }

  let result = conditionCodes[0];
  for (let i = 1; i < conditionCodes.length; i++) {
    const prevCondition = group.conditions[i - 1];
    const operator = prevCondition.operator === "or" ? " or " : " and ";
    result += operator + conditionCodes[i];
  }

  return `(${result})`;
};

const generateSingleConditionCode = (
  condition: Condition,
  rule: Rule,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): string | null => {
  const singleConditionRule = {
    ...rule,
    conditionGroups: [
      {
        ...rule.conditionGroups[0],
        conditions: [condition],
      },
    ],
  };

  switch (condition.type) {
    case "player_money":
      return generatePlayerMoneyConditionCode([singleConditionRule]);

    case "card_rank":
      return generateCardRankConditionCode([singleConditionRule]);

    case "card_suit":
      return generateCardSuitConditionCode([singleConditionRule]);

    case "card_edition":
      return generateCardEditionConditionCode([singleConditionRule]);

    case "card_seal":
      return generateCardSealConditionCode([singleConditionRule]);

    case "card_index":
      return generateCardIndexConditionCode([singleConditionRule]);

    case "blind_type":
      return generateBlindTypeConditionCode([singleConditionRule]);

    case "ante_level":
      return generateAnteLevelConditionCode([singleConditionRule]);

    case "hand_size":
      return generateHandSizeConditionCode([singleConditionRule]);

    case "remaining_hands":
      return generateRemainingHandsConditionCode([singleConditionRule]);

    case "remaining_discards":
      return generateRemainingDiscardsConditionCode([singleConditionRule]);

    case "first_played_hand":
      return generateFirstPlayedHandConditionCode();

    case "poker_hand":
      return generatePokerHandConditionCode([singleConditionRule]);

    case "hand_level":
      return generateHandLevelConditionCode([singleConditionRule]);

    case "blind_requirements":
      return generateBlindRequirementsConditionCode([singleConditionRule]);

    case "joker_count":
      return generateJokerCountConditionCode([singleConditionRule]);

    case "specific_joker":
      return generateSpecificJokerConditionCode([singleConditionRule]);

    case "deck_size":
      return generateDeckSizeConditionCode([singleConditionRule]);

    case "voucher_redeemed":
      return generateVoucherRedeemedConditionCode([singleConditionRule]);

    case "triggered_boss_blind":
      return generateTriggeredBossBlindConditionCode();

    case "internal_variable":
      return generateInternalVariableConditionCode(
        [singleConditionRule],
        itemType
      );

    case "generic_compare":
      return generateGenericCompareConditionCode(
        [singleConditionRule],
        itemType
      );

    case "check_flag":
      return generateCheckFlagConditionCode([singleConditionRule]);

    case "system_condition":
      return generateSystemConditionCode([singleConditionRule]);

    default:
      return null;
  }
};

```

### src\components\codeGeneration\Card\effects\AddChipsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "chips" : `chips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `chips = ${valueCode}`,
    colour: "G.C.CHIPS",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddExpChipsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddExpChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "exp_chips" : `exp_chips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `e_chips = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddExpMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddExpMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "exp_mult" : `exp_mult${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `e_mult = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddHyperChipsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";

export const generateAddHyperChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableNameN =
    sameTypeCount === 0 ? "hyperchips_n" : `hyperchips_n${sameTypeCount + 1}`;
  
    const variableNameArrows =
    sameTypeCount === 0 ? "hyperchips_arrows" : `hyperchips_arrows${sameTypeCount + 1}`;

  const N = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableNameN,
    itemType
  )
  
  const Arrows = generateConfigVariables(
    effect.params?.arrows,
    effect.id,
    variableNameArrows,
    itemType
  )

  const customMessage = effect.customMessage;

  const configVariables = [...N.configVariables, ...Arrows.configVariables]

  const result: EffectReturn = {
    statement: `hyperchips = {
            ${Arrows.valueCode},
            ${N.valueCode}
        }`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddHyperMultEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";

export const generateAddHyperMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableNameN =
    sameTypeCount === 0 ? "hypermult_n" : `hypermult_n${sameTypeCount + 1}`;
  
    const variableNameArrows =
    sameTypeCount === 0 ? "hypermult_arrows" : `hypermult_arrows${sameTypeCount + 1}`;

  const N = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableNameN,
    itemType
  )
  
  const Arrows = generateConfigVariables(
    effect.params?.arrows,
    effect.id,
    variableNameArrows,
    itemType
  )

  const customMessage = effect.customMessage;

  const configVariables = [...N.configVariables, ...Arrows.configVariables]

  const result: EffectReturn = {
    statement: `hypermult = {
            ${Arrows.valueCode},
            ${N.valueCode}
        }`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "mult" : `mult${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `mult = ${valueCode}`,
    colour: "G.C.MULT",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddXChipsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddXChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "x_chips" : `x_chips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `x_chips = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\AddXMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddXMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "x_mult" : `x_mult${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `x_mult = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\BalanceEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateBalanceReturn = (effect: Effect): EffectReturn => {
  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `balance = true`,
    colour: "G.C.PURPLE",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\ChangePokerHandVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateChangePokerHandVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName =
    (effect.params.variable_name as string) || "pokerhandvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificPokerHand =
    (effect.params.specific_pokerhand as string) || "High Card";

  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hands = {}
                for handname, _ in pairs(G.GAME.hands) do
                    if G.GAME.hands[handname].visible then
                        ${variableName}_hands[#${variableName}_hands + 1] = handname
                    end
                end
                if ${variableName}_hands[1] then
                    G.GAME.current_round.${variableName}_hand = pseudorandom_element(${variableName}_hands, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                end
                __PRE_RETURN_CODE_END__`;
  } else if (changeType === "most_played") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hand, ${variableName}_tally = nil, 0
                for k, v in ipairs(G.handlist) do
                    if G.GAME.hands[v].visible and G.GAME.hands[v].played > ${variableName}_tally then
                        ${variableName}_hand = v
                        ${variableName}_tally = G.GAME.hands[v].played
                    end
                end
                if ${variableName}_hand then
                    G.GAME.current_round.${variableName}_hand = ${variableName}_hand
                end
                __PRE_RETURN_CODE_END__`;
  } else if (changeType === "least_played") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hand, ${variableName}_tally = nil, math.huge
                for k, v in ipairs(G.handlist) do
                    if G.GAME.hands[v].visible and G.GAME.hands[v].played < ${variableName}_tally then
                        ${variableName}_hand = v
                        ${variableName}_tally = G.GAME.hands[v].played
                    end
                end
                if ${variableName}_hand then
                    G.GAME.current_round.${variableName}_hand = ${variableName}_hand
                end
                __PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__
                G.GAME.current_round.${variableName}_hand = '${specificPokerHand}'
                __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\ChangeRankVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { getRankId } from "../../../data/BalatroUtils";
import { EffectReturn } from "../effectUtils";

export const generateChangeRankVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName = (effect.params.variable_name as string) || "rankvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificRank = (effect.params.specific_rank as string) || "A";
  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                    if G.playing_cards then
                        local valid_${variableName}_cards = {}
                        for _, v in ipairs(G.playing_cards) do
                            if not SMODS.has_no_rank(v) then
                                valid_${variableName}_cards[#valid_${variableName}_cards + 1] = v
                            end
                        end
                        if valid_${variableName}_cards[1] then
                            local ${variableName}_card = pseudorandom_element(valid_${variableName}_cards, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                            G.GAME.current_round.${variableName}_card.rank = ${variableName}_card.base.value
                            G.GAME.current_round.${variableName}_card.id = ${variableName}_card.base.id
                        end
                    end
                    __PRE_RETURN_CODE_END__`;
  } else {
    const rankId = getRankId(specificRank);
    statement = `__PRE_RETURN_CODE__
                    G.GAME.current_round.${variableName}_card.rank = '${specificRank}'
                    G.GAME.current_round.${variableName}_card.id = ${rankId}
                    __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\ChangeSuitVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateChangeSuitVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName = (effect.params.variable_name as string) || "suitvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificSuit = (effect.params.specific_suit as string) || "Spades";

  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                if G.playing_cards then
                    local valid_${variableName}_cards = {}
                    for _, v in ipairs(G.playing_cards) do
                        if not SMODS.has_no_suit(v) then
                            valid_${variableName}_cards[#valid_${variableName}_cards + 1] = v
                        end
                    end
                    if valid_${variableName}_cards[1] then
                        local ${variableName}_card = pseudorandom_element(valid_${variableName}_cards, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                        G.GAME.current_round.${variableName}_card.suit = ${variableName}_card.base.suit
                    end
                end
                __PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__
                G.GAME.current_round.${variableName}_card.suit = '${specificSuit}'
                __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\CopyConsumableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCopyConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const set = (effect.params?.set as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let copyCode = "";
  const slotCheck = isNegative
    ? ""
    : "and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit";
  const bufferCode = isNegative
    ? ""
    : "G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1";
  const bufferReset = isNegative ? "" : "G.GAME.consumeable_buffer = 0";
  const negativeSetCode = isNegative
    ? `
                        copied_card:set_edition("e_negative", true)`
    : "";
  const messageText = customMessage
    ? `"${customMessage}"`
    : `"Copied Consumable!"`;

  if (set === "random") {
    copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                table.insert(target_cards, consumable)
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
  } else {
    if (specificCard === "random") {
      copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
    } else {
      copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" and consumable.config.center.key == "${specificCard}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${copyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()${copyCode}
                    return true
                end`,
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Card\effects\CopyJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCopyJokerReturn = (effect: Effect): EffectReturn => {
  const selectionMethod =
    (effect.params?.selection_method as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const position = (effect.params?.position as string) || "first";
  const edition = (effect.params?.edition as string) || "none";
  const customMessage = effect.customMessage;

  const normalizedJokerKey = jokerKey.startsWith("j_") 
  ? jokerKey 
  : `j_${jokerKey}`

  const isNegative = edition === "e_negative";
  const hasEdition = edition !== "none";

  let jokerSelectionCode = "";

  if (selectionMethod === "specific" && normalizedJokerKey) {
    jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if joker.config.center.key == "${normalizedJokerKey}" then
                        target_joker = joker
                        break
                    end
                end`;
  } else if (selectionMethod === "position") {
    if (position === "first") {
      jokerSelectionCode = `
                local target_joker = G.jokers.cards[1] or nil`;
    } else if (position === "last") {
      jokerSelectionCode = `
                local target_joker = G.jokers.cards[#G.jokers.cards] or nil`;
    }
  } else {
    jokerSelectionCode = `
                local available_jokers = {}
                for i, joker in ipairs(G.jokers.cards) do
                    table.insert(available_jokers, joker)
                end
                local target_joker = #available_jokers > 0 and pseudorandom_element(available_jokers, pseudoseed('copy_joker_enhanced')) or nil`;
  }

  let spaceCheckCode = "";
  if (isNegative) {
    spaceCheckCode = `if target_joker then`;
  } else {
    spaceCheckCode = `if target_joker and #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then`;
  }

  const editionCode = hasEdition
    ? `
                        copied_joker:set_edition("${edition}", true)`
    : "";

  const bufferCode = isNegative
    ? ""
    : `
                        G.GAME.joker_buffer = G.GAME.joker_buffer + 1`;

  const bufferReset = isNegative
    ? ""
    : `
                        G.GAME.joker_buffer = 0`;

  const copyCode = `${jokerSelectionCode}
                
                ${spaceCheckCode}${bufferCode}
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local copied_joker = copy_card(target_joker, nil, nil, nil, target_joker.edition and target_joker.edition.negative)${editionCode}
                            copied_joker:add_to_deck()
                            G.jokers:emplace(copied_joker)${bufferReset}
                            return true
                        end
                    }))
                end`;

  const result: EffectReturn = {
    statement: `__PRE_RETURN_CODE__${copyCode}__PRE_RETURN_CODE_END__`,
    message: customMessage
      ? `"${customMessage}"`
      : `localize('k_duplicated_ex')`,
    colour: "G.C.GREEN",
  };

  return result;
};

```

### src\components\codeGeneration\Card\effects\CreateConsumableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCreateConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const set = (effect.params?.set as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let consumableCreationCode = "";
  let colour = "G.C.PURPLE";

  if (set === "random") {
    if (isNegative) {
      consumableCreationCode = `local created_consumable = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local random_sets = {'Tarot', 'Planet', 'Spectral'}
                        local random_set = random_sets[math.random(1, #random_sets)]
                        SMODS.add_card{set=random_set, edition = 'e_negative', key_append='enhanced_card_' .. random_set:lower()}
                        return true
                    end
                }))`;
    } else {
      consumableCreationCode = `local created_consumable = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_consumable = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local random_sets = {'Tarot', 'Planet', 'Spectral'}
                            local random_set = random_sets[math.random(1, #random_sets)]
                            SMODS.add_card{set=random_set, key_append='enhanced_card_' .. random_set:lower()}
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  } else {
    if (set === "Tarot") {
      colour = "G.C.PURPLE";
    } else if (set === "Planet") {
      colour = "G.C.SECONDARY_SET.Planet";
    } else if (set === "Spectral") {
      colour = "G.C.SECONDARY_SET.Spectral";
    } else {
      colour = "G.C.PURPLE";
    }

    if (specificCard === "random") {
      if (isNegative) {
        consumableCreationCode = `local created_consumable = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        SMODS.add_card{set = '${set}', edition = 'e_negative', key_append = 'enhanced_card_${set.toLowerCase()}'}
                        return true
                    end
                }))`;
      } else {
        consumableCreationCode = `local created_consumable = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_consumable = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            SMODS.add_card{set = '${set}', key_append = 'enhanced_card_${set.toLowerCase()}'}
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
      }
    } else {
      if (isNegative) {
        consumableCreationCode = `local created_consumable = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        SMODS.add_card{key = '${specificCard}', edition = 'e_negative', key_append = 'enhanced_card_${set.toLowerCase()}'}
                        return true
                    end
                }))`;
      } else {
        consumableCreationCode = `local created_consumable = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_consumable = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            SMODS.add_card{key = '${specificCard}', key_append = 'enhanced_card_${set.toLowerCase()}'}
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
      }
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${consumableCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_consumable and "+1 Consumable!" or nil`,
      colour: colour,
    };
  } else {
    return {
      statement: `func = function()${consumableCreationCode}
                    if created_consumable then
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                          customMessage
                            ? `"${customMessage}"`
                            : `"+1 Consumable!"`
                        }, colour = ${colour}})
                    end
                    return true
                end`,
      colour: colour,
    };
  }
};

```

### src\components\codeGeneration\Card\effects\CreateJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { getModPrefix } from "../../../data/BalatroUtils";

export const generateCreateJokerReturn = (effect: Effect): EffectReturn => {
  const jokerType = (effect.params?.joker_type as string) || "random";
  const rarity = (effect.params?.rarity as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const pool = (effect.params?.pool as string) || "";
  const edition = (effect.params?.edition as string) || "none";
  const sticker = (effect.params?.sticker as string) || "none";
  const ignoreSlotsParam = (effect.params?.ignore_slots as string) || "respect";
  const customMessage = effect.customMessage;

  const modPrefix = getModPrefix();
  const isNegative = edition === "e_negative";
  const hasSticker = sticker !== "none";
  const ignoreSlots = ignoreSlotsParam === "ignore";

  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  const cardParams = [];

  if (pool && pool.trim()) {
    const finalPool = modPrefix ? `${modPrefix}_${pool.trim()}` : pool.trim();
    cardParams.push(`set = '${finalPool}'`);
  } else {
    cardParams.push(`set = 'Joker'`);
  }

  if (jokerType === "specific" && normalizedJokerKey) {
    cardParams.push(`key = '${normalizedJokerKey}'`);
  } else if (rarity !== "random" && (!pool || !pool.trim())) {
    const rarityMap: Record<string, string> = {
      common: "Common",
      uncommon: "Uncommon",
      rare: "Rare",
      legendary: "Legendary",
    };
    const isVanillaRarity = Object.keys(rarityMap).includes(
      rarity.toLowerCase()
    );
    const finalRarity = isVanillaRarity
      ? rarityMap[rarity.toLowerCase()]
      : modPrefix
      ? `${modPrefix}_${rarity}`
      : rarity;
    cardParams.push(`rarity = '${finalRarity}'`);
  }

  let slotLimitCode: string;
  if (isNegative || ignoreSlots) {
    slotLimitCode = "local created_joker = true";
  } else {
    slotLimitCode = `local created_joker = false
                if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then
                    created_joker = true
                    G.GAME.joker_buffer = G.GAME.joker_buffer + 1`;
  }

  const cardCreationCode = `local joker_card = SMODS.add_card({ ${cardParams.join(
    ", "
  )} })`;
  const editionCode =
    edition !== "none" ? `joker_card:set_edition("${edition}", true)` : "";
  const stickerCode = hasSticker
    ? `joker_card:add_sticker('${sticker}', true)`
    : "";

  const result: EffectReturn = {
    statement: `__PRE_RETURN_CODE__
                ${slotLimitCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        ${cardCreationCode}
                        if joker_card then
                            ${editionCode}
                            ${stickerCode}
                        end
                        ${
                          !(isNegative || ignoreSlots)
                            ? "G.GAME.joker_buffer = 0"
                            : ""
                        }
                        return true
                    end
                }))
                ${!(isNegative || ignoreSlots) ? "end" : ""}
              __PRE_RETURN_CODE_END__`,
    message: customMessage
      ? `"${customMessage}"`
      : `created_joker and localize('k_plus_joker') or nil`,
    colour: "G.C.BLUE",
  };

  return result;
};

```

### src\components\codeGeneration\Card\effects\CreateLastPlayedPlanetEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCreateLastPlayedPlanetReturn = (
  effect: Effect
): EffectReturn => {
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const slotCheck = isNegative
    ? ""
    : "and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit";
  const bufferCode = isNegative
    ? ""
    : "G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1";
  const bufferReset = isNegative ? "" : "G.GAME.consumeable_buffer = 0";
  const negativeSetCode = isNegative
    ? `
                            planet_card:set_edition("e_negative", true)`
    : "";
  const messageText = customMessage
    ? `"${customMessage}"`
    : `localize('k_plus_planet')`;

  const planetCreationCode = `${bufferCode}
            G.E_MANAGER:add_event(Event({
                trigger = 'before',
                delay = 0.0,
                func = function()
                    if G.GAME.last_hand_played then
                        local _planet = nil
                        for k, v in pairs(G.P_CENTER_POOLS.Planet) do
                            if v.config.hand_type == G.GAME.last_hand_played then
                                _planet = v.key
                            end
                        end
                        if _planet then
                            local planet_card = SMODS.add_card({ key = _planet })${negativeSetCode}
                        end
                        ${bufferReset}
                    end
                    return true
                end
            }))`;

  return {
    statement: `__PRE_RETURN_CODE__${planetCreationCode}__PRE_RETURN_CODE_END__`,
    message: messageText,
    colour: "G.C.SECONDARY_SET.Planet",
    customCanUse: slotCheck ? slotCheck.replace("and ", "") : undefined,
  };
};

```

### src\components\codeGeneration\Card\effects\DestroyCardEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateDestroyCardReturn = (
  effect: Effect,
  trigger?: string
): EffectReturn => {
  const customMessage = effect.customMessage;
  const setGlassTrigger = effect.params?.setGlassTrigger === "true";

  if (trigger === "card_discarded") {
    const result: EffectReturn = {
      statement: `remove = true`,
      colour: "G.C.RED",
      configVariables: undefined,
    };

    if (customMessage) {
      result.message = `"${customMessage}"`;
    }

    return result;
  }

  let statement: string;

  if (setGlassTrigger) {
    statement = `__PRE_RETURN_CODE__card.glass_trigger = true
            card.should_destroy = true__PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__card.should_destroy = true__PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement: statement,
    colour: "G.C.RED",
    configVariables: undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\DestroyConsumableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateDestroyConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const set = (effect.params?.set as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let destroyCode = "";
  const messageText = customMessage
    ? `"${customMessage}"`
    : `"Destroyed Consumable!"`;

  if (set === "random") {
    destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                table.insert(target_cards, consumable)
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
  } else {
    if (specificCard === "random") {
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    } else {
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" and consumable.config.center.key == "${specificCard}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${destroyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.RED",
    };
  } else {
    return {
      statement: `func = function()${destroyCode}
                    return true
                end`,
      colour: "G.C.RED",
    };
  }
};

```

### src\components\codeGeneration\Card\effects\DestroyJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateDestroyJokerReturn = (effect: Effect): EffectReturn => {
  const selectionMethod =
    (effect.params?.selection_method as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const position = (effect.params?.position as string) || "first";
  const customMessage = effect.customMessage;

  const normalizedJokerKey = jokerKey.startsWith("j_") 
  ? jokerKey 
  : `j_${jokerKey}`

  let jokerSelectionCode = "";

  if (selectionMethod === "specific" && normalizedJokerKey) {
    jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if joker.config.center.key == "${normalizedJokerKey}" and not joker.ability.eternal and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
  } else if (selectionMethod === "position") {
    if (position === "first") {
      jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if not joker.ability.eternal and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
    } else if (position === "last") {
      jokerSelectionCode = `
                local target_joker = nil
                for i = #G.jokers.cards, 1, -1 do
                    local joker = G.jokers.cards[i]
                    if not joker.ability.eternal and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
    }
  } else {
    jokerSelectionCode = `
                local destructable_jokers = {}
                for i, joker in ipairs(G.jokers.cards) do
                    if not joker.ability.eternal and not joker.getting_sliced then
                        table.insert(destructable_jokers, joker)
                    end
                end
                local target_joker = #destructable_jokers > 0 and pseudorandom_element(destructable_jokers, pseudoseed('destroy_joker_enhanced')) or nil`;
  }

  const destroyCode = `${jokerSelectionCode}
                
                if target_joker then
                    target_joker.getting_sliced = true
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            target_joker:start_dissolve({G.C.RED}, nil, 1.6)
                            return true
                        end
                    }))
                end`;

  const result: EffectReturn = {
    statement: `__PRE_RETURN_CODE__${destroyCode}__PRE_RETURN_CODE_END__`,
    message: customMessage ? `"${customMessage}"` : `"Destroyed Joker!"`,
    colour: "G.C.RED",
  };

  return result;
};

```

### src\components\codeGeneration\Card\effects\DrawCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateDrawCardsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "card_draw" : `card_draw${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `__PRE_RETURN_CODE__
  if G.GAME.blind.in_blind then
    SMODS.draw_cards(${valueCode})
  end__PRE_RETURN_CODE_END__`,
    message: customMessage
      ? `"${customMessage}"`
      : `"+"..tostring(${valueCode}).." Cards Drawn"`,
    colour: "G.C.BLUE",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  return result;
};

```

### src\components\codeGeneration\Card\effects\EditDollarsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateEditDollarsReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const operation = (effect.params?.operation as string) || "add";
  const variableName =
    sameTypeCount === 0 ? "dollars" : `dollars${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const customMessage = effect.customMessage;

  let result: EffectReturn;

  switch (operation) {
    case "add": {
      result = {
        statement: `dollars = lenient_bignum(${valueCode})`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0
            ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
            : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
      break;
    }

    case "subtract": {
      result = {
        statement: `dollars = -lenient_bignum(${valueCode})`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0
            ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
            : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
      break;
    }

    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to $"..tostring(${valueCode})`;

      result = {
        statement: `func = function()
                    local target_amount = ${valueCode}
                    local current_amount = G.GAME.dollars
                    local difference = target_amount - current_amount
                    ease_dollars(difference)
                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.MONEY})
                    return true
                end`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0
            ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
            : undefined,
      };
      break;
    }

    default: {
      result = {
        statement: `dollars = lenient_bignum(${valueCode})`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0
            ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
            : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
    }
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\EditPlayingCardEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateEditPlayingCardReturn = (
  effect: Effect,
  trigger?: string
): EffectReturn => {
  const newRank = (effect.params?.new_rank as string) || "none";
  const newSuit = (effect.params?.new_suit as string) || "none";
  const newEnhancement = (effect.params?.new_enhancement as string) || "none";
  const newSeal = (effect.params?.new_seal as string) || "none";
  const newEdition = (effect.params?.new_edition as string) || "none";
  const customMessage = effect.customMessage;

  // For card_discarded, we use context.other_card, for others we use card
  const targetCard =
    trigger === "card_discarded" ? "context.other_card" : "card";

  let modificationCode = "";

  if (newRank !== "none" || newSuit !== "none") {
    let suitParam = "nil";
    let rankParam = "nil";

    if (newSuit === "random") {
      suitParam = "pseudorandom_element(SMODS.Suits, 'edit_card_suit').key";
    } else if (newSuit !== "none") {
      suitParam = `"${newSuit}"`;
    }

    if (newRank === "random") {
      rankParam = "pseudorandom_element(SMODS.Ranks, 'edit_card_rank').key";
    } else if (newRank !== "none") {
      rankParam = `"${newRank}"`;
    }

    modificationCode += `
                assert(SMODS.change_base(${targetCard}, ${suitParam}, ${rankParam}))`;
  }

  if (newEnhancement === "remove") {
    modificationCode += `
                ${targetCard}:set_ability(G.P_CENTERS.c_base)`;
  } else if (newEnhancement === "random") {
    modificationCode += `
                local enhancement_pool = {}
                for _, enhancement in pairs(G.P_CENTER_POOLS.Enhanced) do
                    if enhancement.key ~= 'm_stone' then
                        enhancement_pool[#enhancement_pool + 1] = enhancement
                    end
                end
                local random_enhancement = pseudorandom_element(enhancement_pool, 'edit_card_enhancement')
                ${targetCard}:set_ability(random_enhancement)`;
  } else if (newEnhancement !== "none") {
    modificationCode += `
                ${targetCard}:set_ability(G.P_CENTERS.${newEnhancement})`;
  }

  if (newSeal === "remove") {
    modificationCode += `
                ${targetCard}:set_seal(nil)`;
  } else if (newSeal === "random") {
    modificationCode += `
                local random_seal = SMODS.poll_seal({mod = 10})
                if random_seal then
                    ${targetCard}:set_seal(random_seal, true)
                end`;
  } else if (newSeal !== "none") {
    modificationCode += `
                ${targetCard}:set_seal("${newSeal}", true)`;
  }

  if (newEdition === "remove") {
    modificationCode += `
                ${targetCard}:set_edition(nil)`;
  } else if (newEdition === "random") {
    modificationCode += `
                local random_edition = poll_edition('edit_card_edition', nil, true, true)
                if random_edition then
                    ${targetCard}:set_edition(random_edition, true)
                end`;
  } else if (newEdition !== "none") {
    modificationCode += `
                ${targetCard}:set_edition("${newEdition}", true)`;
  }

  const scoringTriggers = ["card_scored"];
  const isScoring = scoringTriggers.includes(trigger || "");

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${modificationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage ? `"${customMessage}"` : `"Card Modified!"`,
      colour: "G.C.BLUE",
    };
  } else {
    return {
      statement: `func = function()${modificationCode}
                    end`,
      message: customMessage ? `"${customMessage}"` : `"Card Modified!"`,
      colour: "G.C.BLUE",
    };
  }
};

```

### src\components\codeGeneration\Card\effects\EmitFlagEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateEmitFlagReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const flagName = (effect.params?.flag_name as string) || "custom_flag";
  const change = (effect.params?.change as string) || "true";
  const customMessage = effect.customMessage;

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore
  const changeCode = change === "invert" ? `not (G.GAME.pool_flags.${modprefix}_${safeFlagName} or false)` : change

  return {
    statement: `func = function()
                    G.GAME.pool_flags.${modprefix}_${safeFlagName} = ${changeCode}
                    return true
                end`,
    message: customMessage ? `"${customMessage}"` : `"${safeFlagName}"`,
    colour: "G.C.BLUE"
  }
};

```

### src\components\codeGeneration\Card\effects\LevelUpHandEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateLevelUpHandReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const customMessage = effect?.customMessage;

  const variableName =
    sameTypeCount === 0 ? "levels" : `levels${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName,
    itemType
  );

  const targetHandVar =
    sameTypeCount === 0 ? `target_hand` : `target_hand${sameTypeCount + 1}`;

  const handSelection = (effect?.params?.hand_selection as string) || "current";
  const specificHand = (effect?.params?.specific_hand as string) || "High Card";

  let handDeterminationCode = "";
  switch (handSelection) {
    case "specific":
      handDeterminationCode = `${targetHandVar} = "${specificHand}"`;
      break;
    case "random":
      handDeterminationCode = `
                local available_hands = {}
                for hand, value in pairs(G.GAME.hands) do
                  if value.visible and value.level >= to_big(1) then
                    table.insert(available_hands, hand)
                  end
                end
                ${targetHandVar} = #available_hands > 0 and pseudorandom_element(available_hands, pseudoseed('level_up_hand_enhanced')) or "High Card"`;
      break;
    case "most":
      handDeterminationCode = `
                local temp_played = 0
                local temp_order = math.huge
                for hand, value in pairs(G.GAME.hands) do 
                  if value.played > temp_played and value.visible then
                    temp_played = value.played
                    temp_order = value.order
                    ${targetHandVar} = hand
                  elseif value.played == temp_played and value.visible then
                    if value.order < temp_order then
                      temp_order = value.order
                      ${targetHandVar} = hand
                    end
                  end
                end`;
      break;
    case "least":
      handDeterminationCode = `
                local temp_played = math.huge
                local temp_order = math.huge
                for hand, value in pairs(G.GAME.hands) do 
                  if value.played < temp_played and value.visible then
                    temp_played = value.played
                    temp_order = value.order
                    ${targetHandVar} = hand
                  elseif value.played == temp_played and value.visible then
                    if value.order < temp_order then
                      temp_order = value.order
                      ${targetHandVar} = hand
                    end
                  end
                end`;
      break;
    case "current":
      handDeterminationCode = `${targetHandVar} = context.scoring_name or "High Card"`;
      break;
  }

  return {
    statement: `__PRE_RETURN_CODE__
                local ${targetHandVar}
                ${handDeterminationCode}
                __PRE_RETURN_CODE_END__
                level_up = ${valueCode},
                level_up_hand = ${targetHandVar}`,
    message: customMessage ? `"${customMessage}"` : `localize('k_level_up_ex')`,
    colour: "G.C.RED",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };
};

```

### src\components\codeGeneration\Card\effects\ModifyInternalVariableEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../../Jokers/gameVariableUtils";

export const generateModifyInternalVariableReturn = (
  effect: Effect,
  triggerType: string,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const variableName = (effect.params?.variable_name as string) || "var1";
  const operation = (effect.params?.operation as string) || "increment";
  const effectValue = effect.params?.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;
  const abilityPath =
    itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";

  if (parsed.isGameVariable) {
    /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `${variableName}_${effect.id.substring(0, 8)}`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `${abilityPath}.${effectValue}`;
  } else {
    valueCode = effectValue?.toString() || "1";
  }

  const customMessage = effect.customMessage;

  const scoringTriggers = ["card_scored", "card_held"];
  const isScoring = scoringTriggers.includes(triggerType);

  let operationCode = "";
  let messageText = "";
  let messageColor = "G.C.WHITE";

  switch (operation) {
    case "set":
      operationCode = `${abilityPath}.${variableName} = ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.BLUE";
      break;
    case "increment":
      operationCode = `${abilityPath}.${variableName} = (${abilityPath}.${variableName}) + ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.GREEN";
      break;
    case "decrement":
      operationCode = `${abilityPath}.${variableName} = math.max(0, (${abilityPath}.${variableName}) - ${valueCode})`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.RED";
      break;
    case "multiply":
      operationCode = `${abilityPath}.${variableName} = (${abilityPath}.${variableName}) * ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.MULT";
      break;
    case "divide":
      operationCode = `${abilityPath}.${variableName} = (${abilityPath}.${variableName}) / ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.MULT";
      break;
    default:
      operationCode = `${abilityPath}.${variableName} = (${abilityPath}.${variableName}) + ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.GREEN";
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__
                ${operationCode}
                __PRE_RETURN_CODE_END__`,
      message: messageText || undefined,
      colour: messageColor,
    };
  } else {
    return {
      statement: `func = function()
                    ${operationCode}
                    return true
                end`,
      message: messageText || undefined,
      colour: messageColor,
    };
  }
};

```

### src\components\codeGeneration\Card\effects\PlaySoundEffect.ts

```
import { Effect } from "../../../ruleBuilder";
import { EffectReturn } from "../effectUtils";

export const generatePlaySoundReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const key = effect.params.sound_key as string || "";

  const normalizedKey = key.startsWith(modprefix+"_")
    ? key
    : `${modprefix}_${key}`

  const customMessage = effect.customMessage

  return {
    colour: "G.C.BLUE",
    statement: `__PRE_RETURN_CODE__play_sound("${normalizedKey}")
    ${customMessage ? `SMODS.calculate_effect({message = "${customMessage}"}, card)` : ""}
    __PRE_RETURN_CODE_END__`
  }
}
```

### src\components\codeGeneration\Card\effects\RetriggerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { generateConfigVariables } from "../../Jokers/gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateRetriggerReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  const effectValue = effect.params?.value ?? 1;
  const variableName =
    sameTypeCount === 0
      ? "retrigger_times"
      : `retrigger_times${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effectValue,
    effect.id,
    variableName,
    itemType
  );

  const abilityPath =
    itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";
  const customMessage = effect.customMessage;

  let statement: string;

  if (typeof effectValue === "number" && effectValue !== 1) {
    statement = `__PRE_RETURN_CODE__card.should_retrigger = true
            ${abilityPath}.${variableName} = ${effectValue}__PRE_RETURN_CODE_END__`;
  } else if (valueCode !== `${abilityPath}.${variableName}`) {
    statement = `__PRE_RETURN_CODE__card.should_retrigger = true
            ${abilityPath}.${variableName} = ${valueCode}__PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__card.should_retrigger = true__PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement: statement,
    colour: "G.C.SECONDARY_SET.Spectral",
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => `${cv.name} = ${cv.value}`)
        : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effects\ShowMessageEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateShowMessageReturn = (effect: Effect): EffectReturn => {
  const colour = (effect.params?.colour as string) || "G.C.WHITE";
  const customMessage = effect.customMessage;

  const messageCode = customMessage ? `"${customMessage}"` : '"Message!"';

  return {
    statement: "",
    message: messageCode,
    colour: colour,
  };
};

```

### src\components\codeGeneration\Card\effects\SwapChipsMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateSwapChipsMultReturn = (
  effect: Effect,
): EffectReturn => {

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `swap = true`,
    colour: "G.C.CHIPS",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Card\effectUtils.ts

```
import type { Effect, LoopGroup, RandomGroup } from "../../ruleBuilder/types";
import { generateAddMultReturn } from "./effects/AddMultEffect";
import { generateAddChipsReturn } from "./effects/AddChipsEffect";
import { generateEditDollarsReturn } from "./effects/EditDollarsEffect";
import { generateAddXChipsReturn } from "./effects/AddXChipsEffect";
import { generateAddXMultReturn } from "./effects/AddXMultEffect";
import { generateDestroyCardReturn } from "./effects/DestroyCardEffect";
import { generateRetriggerReturn } from "./effects/RetriggerEffect";
import { generateCreateJokerReturn } from "./effects/CreateJokerEffect";
import { generateDestroyJokerReturn } from "./effects/DestroyJokerEffect";
import { generateCopyJokerReturn } from "./effects/CopyJokerEffect";
import { generateLevelUpHandReturn } from "./effects/LevelUpHandEffect";
import { generateCreateConsumableReturn } from "./effects/CreateConsumableEffect";
import { generateCopyConsumableReturn } from "./effects/CopyConsumableEffect";
import { generateDestroyConsumableReturn } from "./effects/DestroyConsumableEffect";
import { generateShowMessageReturn } from "./effects/ShowMessageEffect";
import { generateBalanceReturn } from "./effects/BalanceEffect";
import { generateDrawCardsReturn } from "./effects/DrawCardsEffect";
import { generateCreateLastPlayedPlanetReturn } from "./effects/CreateLastPlayedPlanetEffect";
import { generateSwapChipsMultReturn } from "./effects/SwapChipsMultEffect";
import { generateModifyInternalVariableReturn } from "./effects/ModifyInternalVariableEffect";
import { generateEmitFlagReturn } from "./effects/EmitFlagEffect";
import { generateEditPlayingCardReturn } from "./effects/EditPlayingCardEffect";
import { getModPrefix } from "../../data/BalatroUtils";
import { generatePlaySoundReturn } from "./effects/PlaySoundEffect";
import { generateAddExpChipsReturn } from "./effects/AddExpChipsEffect";
import { generateAddExpMultReturn } from "./effects/AddExpMultEffect";
import { generateAddHyperChipsReturn } from "./effects/AddHyperChipsEffect";
import { generateAddHyperMultReturn } from "./effects/AddHyperMultEffect";
import { generateChangeRankVariableReturn } from "./effects/ChangeRankVariableEffect";
import { generateChangeSuitVariableReturn } from "./effects/ChangeSuitVariableEffect";
import { generateChangePokerHandVariableReturn } from "./effects/ChangePokerHandVariableEffect";

export interface ConfigExtraVariable {
  name: string;
  value: number;
}

export interface EffectReturn {
  statement: string;
  message?: string;
  colour: string;
  configVariables?: string[];
  customCanUse?: string;
}

export interface ReturnStatementResult {
  statement: string;
  colour: string;
  preReturnCode?: string;
  isRandomChance?: boolean;
  configVariables?: string[];
  customCanUse?: string;
}

const generateSingleEffect = (
  effect: Effect,
  trigger?: string,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): EffectReturn => {
  switch (effect.type) {
    case "add_mult":
      return generateAddMultReturn(effect, 0, itemType);

    case "add_chips":
      return generateAddChipsReturn(effect, 0, itemType);

    case "add_x_chips":
      return generateAddXChipsReturn(effect, 0, itemType);

    case "add_x_mult":
      return generateAddXMultReturn(effect, 0, itemType);

    case "add_exp_chips":
      return generateAddExpChipsReturn(effect, 0, itemType);

    case "add_exp_mult":
      return generateAddExpMultReturn(effect, 0, itemType);

    case "add_hyper_chips":
      return generateAddHyperChipsReturn(effect, 0, itemType);

    case "add_hyper_mult":
      return generateAddHyperMultReturn(effect, 0, itemType);

    case "edit_dollars":
      return generateEditDollarsReturn(effect, 0, itemType);

    case "destroy_card":
      return generateDestroyCardReturn(effect, trigger);

    case "retrigger_card":
      return generateRetriggerReturn(effect, 0, itemType);

    case "create_joker":
      return generateCreateJokerReturn(effect);

    case "destroy_joker":
      return generateDestroyJokerReturn(effect);

    case "copy_joker":
      return generateCopyJokerReturn(effect);

    case "level_up_hand":
      return generateLevelUpHandReturn(effect, 0, itemType);

    case "create_consumable":
      return generateCreateConsumableReturn(effect, trigger || "");

    case "copy_consumable":
      return generateCopyConsumableReturn(effect, trigger || "");

    case "destroy_consumable":
      return generateDestroyConsumableReturn(effect, trigger || "");

    case "show_message":
      return generateShowMessageReturn(effect);

    case "balance":
      return generateBalanceReturn(effect);

    case "draw_cards":
      return generateDrawCardsReturn(effect, 0, itemType);

    case "create_last_played_planet":
      return generateCreateLastPlayedPlanetReturn(effect);

    case "swap_chips_mult":
      return generateSwapChipsMultReturn(effect);

    case "modify_internal_variable":
      return generateModifyInternalVariableReturn(
        effect,
        trigger || "",
        itemType
      );
    
    case "change_rank_variable":
      return generateChangeRankVariableReturn(effect);

    case "change_suit_variable":
      return generateChangeSuitVariableReturn(effect);
    
      case "change_poker_hand_variable":
      return generateChangePokerHandVariableReturn(effect);

    case "emit_flag":
      return generateEmitFlagReturn(effect, getModPrefix());
    
    case "play_sound":
      return generatePlaySoundReturn(effect, getModPrefix());

    case "edit_playing_card":
      return generateEditPlayingCardReturn(effect, trigger);

    default:
      return {
        statement: "",
        colour: "G.C.WHITE",
      };
  }
};

export function generateEffectReturnStatement(
  regularEffects: Effect[] = [],
  randomGroups: RandomGroup[] = [],
  loopGroups: LoopGroup[] = [],
  modprefix: string,
  cardKey: string,
  trigger?: string,
  itemType: "enhancement" | "seal" | "edition" = "enhancement"
): ReturnStatementResult {
  if (regularEffects.length === 0 && randomGroups.length === 0 && loopGroups.length === 0) {
    return {
      statement: "",
      colour: "G.C.WHITE",
      configVariables: [],
    };
  }

  let combinedPreReturnCode = "";
  let mainReturnStatement = "";
  let primaryColour = "G.C.WHITE";
  const customCanUseConditions: string[] = [];
  const allConfigVariables: string[] = [];
  const configVariableSet = new Set<string>();

  if (regularEffects.length > 0) {
    const effectReturns: EffectReturn[] = regularEffects
      .map((effect) => generateSingleEffect(effect, trigger, itemType))
      .filter((ret) => ret.statement || ret.message);

    effectReturns.forEach((effectReturn) => {
      if (effectReturn.configVariables) {
        effectReturn.configVariables.forEach((configVar) => {
          if (!configVariableSet.has(configVar)) {
            configVariableSet.add(configVar);
            allConfigVariables.push(configVar);
          }
        });
      }
      if (effectReturn.customCanUse) {
        customCanUseConditions.push(effectReturn.customCanUse);
      }
    });

    const effectCalls: string[] = [];

    effectReturns.forEach((effect) => {
      const { cleanedStatement, preReturnCode } = extractPreReturnCode(
        effect.statement
      );

      if (preReturnCode) {
        combinedPreReturnCode +=
          (combinedPreReturnCode ? "\n            " : "") + preReturnCode;
      }

      if (cleanedStatement && cleanedStatement.trim()) {
        const effectObj = `{${cleanedStatement.trim()}}`;
        effectCalls.push(`SMODS.calculate_effect(${effectObj}, card)`);
      }

      if (effect.message) {
        effectCalls.push(
          `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
            effect.message
          }, colour = ${effect.colour || "G.C.WHITE"}})`
        );
      }
    });

    if (combinedPreReturnCode && effectCalls.length > 0) {
      const isDiscardTrigger = trigger === "card_discarded";

      if (isDiscardTrigger) {
        const allCleanedStatements = effectReturns
          .map((effect) => {
            const { cleanedStatement } = extractPreReturnCode(effect.statement);
            return cleanedStatement && cleanedStatement.trim()
              ? cleanedStatement.trim()
              : null;
          })
          .filter(Boolean);

        if (allCleanedStatements.length === effectReturns.length) {
          mainReturnStatement = buildEnhancementEffectCode(
            effectReturns.map((effect) => ({
              ...effect,
              statement: extractPreReturnCode(effect.statement)
                .cleanedStatement,
            }))
          );
        } else {
          combinedPreReturnCode +=
            "\n            " + effectCalls.join("\n            ");
          mainReturnStatement = "";
        }
      } else {
        combinedPreReturnCode +=
          "\n            " + effectCalls.join("\n            ");
        mainReturnStatement = "";
      }
    } else if (effectCalls.length > 0) {
      const pureStatementEffects = effectReturns.filter((effect) => {
        const { cleanedStatement } = extractPreReturnCode(effect.statement);
        return (
          cleanedStatement &&
          cleanedStatement.trim() &&
          !extractPreReturnCode(effect.statement).preReturnCode
        );
      });

      if (pureStatementEffects.length === effectReturns.length) {
        mainReturnStatement = buildEnhancementEffectCode(
          pureStatementEffects.map((effect) => ({
            ...effect,
            statement: extractPreReturnCode(effect.statement).cleanedStatement,
          }))
        );
      } else {
        combinedPreReturnCode = effectCalls.join("\n            ");
        mainReturnStatement = "";
      }
    }

    if (effectReturns.length > 0) {
      primaryColour = effectReturns[0]?.colour ?? "G.C.WHITE";
    }
  }

  if (randomGroups.length > 0) {
    const denominators = [
      ...new Set(
        randomGroups.map((group) => group.chance_denominator as number)
      ),
    ];
    const denominatorToOddsVar: Record<number, string> = {};
    const abilityPath =
      itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";

    if (denominators.length === 1) {
      denominatorToOddsVar[denominators[0]] = `${abilityPath}.odds`;
      const oddsVar = "odds = " + denominators[0];
      if (!configVariableSet.has(oddsVar)) {
        configVariableSet.add(oddsVar);
        allConfigVariables.push(oddsVar);
      }
    } else {
      denominators.forEach((denom, index) => {
        if (index === 0) {
          denominatorToOddsVar[denom] = `${abilityPath}.odds`;
          const oddsVar = "odds = " + denom;
          if (!configVariableSet.has(oddsVar)) {
            configVariableSet.add(oddsVar);
            allConfigVariables.push(oddsVar);
          }
        } else {
          denominatorToOddsVar[denom] = `${abilityPath}.odds${index + 1}`;
          const oddsVar = `odds${index + 1} = ${denom}`;
          if (!configVariableSet.has(oddsVar)) {
            configVariableSet.add(oddsVar);
            allConfigVariables.push(oddsVar);
          }
        }
      });
    }

    randomGroups.forEach((group, groupIndex) => {
      const effectReturns: EffectReturn[] = group.effects
        .map((effect) => generateSingleEffect(effect, trigger, itemType))
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          effectReturn.configVariables.forEach((configVar) => {
            if (!configVariableSet.has(configVar)) {
              configVariableSet.add(configVar);
              allConfigVariables.push(configVar);
            }
          });
        }
        if (effectReturn.customCanUse) {
          customCanUseConditions.push(effectReturn.customCanUse);
        }
      });

      if (effectReturns.length === 0) return;

      const oddsVar = denominatorToOddsVar[group.chance_denominator as number];
      const probabilityIdentifier = `group_${groupIndex}_${group.id.substring(
        0,
        8
      )}`;

      let groupContent = "";
      let groupPreReturnCode = "";
      const groupEffectCalls: string[] = [];

      effectReturns.forEach((effect) => {
        const { cleanedStatement, preReturnCode } = extractPreReturnCode(
          effect.statement
        );

        if (preReturnCode) {
          groupPreReturnCode +=
            (groupPreReturnCode ? "\n                " : "") + preReturnCode;
        }

        if (cleanedStatement && cleanedStatement.trim()) {
          const effectObj = `{${cleanedStatement.trim()}}`;
          groupEffectCalls.push(`SMODS.calculate_effect(${effectObj}, card)`);
        }

        if (effect.message) {
          groupEffectCalls.push(
            `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
              effect.message
            }, colour = ${effect.colour || "G.C.WHITE"}})`
          );
        }
      });

      if (groupPreReturnCode) {
        groupContent += groupPreReturnCode;
        if (groupEffectCalls.length > 0) {
          groupContent +=
            "\n                " + groupEffectCalls.join("\n                ");
        }
      } else if (groupEffectCalls.length > 0) {
        groupContent = groupEffectCalls.join("\n                ");
      }

      const probabilityStatement =
        group.respect_probability_effects !== false
          ? `SMODS.pseudorandom_probability(card, '${probabilityIdentifier}', ${
              group.chance_numerator
            }, ${oddsVar}, '${
              group.custom_key || `m_${modprefix}_${cardKey}`
            }')`
          : `pseudorandom('${probabilityIdentifier}') < ${group.chance_numerator} / ${oddsVar}`;

      const groupStatement = `if ${probabilityStatement} then
                ${groupContent}
            end`;

      combinedPreReturnCode +=
        (combinedPreReturnCode ? "\n            " : "") + groupStatement;
    });
  }
  
  if (loopGroups.length > 0) {
    const repetitions = [
      ...new Set(loopGroups.map((group) => group.repetitions as number)),
    ];
    const repetitionsToVar: Record<number, string> = {};
    const abilityPath =
      itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";

    if (repetitions.length === 1) {
      repetitionsToVar[repetitions[0]] = `${abilityPath}.repetitions`;
      const repetitionsVar = "repetitions = " + repetitions[0];
      if (!(typeof repetitions[0] === "string") && !configVariableSet.has(repetitionsVar)) {
        configVariableSet.add(repetitionsVar);
        allConfigVariables.push(repetitionsVar);
      }
    } else {
      repetitions.forEach((denom, index) => {
        if (index === 0) {
          repetitionsToVar[denom] = `${abilityPath}.repetitions`;
          const repetitionsVar = "repetitions = " + denom;
          if (!(typeof denom === "string") && !configVariableSet.has(repetitionsVar)) {
            configVariableSet.add(repetitionsVar);
            allConfigVariables.push(repetitionsVar);
          }
        } else {
          repetitionsToVar[denom] = `${abilityPath}.repetitions${index + 1}`;
          const repetitionsVar = `repetitions${index + 1} = ${denom}`;
          if (!(typeof denom === "string") && !configVariableSet.has(repetitionsVar)) {
            configVariableSet.add(repetitionsVar);
            allConfigVariables.push(repetitionsVar);
          }
        }
      });
    }

    loopGroups.forEach((group) => {
      const effectReturns: EffectReturn[] = group.effects
        .map((effect) => generateSingleEffect(effect, trigger, itemType))
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          effectReturn.configVariables.forEach((configVar) => {
            if (!configVariableSet.has(configVar)) {
              configVariableSet.add(configVar);
              allConfigVariables.push(configVar);
            }
          });
        }
        if (effectReturn.customCanUse) {
          customCanUseConditions.push(effectReturn.customCanUse);
        }
      });

      if (effectReturns.length === 0) return;

      const repetitionsVar = typeof group.repetitions === "string" ? group.repetitions : repetitionsToVar[group.repetitions as number];

      let groupContent = "";
      let groupPreReturnCode = "";
      const groupEffectCalls: string[] = [];

      effectReturns.forEach((effect) => {
        const { cleanedStatement, preReturnCode } = extractPreReturnCode(
          effect.statement
        );

        if (preReturnCode) {
          groupPreReturnCode +=
            (groupPreReturnCode ? "\n                " : "") + preReturnCode;
        }

        if (cleanedStatement && cleanedStatement.trim()) {
          const effectObj = `{${cleanedStatement.trim()}}`;
          groupEffectCalls.push(`SMODS.calculate_effect(${effectObj}, card)`);
        }

        if (effect.message) {
          groupEffectCalls.push(
            `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
              effect.message
            }, colour = ${effect.colour || "G.C.WHITE"}})`
          );
        }
      });

      if (groupPreReturnCode) {
        groupContent += groupPreReturnCode;
        if (groupEffectCalls.length > 0) {
          groupContent +=
            "\n                " + groupEffectCalls.join("\n                ");
        }
      } else if (groupEffectCalls.length > 0) {
        groupContent = groupEffectCalls.join("\n                ");
      }

      const loopStatement =  `for i = 1, ${repetitionsVar} do`;
      
      const groupStatement = `${loopStatement}
              ${groupContent}
          end`;

      combinedPreReturnCode +=
        (combinedPreReturnCode ? "\n            " : "") + groupStatement;
    });
  }

  return {
    statement: mainReturnStatement,
    colour: primaryColour,
    preReturnCode: combinedPreReturnCode || undefined,
    isRandomChance: randomGroups.length > 0,
    configVariables: allConfigVariables,
    customCanUse:
      customCanUseConditions.length > 0
        ? customCanUseConditions.join(" and ")
        : undefined,
  };
}

const buildEnhancementEffectCode = (effects: EffectReturn[]): string => {
  if (effects.length === 0) return "";

  const returnParts: string[] = [];

  effects.forEach((effect) => {
    if (effect.statement.trim()) {
      returnParts.push(effect.statement.trim());
    }
  });

  if (returnParts.length === 0) return "";

  if (returnParts.length === 1) {
    return `{ ${returnParts[0]} }`;
  }

  return `{ ${returnParts.join(", ")} }`;
};

function extractPreReturnCode(statement: string): {
  cleanedStatement: string;
  preReturnCode?: string;
} {
  const preReturnStart = "__PRE_RETURN_CODE__";
  const preReturnEnd = "__PRE_RETURN_CODE_END__";

  if (statement.includes(preReturnStart) && statement.includes(preReturnEnd)) {
    const startIndex =
      statement.indexOf(preReturnStart) + preReturnStart.length;
    const endIndex = statement.indexOf(preReturnEnd);

    if (startIndex < endIndex) {
      const preReturnCode = statement.substring(startIndex, endIndex).trim();
      const cleanedStatement = statement
        .replace(
          new RegExp(`${preReturnStart}[\\s\\S]*?${preReturnEnd}`, "g"),
          ""
        )
        .trim();

      return { cleanedStatement, preReturnCode };
    }
  }

  return { cleanedStatement: statement };
}

```

### src\components\codeGeneration\Card\index.ts

```
import {
  EditionData,
  EnhancementData,
  isCustomShader,
  isVanillaShader,
  SealData,
  slugify,
} from "../../data/BalatroUtils";
import { generateConditionChain } from "./conditionUtils";
import { generateEffectReturnStatement } from "./effectUtils";
import { generateTriggerCondition } from "./triggerUtils";
import { extractGameVariablesFromRules, generateGameVariableCode, parseGameVariable } from "../Consumables/gameVariableUtils";
import type { Rule, Effect } from "../../ruleBuilder/types";
import { parseRangeVariable } from "../Jokers/gameVariableUtils";

interface EnhancementGenerationOptions {
  modPrefix?: string;
  atlasKey?: string;
}

interface SealGenerationOptions {
  modPrefix?: string;
  atlasKey?: string;
}

interface UnconditionalEffect {
  trigger: string;
  effect: Effect;
}

const hasRetriggerEffects = (rules: Rule[]): boolean => {
  return rules.some(
    (rule) =>
      rule.effects?.some((effect) => effect.type === "retrigger_card") ||
      rule.randomGroups?.some((group) =>
        group.effects.some((effect) => effect.type === "retrigger_card")
      ) ||
      rule.loops?.some((group) =>
        group.effects.some((effect) => effect.type === "retrigger_card")
      )
  );
};

const hasDestroyCardEffects = (rules: Rule[]): boolean => {
  return rules.some(
    (rule) =>
      rule.effects?.some((effect) => effect.type === "destroy_card") ||
      rule.randomGroups?.some((group) =>
        group.effects.some((effect) => effect.type === "destroy_card")
      ) ||
      rule.loops?.some((group) =>
        group.effects.some((effect) => effect.type === "destroy_card")
      )
  );
};

const hasNonDiscardDestroyEffects = (rules: Rule[]): boolean => {
  return rules.some(
    (rule) =>
      rule.trigger !== "card_discarded" &&
      (rule.effects?.some((effect) => effect.type === "destroy_card") ||
        rule.randomGroups?.some((group) =>
          group.effects.some((effect) => effect.type === "destroy_card")
        ) ||
        rule.loops?.some((group) =>
          group.effects.some((effect) => effect.type === "destroy_card")
        )
      )
  );
};

const generateCalculateFunction = (
  rules: Rule[],
  modPrefix: string,
  hasNonDiscardDestroy: boolean,
  hasRetrigger: boolean,
  cardKey: string,
  itemType: "enhancement" | "seal" | "edition"
): string => {
  if (rules.length === 0 && !hasNonDiscardDestroy && !hasRetrigger) {
    return "";
  }

  const abilityPath =
    itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";

  let calculateFunction = `calculate = function(self, card, context)`;

  if (hasNonDiscardDestroy) {
    if (itemType === "enhancement") {
      calculateFunction += `
        if context.destroy_card and context.cardarea == G.play and context.destroy_card == card and card.should_destroy then
            return { remove = true }
        end`;
    } else {
      calculateFunction += `
        if context.destroy_card and context.cardarea == G.play and context.destroy_card == card and card.should_destroy then
            G.E_MANAGER:add_event(Event({
                func = function()
                    card:start_dissolve()
                    return true
                end
            }))
            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = "Card Destroyed!", colour = G.C.RED})
            return
        end`;
    }
  }

  if (hasRetrigger) {
    calculateFunction += `
        if context.repetition and card.should_retrigger then
            return { repetitions = ${abilityPath}.retrigger_times }
        end`;
  }

  rules.forEach((rule) => {
    const triggerCondition = generateTriggerCondition(rule.trigger, itemType);
    const conditionCode = generateConditionChain(rule, itemType);

    const ruleHasDestroyCardEffects =
      rule.effects?.some((effect) => effect.type === "destroy_card") ||
      rule.randomGroups?.some((group) =>
        group.effects.some((effect) => effect.type === "destroy_card")
      ) ||
      rule.loops?.some((group) =>
        group.effects.some((effect) => effect.type === "destroy_card")
      );

    const ruleHasRetriggerEffects =
      rule.effects?.some((effect) => effect.type === "retrigger_card") ||
      rule.randomGroups?.some((group) =>
        group.effects.some((effect) => effect.type === "retrigger_card")
      ) ||
      rule.loops?.some((group) =>
        group.effects.some((effect) => effect.type === "retrigger_card")
      );

    const isDiscardTrigger = rule.trigger === "card_discarded";

    let ruleCode = "";

    if (triggerCondition) {
      if (
        (ruleHasDestroyCardEffects || ruleHasRetriggerEffects) &&
        !isDiscardTrigger
      ) {
        ruleCode += `
        if ${triggerCondition} then`;

        if (ruleHasDestroyCardEffects) {
          ruleCode += `
            card.should_destroy = false`;
        }

        if (ruleHasRetriggerEffects) {
          ruleCode += `
            card.should_retrigger = false`;
        }

        if (conditionCode) {
          ruleCode += `
            if ${conditionCode} then`;
        }
      } else {
        ruleCode += `
        if ${triggerCondition}`;

        if (conditionCode) {
          ruleCode += ` and ${conditionCode}`;
        }

        ruleCode += ` then`;
      }
    }

    const regularEffects = rule.effects || [];
    const randomGroups = (rule.randomGroups || []).map((group) => ({
      ...group,
      chance_numerator:
        typeof group.chance_numerator === "string" ? 1 : group.chance_numerator,
      chance_denominator:
        typeof group.chance_denominator === "string"
          ? 1
          : group.chance_denominator,
    }));
    const loopGroups = (rule.loops || []).map((group) => ({
      ...group,
      repetitions:
        typeof group.repetitions === "string"
          ? (() => {
              const parsed = parseGameVariable(group.repetitions);
              const rangeParsed = parseRangeVariable(group.repetitions);
              if (parsed.isGameVariable) {
                return generateGameVariableCode(group.repetitions);
              } else if (rangeParsed.isRangeVariable) {
                const seedName = `repetitions_${group.id.substring(0, 8)}`;
                return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
              } else {
                return `card.ability.extra.${group.repetitions}`
              }
            })()
          : group.repetitions,
    }));

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      cardKey,
      rule.trigger,
      itemType
    );

    const indentLevel =
      (ruleHasDestroyCardEffects || ruleHasRetriggerEffects) &&
      !isDiscardTrigger &&
      conditionCode
        ? "                "
        : "            ";

    if (effectResult.preReturnCode) {
      ruleCode += `
${indentLevel}${effectResult.preReturnCode}`;
    }

    if (effectResult.statement) {
      ruleCode += `
${indentLevel}return ${effectResult.statement}`;
    }

    if (triggerCondition) {
      if (
        (ruleHasDestroyCardEffects || ruleHasRetriggerEffects) &&
        !isDiscardTrigger &&
        conditionCode
      ) {
        ruleCode += `
            end`;
      }
      ruleCode += `
        end`;
    }

    calculateFunction += ruleCode;
  });

  calculateFunction += `
    end`;

  return calculateFunction;
};

const generateLocVarsFunction = (
  item: EnhancementData | SealData | EditionData,
  gameVariables: Array<{
    name: string;
    code: string;
    startsFrom: number;
    multiplier: number;
  }>,
  modPrefix: string,
  itemType: "enhancement" | "seal" | "edition",
  unconditionalEffects: UnconditionalEffect[] = []
): string | null => {
  const descriptionHasVariables = item.description.includes("#");
  if (!descriptionHasVariables) {
    return null;
  }

  const variablePlaceholders = item.description.match(/#(\d+)#/g) || [];
  const maxVariableIndex = Math.max(
    ...variablePlaceholders.map((placeholder) =>
      parseInt(placeholder.replace(/#/g, ""))
    ),
    0
  );

  if (maxVariableIndex === 0) {
    return null;
  }

  const activeRules = item.rules || [];
  const hasRandomGroups = activeRules.some(
    (rule) => rule.randomGroups && rule.randomGroups.length > 0
  );

  const abilityPath =
    itemType === "seal" ? "card.ability.seal.extra" : "card.ability.extra";

  const wrapGameVariableCode = (code: string): string => {
    if (code.includes("G.jokers.cards")) {
      return code.replace(
        "G.jokers.cards",
        "(G.jokers and G.jokers.cards or {})"
      );
    }
    if (code.includes("#G.jokers.cards")) {
      return code.replace(
        "#G.jokers.cards",
        "(G.jokers and G.jokers.cards and #G.jokers.cards or 0)"
      );
    }
    if (code.includes("#G.hand.cards")) {
      return code.replace(
        "#G.hand.cards",
        "(G.hand and G.hand.cards and #G.hand.cards or 0)"
      );
    }
    if (code.includes("#G.deck.cards")) {
      return code.replace(
        "#G.deck.cards",
        "(G.deck and G.deck.cards and #G.deck.cards or 0)"
      );
    }
    if (code.includes("#G.consumeables.cards")) {
      return code.replace(
        "#G.consumeables.cards",
        "(G.consumeables and G.consumeables.cards and #G.consumeables.cards or 0)"
      );
    }
    if (
      code.includes("G.GAME") ||
      code.includes("G.jokers") ||
      code.includes("G.hand") ||
      code.includes("G.deck") ||
      code.includes("G.consumeables")
    ) {
      return `(${code} or 0)`;
    }
    return code;
  };

  const variableMapping: string[] = [];

  if (itemType === "enhancement") {
    const getDefaultEffectValue = (effectType: string): number => {
      switch (effectType) {
        case "add_mult":
          return 4;
        case "add_chips":
          return 30;
        case "edit_dollars":
          return 1;
        default:
          return 0;
      }
    };

    unconditionalEffects.forEach((unconditionalEffect) => {
      if (variableMapping.length >= maxVariableIndex) return;

      const value =
        (unconditionalEffect.effect.params?.value as number) ||
        getDefaultEffectValue(unconditionalEffect.effect.type);
      variableMapping.push(value.toString());
    });
  }

  gameVariables.forEach((gameVar) => {
    if (variableMapping.length >= maxVariableIndex) return;

    let gameVarCode: string;
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
      gameVarCode = wrapGameVariableCode(gameVar.code);
    } else if (gameVar.startsFrom === 0) {
      gameVarCode = `(${wrapGameVariableCode(gameVar.code)}) * ${
        gameVar.multiplier
      }`;
    } else if (gameVar.multiplier === 1) {
      gameVarCode = `${abilityPath}.${varName} + (${wrapGameVariableCode(
        gameVar.code
      )})`;
    } else {
      gameVarCode = `${abilityPath}.${varName} + (${wrapGameVariableCode(
        gameVar.code
      )}) * ${gameVar.multiplier}`;
    }

    variableMapping.push(gameVarCode);
  });

  if (hasRandomGroups) {
    const randomGroups = activeRules.flatMap((rule) => rule.randomGroups || []);
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator)),
    ];

    if (denominators.length === 1) {
      const keyPrefix =
        itemType === "enhancement" ? `m_${modPrefix}` : modPrefix;
      const itemKey =
        itemType === "enhancement"
          ? (item as EnhancementData).enhancementKey
          : (item as SealData).sealKey;

      return `loc_vars = function(self, info_queue, card)
        local numerator, denominator = SMODS.get_probability_vars(card, 1, ${abilityPath}.odds, '${keyPrefix}_${itemKey}')
        return {vars = {${variableMapping.join(", ")}${
        variableMapping.length > 0 ? ", " : ""
      }numerator, denominator}}
    end`;
    } else {
      const probabilityVars: string[] = [];
      denominators.forEach((index) => {
        const varName =
          index === 0
            ? `${abilityPath}.odds`
            : `${abilityPath}.odds${Number(index) + 1}`;
        probabilityVars.push(varName);
      });

      return `loc_vars = function(self, info_queue, card)
        return {vars = {${[...variableMapping, ...probabilityVars]
          .slice(0, maxVariableIndex)
          .join(", ")}}}
    end`;
    }
  }

  const finalVars = variableMapping.slice(0, maxVariableIndex);

  return `loc_vars = function(self, info_queue, card)
        return {vars = {${finalVars.join(", ")}}}
    end`;
};

export const generateEnhancementsCode = (
  enhancements: EnhancementData[],
  options: EnhancementGenerationOptions = {}
): { enhancementsCode: Record<string, string> } => {
  const { modPrefix = "", atlasKey = "CustomEnhancements" } = options;

  const enhancementsWithKeys = enhancements.map((enhancement) => ({
    ...enhancement,
    enhancementKey: enhancement.enhancementKey || slugify(enhancement.name),
  }));

  const enhancementsCode: Record<string, string> = {};
  let currentPosition = 0;

  enhancementsWithKeys.forEach((enhancement) => {
    const result = generateSingleEnhancementCode(
      enhancement,
      atlasKey,
      currentPosition,
      modPrefix
    );
    enhancementsCode[`${enhancement.enhancementKey}.lua`] = result.code;
    currentPosition = result.nextPosition;
  });

  return { enhancementsCode };
};

export const generateSealsCode = (
  seals: SealData[],
  options: SealGenerationOptions = {}
): { sealsCode: Record<string, string> } => {
  const { modPrefix = "", atlasKey = "CustomSeals" } = options;

  const sealsWithKeys = seals.map((seal) => ({
    ...seal,
    sealKey: seal.sealKey || slugify(seal.name),
  }));

  const sealsCode: Record<string, string> = {};
  let currentPosition = 0;

  sealsWithKeys.forEach((seal) => {
    const result = generateSingleSealCode(
      seal,
      atlasKey,
      currentPosition,
      modPrefix
    );
    sealsCode[`${seal.sealKey}.lua`] = result.code;
    currentPosition = result.nextPosition;
  });

  return { sealsCode };
};

export const generateEditionsCode = (
  editions: EditionData[],
  options: { modPrefix?: string } = {}
): { editionsCode: Record<string, string> } => {
  const { modPrefix = "" } = options;

  const editionsWithKeys = editions.map((edition) => ({
    ...edition,
    editionKey: edition.editionKey || slugify(edition.name),
  }));

  const editionsCode: Record<string, string> = {};

  editionsWithKeys.forEach((edition) => {
    const result = generateSingleEditionCode(edition, modPrefix);
    editionsCode[`${edition.editionKey}.lua`] = result.code;
  });

  return { editionsCode };
};

const generateSingleEnhancementCode = (
  enhancement: EnhancementData,
  atlasKey: string,
  currentPosition: number,
  modPrefix: string
): { code: string; nextPosition: number } => {
  const activeRules = enhancement.rules || [];

  const hasNonDiscardDestroy = hasNonDiscardDestroyEffects(activeRules);
  const hasRetrigger = hasRetriggerEffects(activeRules);

  const isUnconditionalRule = (rule: Rule): boolean => {
    return (
      !rule.conditionGroups ||
      rule.conditionGroups.length === 0 ||
      rule.conditionGroups.every(
        (group) => !group.conditions || group.conditions.length === 0
      )
    );
  };

  const allowsBaseConfigConversion = (trigger: string): boolean => {
    return trigger === "card_scored" || trigger === "card_held";
  };

  const isSimpleEffect = (effect: Effect): boolean => {
    const allowedTypes = ["add_mult", "add_chips", "edit_dollars"];
    if (!allowedTypes.includes(effect.type)) {
      return false;
    }

    if (effect.type === "edit_dollars") {
      const operation = (effect.params?.operation as string) || "add";
      if (operation !== "add") {
        return false;
      }
    }

    const value = effect.params?.value;

    if (value === undefined || value === null) {
      return true;
    }

    if (typeof value === "number") {
      return true;
    }

    if (typeof value === "string") {
      if (value.includes("GAMEVAR:") || value.includes("RANGE:")) {
        return false;
      }

      if (value.includes("_value") || value.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {
        return false;
      }

      const numValue = parseFloat(value);
      if (!isNaN(numValue)) {
        return true;
      }

      return false;
    }

    return false;
  };

  const unconditionalEffects: UnconditionalEffect[] = [];
  activeRules.forEach((rule) => {
    if (
      isUnconditionalRule(rule) &&
      allowsBaseConfigConversion(rule.trigger) &&
      rule.effects
    ) {
      rule.effects.forEach((effect) => {
        if (isSimpleEffect(effect)) {
          unconditionalEffects.push({
            trigger: rule.trigger,
            effect: effect,
          });
        }
      });
    }
  });

  const baseConfig: Record<string, number> = {};
  unconditionalEffects.forEach(({ trigger, effect }) => {
    const getDefaultEffectValue = (effectType: string): number => {
      switch (effectType) {
        case "add_mult":
          return 4;
        case "add_chips":
          return 30;
        case "edit_dollars":
          return 1;
        default:
          return 0;
      }
    };

    let value: number;
    if (effect.params?.value === undefined || effect.params?.value === null) {
      value = getDefaultEffectValue(effect.type);
    } else if (typeof effect.params.value === "number") {
      value = effect.params.value;
    } else if (typeof effect.params.value === "string") {
      const numValue = parseFloat(effect.params.value);
      if (!isNaN(numValue)) {
        value = numValue;
      } else {
        console.warn(
          `Unexpected non-numeric value in simple effect: ${effect.params.value}`
        );
        value = getDefaultEffectValue(effect.type);
      }
    } else {
      value = getDefaultEffectValue(effect.type);
    }

    switch (effect.type) {
      case "add_chips":
        if (trigger === "card_scored") {
          baseConfig.bonus = (baseConfig.bonus || 0) + value;
        } else if (trigger === "card_held") {
          baseConfig.h_chips = (baseConfig.h_chips || 0) + value;
        }
        break;

      case "add_mult":
        if (trigger === "card_scored") {
          baseConfig.mult = (baseConfig.mult || 0) + value;
        } else if (trigger === "card_held") {
          baseConfig.h_mult = (baseConfig.h_mult || 0) + value;
        }
        break;

      case "edit_dollars": {
        const operation = (effect.params?.operation as string) || "add";
        if (operation === "add") {
          if (trigger === "card_scored") {
            baseConfig.p_dollars = (baseConfig.p_dollars || 0) + value;
          } else if (trigger === "card_held") {
            baseConfig.h_dollars = (baseConfig.h_dollars || 0) + value;
          }
        }
        break;
      }
    }
  });

  const conditionalRules = activeRules
    .map((rule) => {
      const conditionalEffects = rule.effects?.filter(
        (effect) =>
          !isSimpleEffect(effect) ||
          !isUnconditionalRule(rule) ||
          !allowsBaseConfigConversion(rule.trigger)
      );

      if (
        !isUnconditionalRule(rule) ||
        !allowsBaseConfigConversion(rule.trigger)
      ) {
        return rule;
      }

      if (rule.randomGroups && rule.randomGroups.length > 0) {
        return {
          ...rule,
          effects: conditionalEffects || [],
        };
      }

      if (rule.loops && rule.loops.length > 0) {
        return {
          ...rule,
          effects: conditionalEffects || [],
        };
      }

      if (conditionalEffects && conditionalEffects.length > 0) {
        return {
          ...rule,
          effects: conditionalEffects,
        };
      }

      return null;
    })
    .filter(
      (rule): rule is Rule =>
        rule !== null &&
        (!isUnconditionalRule(rule) ||
          !allowsBaseConfigConversion(rule.trigger) ||
          (rule.effects && rule.effects.length > 0) ||
          (rule.randomGroups && rule.randomGroups.length > 0) ||
          (rule.loops && rule.loops.length > 0)
        )
    );

  const configItems: string[] = [];

  const gameVariables = extractGameVariablesFromRules(activeRules);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  if (enhancement.userVariables && enhancement.userVariables.length > 0) {
    enhancement.userVariables.forEach((variable) => {
      if (variable.type === "number" || !variable.type) {
        configItems.push(`${variable.name} = ${variable.initialValue || 0}`);
      }
    });
  }

  conditionalRules.forEach((rule) => {
    const regularEffects = rule.effects || [];
    const randomGroups = (rule.randomGroups || []).map((group) => ({
      ...group,
      chance_numerator:
        typeof group.chance_numerator === "string" ? 1 : group.chance_numerator,
      chance_denominator:
        typeof group.chance_denominator === "string"
          ? 1
          : group.chance_denominator,
    }));
    const loopGroups = (rule.loops || []).map((group) => ({
      ...group,
      repetitions:
        typeof group.repetitions === "string"
          ? (() => {
              const parsed = parseGameVariable(group.repetitions);
              const rangeParsed = parseRangeVariable(group.repetitions);
              if (parsed.isGameVariable) {
                return generateGameVariableCode(group.repetitions);
              } else if (rangeParsed.isRangeVariable) {
                const seedName = `repetitions_${group.id.substring(0, 8)}`;
                return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
              } else {
                return `card.ability.extra.${group.repetitions}`
              }
            })()
          : group.repetitions,
    }));

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      rule.trigger,
      "enhancement"
    );

    if (effectResult.configVariables) {
      configItems.push(...effectResult.configVariables);
    }
  });

  const enhancementsPerRow = 10;
  const col = currentPosition % enhancementsPerRow;
  const row = Math.floor(currentPosition / enhancementsPerRow);

  const nextPosition = currentPosition + 1;

  let enhancementCode = `SMODS.Enhancement {
    key = '${enhancement.enhancementKey}',
    pos = { x = ${col}, y = ${row} },`;

  const hasBaseConfig = Object.keys(baseConfig).length > 0;
  const hasExtraConfig = configItems.length > 0;

  if (hasBaseConfig || hasExtraConfig) {
    enhancementCode += `
    config = {`;

    Object.entries(baseConfig).forEach(([key, value]) => {
      enhancementCode += `
        ${key} = ${value},`;
    });

    if (hasExtraConfig) {
      enhancementCode += `
        extra = {
            ${configItems.join(",\n            ")}
        }`;
    }

    enhancementCode = enhancementCode.replace(/,$/, "");
    enhancementCode += `
    },`;
  }

  enhancementCode += `
    loc_txt = {
        name = '${enhancement.name}',
        text = ${formatDescription(enhancement)}
    },`;

  if (enhancement.atlas) {
    enhancementCode += `
    atlas = '${enhancement.atlas}',`;
  } else {
    enhancementCode += `
    atlas = '${atlasKey}',`;
  }

  if (enhancement.any_suit !== undefined) {
    enhancementCode += `
    any_suit = ${enhancement.any_suit},`;
  }

  if (hasDestroyCardEffects(activeRules)) {
    enhancementCode += `
    shatters = true,`;
  }

  if (enhancement.replace_base_card !== undefined) {
    enhancementCode += `
    replace_base_card = ${enhancement.replace_base_card},`;
  }

  if (enhancement.no_rank !== undefined) {
    enhancementCode += `
    no_rank = ${enhancement.no_rank},`;
  }

  if (enhancement.no_suit !== undefined) {
    enhancementCode += `
    no_suit = ${enhancement.no_suit},`;
  }

  if (enhancement.always_scores !== undefined) {
    enhancementCode += `
    always_scores = ${enhancement.always_scores},`;
  }

  if (enhancement.unlocked !== undefined) {
    enhancementCode += `
    unlocked = ${enhancement.unlocked},`;
  }

  if (enhancement.discovered !== undefined) {
    enhancementCode += `
    discovered = ${enhancement.discovered},`;
  }

  if (enhancement.no_collection !== undefined) {
    enhancementCode += `
    no_collection = ${enhancement.no_collection},`;
  }

  if (enhancement.weight !== undefined) {
    enhancementCode += `
    weight = ${enhancement.weight},`;
  }

  const locVarsCode = generateLocVarsFunction(
    enhancement,
    gameVariables,
    modPrefix,
    "enhancement",
    unconditionalEffects
  );
  if (locVarsCode) {
    enhancementCode += `
    ${locVarsCode},`;
  }

  const calculateCode = generateCalculateFunction(
    conditionalRules,
    modPrefix,
    hasNonDiscardDestroy,
    hasRetrigger,
    enhancement.enhancementKey,
    "enhancement"
  );
  if (calculateCode) {
    enhancementCode += `
    ${calculateCode},`;
  }

  enhancementCode = enhancementCode.replace(/,$/, "");
  enhancementCode += `
}`;

  return {
    code: enhancementCode,
    nextPosition,
  };
};

const generateSingleSealCode = (
  seal: SealData,
  atlasKey: string,
  currentPosition: number,
  modPrefix: string
): { code: string; nextPosition: number } => {
  const activeRules = seal.rules || [];

  const hasNonDiscardDestroy = hasNonDiscardDestroyEffects(activeRules);
  const hasRetrigger = hasRetriggerEffects(activeRules);

  const configItems: string[] = [];

  const gameVariables = extractGameVariablesFromRules(activeRules);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  activeRules.forEach((rule) => {
    const regularEffects = rule.effects || [];
    const randomGroups = (rule.randomGroups || []).map((group) => ({
      ...group,
      chance_numerator:
        typeof group.chance_numerator === "string" ? 1 : group.chance_numerator,
      chance_denominator:
        typeof group.chance_denominator === "string"
          ? 1
          : group.chance_denominator,
    }));
    const loopGroups = (rule.loops || []).map((group) => ({
      ...group,
      repetitions:
        typeof group.repetitions === "string"
          ? (() => {
              const parsed = parseGameVariable(group.repetitions);
              const rangeParsed = parseRangeVariable(group.repetitions);
              if (parsed.isGameVariable) {
                return generateGameVariableCode(group.repetitions);
              } else if (rangeParsed.isRangeVariable) {
                const seedName = `repetitions_${group.id.substring(0, 8)}`;
                return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
              } else {
                return `card.ability.extra.${group.repetitions}`
              }
            })()
          : group.repetitions,
    }));

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      rule.trigger,
      "seal"
    );

    if (effectResult.configVariables) {
      configItems.push(...effectResult.configVariables);
    }
  });

  if (seal.userVariables && seal.userVariables.length > 0) {
    seal.userVariables.forEach((variable) => {
      if (variable.type === "number" || !variable.type) {
        configItems.push(`${variable.name} = ${variable.initialValue || 0}`);
      }
    });
  }

  const sealsPerRow = 10;
  const col = currentPosition % sealsPerRow;
  const row = Math.floor(currentPosition / sealsPerRow);

  const nextPosition = currentPosition + 1;

  let sealCode = `SMODS.Seal {
    key = '${seal.sealKey}',
    pos = { x = ${col}, y = ${row} },`;

  const hasExtraConfig = configItems.length > 0;

  if (hasExtraConfig) {
    sealCode += `
    config = {
        extra = {
            ${configItems.join(",\n            ")}
        }
    },`;
  }

  if (seal.badge_colour && seal.badge_colour !== "#FFFFFF") {
    sealCode += `
    badge_colour = HEX('${seal.badge_colour.replace("#", "")}'),`;
  }

  sealCode += `
   loc_txt = {
        name = '${seal.name}',
        label = '${seal.name}',
        text = ${formatDescription(seal)}
    },`;

  if (seal.atlas) {
    sealCode += `
    atlas = '${seal.atlas}',`;
  } else {
    sealCode += `
    atlas = '${atlasKey}',`;
  }

  if (seal.unlocked !== undefined) {
    sealCode += `
    unlocked = ${seal.unlocked},`;
  }

  if (seal.discovered !== undefined) {
    sealCode += `
    discovered = ${seal.discovered},`;
  }

  if (seal.no_collection !== undefined) {
    sealCode += `
    no_collection = ${seal.no_collection},`;
  }

  const locVarsCode = generateLocVarsFunction(
    seal,
    gameVariables,
    modPrefix,
    "seal"
  );
  if (locVarsCode) {
    sealCode += `
    ${locVarsCode},`;
  }

  const calculateCode = generateCalculateFunction(
    activeRules,
    modPrefix,
    hasNonDiscardDestroy,
    hasRetrigger,
    seal.sealKey,
    "seal"
  );
  if (calculateCode) {
    sealCode += `
    ${calculateCode},`;
  }

  sealCode = sealCode.replace(/,$/, "");
  sealCode += `
}`;

  return {
    code: sealCode,
    nextPosition,
  };
};

export const generateSingleEditionCode = (
  edition: EditionData,
  modPrefix: string = ""
): { code: string; nextPosition: number } => {
  const editionKey = edition.editionKey || slugify(edition.name);
  const activeRules = edition.rules || [];

  const configItems: string[] = [];

  const gameVariables = extractGameVariablesFromRules(activeRules);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1")
      .toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  activeRules.forEach((rule) => {
    const regularEffects = rule.effects || [];
    const randomGroups = (rule.randomGroups || []).map((group) => ({
      ...group,
      chance_numerator:
        typeof group.chance_numerator === "string" ? 1 : group.chance_numerator,
      chance_denominator:
        typeof group.chance_denominator === "string"
          ? 1
          : group.chance_denominator,
    }));
    const loopGroups = (rule.loops || []).map((group) => ({
      ...group,
      repetitions:
        typeof group.repetitions === "string"
          ? (() => {
              const parsed = parseGameVariable(group.repetitions);
              const rangeParsed = parseRangeVariable(group.repetitions);
              if (parsed.isGameVariable) {
                return generateGameVariableCode(group.repetitions);
              } else if (rangeParsed.isRangeVariable) {
                const seedName = `repetitions_${group.id.substring(0, 8)}`;
                return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
              } else {
                return `card.ability.extra.${group.repetitions}`
              }
            })()
          : group.repetitions,
    }));

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      editionKey,
      rule.trigger,
      "edition"
    );

    if (effectResult.configVariables) {
      configItems.push(...effectResult.configVariables);
    }
  });

  let editionCode = "";

  if (typeof edition.shader === "string" && isCustomShader(edition.shader)) {
    editionCode += `SMODS.Shader({ key = '${edition.shader}', path = '${edition.shader}.fs' })

`;
  }  
  if (edition.userVariables && edition.userVariables.length > 0) {
    edition.userVariables.forEach((variable) => {
      if (variable.type === "number" || !variable.type) {
        configItems.push(`${variable.name} = ${variable.initialValue || 0}`);
      }
      else if (variable.type === "rank"){
        configItems.push(`${variable.name} = ${variable.initialValue || "Ace"}`);}
      else if (variable.type === "suit"){
        configItems.push(`${variable.name} = ${variable.initialValue || "Hearts"}`)}
      else if (variable.type === "pokerhand"){
        configItems.push(`${variable.name} = ${variable.initialValue || "High Card"}`);
      }
    });
  }

  editionCode += `SMODS.Edition {
    key = '${editionKey}',`;

  if (typeof edition.shader === "string" && edition.shader !== "false") {
    const isVanilla = isVanillaShader(edition.shader);

    editionCode += `
    shader = '${edition.shader}',`;

    if (isVanilla) {
      editionCode += `
    prefix_config = {
        -- This allows using the vanilla shader
        -- Not needed when using your own
        shader = false
    },`;
    }
  } else if (edition.shader === false || edition.shader === "false") {
    editionCode += `
    shader = false,`;
  }

  const hasConfig = configItems.length > 0;
  if (hasConfig) {
    editionCode += `
    config = {
        ${configItems.join(",\n        ")}
    },`;
  }

  if (edition.in_shop !== undefined) {
    editionCode += `
    in_shop = ${edition.in_shop},`;
  }

  if (edition.weight !== undefined && edition.weight > 0) {
    editionCode += `
    weight = ${edition.weight},`;
  }

  if (edition.extra_cost !== undefined && edition.extra_cost > 0) {
    editionCode += `
    extra_cost = ${edition.extra_cost},`;
  }

  if (edition.apply_to_float !== undefined) {
    editionCode += `
    apply_to_float = ${edition.apply_to_float},`;
  }

  if (edition.badge_colour && edition.badge_colour !== "#FFAA00") {
    editionCode += `
    badge_colour = HEX('${edition.badge_colour.replace("#", "")}'),`;
  }

  if (edition.sound && edition.sound !== "foil1") {
    editionCode += `
    sound = { sound = "${edition.sound}", per = 1.2, vol = 0.4 },`;
  }

  if (edition.disable_shadow !== undefined) {
    editionCode += `
    disable_shadow = ${edition.disable_shadow},`;
  }

  if (edition.disable_base_shader !== undefined) {
    editionCode += `
    disable_base_shader = ${edition.disable_base_shader},`;
  }

  editionCode += `
    loc_txt = {
        name = '${edition.name}',
        label = '${edition.name}',
        text = ${formatDescription(edition)}
    },`;

  if (edition.unlocked !== undefined) {
    editionCode += `
    unlocked = ${edition.unlocked},`;
  }

  if (edition.discovered !== undefined) {
    editionCode += `
    discovered = ${edition.discovered},`;
  }

  if (edition.no_collection !== undefined) {
    editionCode += `
    no_collection = ${edition.no_collection},`;
  }

  const locVarsCode = generateLocVarsFunction(
    edition,
    gameVariables,
    modPrefix,
    "edition"
  );
  if (locVarsCode) {
    editionCode += `
    ${locVarsCode},`;
  }

  editionCode += `
    get_weight = function(self)
        return G.GAME.edition_rate * self.weight
    end,
  `;

  const calculateCode = generateCalculateFunction(
    activeRules,
    modPrefix,
    false,
    false,
    editionKey,
    "edition"
  );
  if (calculateCode) {
    editionCode += `
    ${calculateCode},`;
  }

  editionCode = editionCode.replace(/,$/, "");
  editionCode += `
}`;

  return {
    code: editionCode,
    nextPosition: 0,
  };
};

export const exportSingleEnhancement = (enhancement: EnhancementData): void => {
  try {
    const enhancementWithKey = enhancement.enhancementKey
      ? enhancement
      : { ...enhancement, enhancementKey: slugify(enhancement.name) };

    const result = generateSingleEnhancementCode(
      enhancementWithKey,
      "Enhancement",
      0,
      "modprefix"
    );
    const enhancementCode = result.code;

    const blob = new Blob([enhancementCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${enhancementWithKey.enhancementKey}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export enhancement:", error);
    throw error;
  }
};

export const exportSingleSeal = (seal: SealData): void => {
  try {
    const sealWithKey = seal.sealKey
      ? seal
      : { ...seal, sealKey: slugify(seal.name) };

    const result = generateSingleSealCode(sealWithKey, "Seal", 0, "modprefix");
    const sealCode = result.code;

    const blob = new Blob([sealCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${sealWithKey.sealKey}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export seal:", error);
    throw error;
  }
};

export const exportSingleEdition = (edition: EditionData): void => {
  try {
    const editionWithKey = edition.editionKey
      ? edition
      : { ...edition, editionKey: slugify(edition.name) };

    const result = generateSingleEditionCode(editionWithKey);
    const editionCode = result.code;

    const blob = new Blob([editionCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${editionWithKey.editionKey}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export edition:", error);
    throw error;
  }
};

function formatDescription(
  enhancement: EnhancementData | SealData | EditionData
): string {
  const formatted = enhancement.description.replace(/<br\s*\/?>/gi, "[s]");
  const escaped = formatted.replace(/\n/g, "[s]");
  const lines = escaped.split("[s]").map((line) => line.trim());

  if (lines.length === 0) {
    lines.push(escaped.trim());
  }

  return `{
${lines
  .map(
    (line, i) =>
      `        [${i + 1}] = '${line
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/'/g, "\\'")}'`
  )
  .join(",\n")}
    }`;
}

```

### src\components\codeGeneration\Card\triggerUtils.ts

```
interface TriggerDefinition {
  condition: string;
  context: string;
  description: string;
}

const TRIGGER_DEFINITIONS: Record<string, TriggerDefinition> = {
  card_scored: {
    condition: "context.main_scoring and context.cardarea == G.play",
    context: "scoring context",
    description: "When this card is part of a scoring hand",
  },
  card_held: {
    condition: "context.cardarea == G.hand and context.main_scoring",
    context: "hand context",
    description: "When this card is held in the player's hand",
  },
  card_held_in_hand_end_of_round: {
    condition:
      "context.end_of_round and context.cardarea == G.hand and context.other_card == card and context.individual",
    context: "end of round context",
    description: "When this card is held in hand at the end of the round",
  },
  card_discarded: {
    condition: "context.discard and context.other_card == card",
    context: "discard context",
    description:
      "Triggers whenever a card is discarded. Use conditions to check properties of the discarded card.",
  },
};

export const generateTriggerCondition = (
  trigger: string,
  itemType?: "enhancement" | "seal" | "edition"
): string => {
  if (trigger === "card_scored" && itemType === "edition") {
    return "context.pre_joker or (context.main_scoring and context.cardarea == G.play)";
  }
  return TRIGGER_DEFINITIONS[trigger]?.condition || "";
};

```

### src\components\codeGeneration\Consumables\conditions\AnteLevelCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateAnteLevelConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "ante_level") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value ?? 1;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `G.GAME.round_resets.ante > ${valueCode}`;
    case "greater_than_or_equal":
      return `G.GAME.round_resets.ante >= ${valueCode}`;
    case "less_than":
      return `G.GAME.round_resets.ante < ${valueCode}`;
    case "less_than_or_equal":
      return `G.GAME.round_resets.ante <= ${valueCode}`;
    case "equal":
      return `G.GAME.round_resets.ante == ${valueCode}`;
    case "not_equal":
      return `G.GAME.round_resets.ante ~= ${valueCode}`;
    default:
      return `G.GAME.round_resets.ante > ${valueCode}`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\CardsSelectedCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCardsSelectedConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "cards_selected") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value || 1;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `#G.hand.highlighted > ${valueCode}`;
    case "greater_equals":
      return `#G.hand.highlighted >= ${valueCode}`;
    case "less_than":
      return `#G.hand.highlighted < ${valueCode}`;
    case "less_equals":
      return `#G.hand.highlighted <= ${valueCode}`;
    case "equals":
      return `#G.hand.highlighted == ${valueCode}`;
    case "not_equal":
      return `#G.hand.highlighted ~= ${valueCode}`;
    default:
      return `#G.hand.highlighted > ${valueCode}`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\CheckFlagCondition.ts

```
import { getModPrefix } from "../../../data/BalatroUtils";
import type { Rule } from "../../../ruleBuilder/types";

export const generateCheckFlagConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const flagName = (condition.params.flag_name as string) || "custom_flag";

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore

  const modPrefix = getModPrefix()

  return `(G.GAME.pool_flags.${modPrefix}_${safeFlagName} or false)`;
};

```

### src\components\codeGeneration\Consumables\conditions\ConsumableCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateConsumableCountConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "consumable_count") return "";

  const consumableType = (condition.params.consumable_type as string) || "any";
  const specificCard = (condition.params.specific_card as string) || "any";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  if (consumableType === "any") {
    return `#G.consumeables.cards ${comparison}`;
  }

  // Handle vanilla sets
  if (
    consumableType === "Tarot" ||
    consumableType === "Planet" ||
    consumableType === "Spectral"
  ) {
    if (specificCard === "any") {
      return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.ability.set == '${consumableType}' then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
    } else {
      const normalizedCardKey = specificCard.startsWith("c_")
        ? specificCard
        : `c_${specificCard}`;

      return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.config.center.key == "${normalizedCardKey}" then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
    }
  }

  // Handle custom consumable sets
  const setKey = consumableType.includes("_")
    ? consumableType.split("_").slice(1).join("_")
    : consumableType;

  if (specificCard === "any") {
    return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.ability.set == '${setKey}' or consumable_card.ability.set == '${consumableType}' then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
  } else {
    const normalizedCardKey = specificCard.startsWith("c_")
      ? specificCard
      : `c_${specificCard}`;

    return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.config.center.key == "${normalizedCardKey}" then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\HandSizeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateHandSizeConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "hand_size") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value || 8;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `G.hand.config.card_limit > ${valueCode}`;
    case "greater_than_or_equal":
      return `G.hand.config.card_limit >= ${valueCode}`;
    case "less_than":
      return `G.hand.config.card_limit < ${valueCode}`;
    case "less_than_or_equal":
      return `G.hand.config.card_limit <= ${valueCode}`;
    case "equal":
      return `G.hand.config.card_limit == ${valueCode}`;
    case "not_equal":
      return `G.hand.config.card_limit ~= ${valueCode}`;
    default:
      return `G.hand.config.card_limit > ${valueCode}`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\InBlindCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateInBlindConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "in_blind") return "";

  return "G.GAME.blind.in_blind";
};

```

### src\components\codeGeneration\Consumables\conditions\PlayerMoneyCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generatePlayerMoneyConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "player_money") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value || 0;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `G.GAME.dollars > ${valueCode}`;
    case "greater_than_or_equal":
      return `G.GAME.dollars >= ${valueCode}`;
    case "less_than":
      return `G.GAME.dollars < ${valueCode}`;
    case "less_than_or_equal":
      return `G.GAME.dollars <= ${valueCode}`;
    case "equal":
      return `G.GAME.dollars == ${valueCode}`;
    case "not_equal":
      return `G.GAME.dollars ~= ${valueCode}`;
    default:
      return `G.GAME.dollars > ${valueCode}`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\RemainingHandsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateRemainingHandsConditionCode = (rules: Rule[]): string => {
  if (rules.length === 0) return "";

  const rule = rules[0];
  const condition = rule.conditionGroups?.[0]?.conditions?.[0];
  if (!condition || condition.type !== "remaining_hands") return "";

  const operator = condition.params?.operator || "greater_than";
  const value = condition.params?.value ?? 1;

  const valueCode = generateGameVariableCode(value);

  switch (operator) {
    case "greater_than":
      return `G.GAME.current_round.hands_left > ${valueCode}`;
    case "greater_than_or_equal":
      return `G.GAME.current_round.hands_left >= ${valueCode}`;
    case "less_than":
      return `G.GAME.current_round.hands_left < ${valueCode}`;
    case "less_than_or_equal":
      return `G.GAME.current_round.hands_left <= ${valueCode}`;
    case "equal":
      return `G.GAME.current_round.hands_left == ${valueCode}`;
    case "not_equal":
      return `G.GAME.current_round.hands_left ~= ${valueCode}`;
    default:
      return `G.GAME.current_round.hands_left > ${valueCode}`;
  }
};

```

### src\components\codeGeneration\Consumables\conditions\SystemCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateSystemConditionCode = (
  rules: Rule[],
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];

  return `love.system.getOS() == "${condition.params?.system || "Windows"}"`;
};

```

### src\components\codeGeneration\Consumables\conditions\VoucherRedeemedCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateVoucherRedeemedConditionCode = (
  rules: Rule[]
): string => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const voucher = (condition.params.voucher as string) || "v_overstock_norm";

  return `G.GAME.used_vouchers["${voucher}"]`
};

```

### src\components\codeGeneration\Consumables\conditionUtils.ts

```
import type { Rule, Condition, ConditionGroup } from "../../ruleBuilder/types";
import { generatePlayerMoneyConditionCode } from "./conditions/PlayerMoneyCondition";
import { generateCardsSelectedConditionCode } from "./conditions/CardsSelectedCondition";
import { generateAnteLevelConditionCode } from "./conditions/AnteLevelCondition";
import { generateHandSizeConditionCode } from "./conditions/HandSizeCondition";
import { generateRemainingHandsConditionCode } from "./conditions/RemainingHandsCondition";
import { generateVoucherRedeemedConditionCode } from "./conditions/VoucherRedeemedCondition";
import { generateInBlindConditionCode } from "./conditions/InBlindCondition";
import { generateConsumableCountConditionCode } from "./conditions/ConsumableCountCondition";
import { generateCheckFlagConditionCode } from "./conditions/CheckFlagCondition";
import { generateSystemConditionCode } from "./conditions/SystemCondition";

export const generateConditionChain = (rule: Rule): string => {
  if (!rule.conditionGroups || rule.conditionGroups.length === 0) {
    return "";
  }

  const groupConditions: string[] = [];

  rule.conditionGroups.forEach((group) => {
    const conditions = generateConditionGroupCode(group, rule);
    if (conditions) {
      groupConditions.push(conditions);
    }
  });

  if (groupConditions.length === 0) {
    return "";
  }

  if (groupConditions.length === 1) {
    return groupConditions[0];
  }

  return `(${groupConditions.join(") and (")})`;
};

const generateConditionGroupCode = (
  group: ConditionGroup,
  rule: Rule
): string => {
  if (!group.conditions || group.conditions.length === 0) {
    return "";
  }

  const conditionCodes: string[] = [];

  group.conditions.forEach((condition) => {
    const code = generateSingleConditionCode(condition, rule);
    if (code) {
      let finalCode = code;

      if (condition.negate) {
        finalCode = `not (${code})`;
      }

      conditionCodes.push(finalCode);
    }
  });

  if (conditionCodes.length === 0) {
    return "";
  }

  if (conditionCodes.length === 1) {
    return conditionCodes[0];
  }

  let result = conditionCodes[0];
  for (let i = 1; i < conditionCodes.length; i++) {
    const prevCondition = group.conditions[i - 1];
    const operator = prevCondition.operator === "or" ? " or " : " and ";
    result += operator + conditionCodes[i];
  }

  return `(${result})`;
};

const generateSingleConditionCode = (
  condition: Condition,
  rule: Rule
): string | null => {
  const singleConditionRule = {
    ...rule,
    conditionGroups: [
      {
        ...rule.conditionGroups[0],
        conditions: [condition],
      },
    ],
  };

  switch (condition.type) {
    case "player_money":
      return generatePlayerMoneyConditionCode([singleConditionRule]);

    case "cards_selected":
      return generateCardsSelectedConditionCode([singleConditionRule]);

    case "ante_level":
      return generateAnteLevelConditionCode([singleConditionRule]);

    case "hand_size":
      return generateHandSizeConditionCode([singleConditionRule]);

    case "remaining_hands":
      return generateRemainingHandsConditionCode([singleConditionRule]);

    case "voucher_redeemed":
      return generateVoucherRedeemedConditionCode([singleConditionRule]);

    case "in_blind":
      return generateInBlindConditionCode([singleConditionRule]);

    case "consumable_count":
      return generateConsumableCountConditionCode([singleConditionRule]);
    
    case "check_flag":
      return generateCheckFlagConditionCode([singleConditionRule]);

    case "system_condition":
      return generateSystemConditionCode([singleConditionRule]);

    default:
      return null;
  }
};

```

### src\components\codeGeneration\Consumables\effects\AddCardsToHandEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateAddCardsToHandReturn = (effect: Effect): EffectReturn => {
  const enhancement = effect.params?.enhancement || "none";
  const seal = effect.params?.seal || "none";
  const edition = effect.params?.edition || "none";
  const suit = effect.params?.suit || "none";
  const rank = effect.params?.rank || "random";
  const count = effect.params?.count || 1;
  const customMessage = effect.customMessage;

  const countCode = generateGameVariableCode(count);

  let addCardsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.7,
                func = function()
                    local cards = {}
                    for i = 1, ${countCode} do`;

  // Handle rank selection
  if (rank === "Face Cards") {
    addCardsCode += `
                        local faces = {}
                        for _, rank_key in ipairs(SMODS.Rank.obj_buffer) do
                            local rank = SMODS.Ranks[rank_key]
                            if rank.face then table.insert(faces, rank) end
                        end
                        local _rank = pseudorandom_element(faces, 'add_face_cards').card_key`;
  } else if (rank === "Numbered Cards") {
    addCardsCode += `
                        local numbers = {}
                        for _, rank_key in ipairs(SMODS.Rank.obj_buffer) do
                            local rank = SMODS.Ranks[rank_key]
                            if rank_key ~= 'Ace' and not rank.face then table.insert(numbers, rank) end
                        end
                        local _rank = pseudorandom_element(numbers, 'add_numbered_cards').card_key`;
  } else if (rank === "random") {
    addCardsCode += `
                        local _rank = pseudorandom_element(SMODS.Ranks, 'add_random_rank').card_key`;
  } else {
    addCardsCode += `
                        local _rank = '${rank}'`;
  }

  // Handle suit selection
  if (suit === "random") {
    addCardsCode += `
                        local _suit = pseudorandom_element(SMODS.Suits, 'add_random_suit').key`;
  } else if (suit !== "none") {
    addCardsCode += `
                        local _suit = '${suit}'`;
  } else {
    addCardsCode += `
                        local _suit = nil`;
  }

  // Handle enhancement selection
  if (enhancement === "random") {
    addCardsCode += `
                        local cen_pool = {}
                        for _, enhancement_center in pairs(G.P_CENTER_POOLS["Enhanced"]) do
                            if enhancement_center.key ~= 'm_stone' and not enhancement_center.overrides_base_rank then
                                cen_pool[#cen_pool + 1] = enhancement_center
                            end
                        end
                        local enhancement = pseudorandom_element(cen_pool, 'add_cards_enhancement')`;
  } else if (enhancement !== "none") {
    addCardsCode += `
                        local enhancement = G.P_CENTERS['${enhancement}']`;
  }

  // Create the card
  addCardsCode += `
                        local new_card_params = { set = "Base" }
                        if _rank then new_card_params.rank = _rank end
                        if _suit then new_card_params.suit = _suit end`;

  if (enhancement !== "none") {
    addCardsCode += `
                        if enhancement then new_card_params.enhancement = enhancement.key end`;
  }

  addCardsCode += `
                        cards[i] = SMODS.add_card(new_card_params)`;

  // Apply seal if specified
  if (seal !== "none") {
    if (seal === "random") {
      addCardsCode += `
                        if cards[i] then
                            local seal_pool = {'Gold', 'Red', 'Blue', 'Purple'}
                            local random_seal = pseudorandom_element(seal_pool, 'add_cards_seal')
                            cards[i]:set_seal(random_seal, nil, true)
                        end`;
    } else {
      addCardsCode += `
                        if cards[i] then
                            cards[i]:set_seal('${seal}', nil, true)
                        end`;
    }
  }

  // Apply edition if specified
  if (edition !== "none") {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };

    if (edition === "random") {
      addCardsCode += `
                        if cards[i] then
                            local edition = poll_edition('add_cards_edition', nil, true, true, 
                                { 'e_polychrome', 'e_holo', 'e_foil' })
                            cards[i]:set_edition(edition, true)
                        end`;
    } else {
      const editionLua =
        editionMap[edition as keyof typeof editionMap] || "foil";
      addCardsCode += `
                        if cards[i] then
                            cards[i]:set_edition({ ${editionLua} = true }, true)
                        end`;
    }
  }

  addCardsCode += `
                    end
                    SMODS.calculate_context({ playing_card_added = true, cards = cards })
                    return true
                end
            }))
            delay(0.3)
            __PRE_RETURN_CODE_END__`;

  // Only add config variable if it's not a game variable
  const configVariables =
    typeof count === "string" && count.startsWith("GAMEVAR:")
      ? []
      : [`add_cards_count = ${count}`];

  const result: EffectReturn = {
    statement: addCardsCode,
    colour: "G.C.SECONDARY_SET.Spectral",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\AddDollarsFromJokersEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateAddDollarsFromJokersReturn = (
  effect: Effect
): EffectReturn => {
  const limit = effect.params?.limit || 50;
  const customMessage = effect.customMessage;

  const limitCode = generateGameVariableCode(limit);

  const jokerDollarsCode = `
            __PRE_RETURN_CODE__
            local money = 0
            for i = 1, #G.jokers.cards do
                if G.jokers.cards[i].ability.set == 'Joker' then
                    money = money + G.jokers.cards[i].sell_cost
                end
            end
            card.ability.extra.joker_money = math.min(money, ${limitCode})

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('timpani')
                    used_card:juice_up(0.3, 0.5)
                    ease_dollars(card.ability.extra.joker_money, true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const configVariables =
    typeof limit === "string" && limit.startsWith("GAMEVAR:")
      ? [`joker_money = 0`]
      : [`joker_limit = ${limit}`, `joker_money = 0`];

  const result: EffectReturn = {
    statement: jokerDollarsCode,
    colour: "G.C.MONEY",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\ConvertAllCardsToRankEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateConvertAllCardsToRankReturn = (
  effect: Effect
): EffectReturn => {
  const rank = effect.params?.rank || "Ace";
  const customMessage = effect.customMessage;

  let rankCode = "";

  if (rank === "random") {
    rankCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.cards do
                local percent = 1.15 - (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('card1', percent)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            local _rank = pseudorandom_element(SMODS.Ranks, 'convert_all_rank')
            for i = 1, #G.hand.cards do
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = G.hand.cards[i]
                        assert(SMODS.change_base(_card, nil, _rank.key))
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                local percent = 0.85 + (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.5)
            __PRE_RETURN_CODE_END__`;
  } else {
    rankCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.cards do
                local percent = 1.15 - (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('card1', percent)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = G.hand.cards[i]
                        assert(SMODS.change_base(_card, nil, '${rank}'))
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                local percent = 0.85 + (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.5)
            __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement: rankCode,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\ConvertAllCardsToSuitEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateConvertAllCardsToSuitReturn = (
  effect: Effect
): EffectReturn => {
  const suit = effect.params?.suit || "Hearts";
  const customMessage = effect.customMessage;

  let suitCode = "";

  if (suit === "random") {
    suitCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.cards do
                local percent = 1.15 - (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('card1', percent)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            local _suit = pseudorandom_element(SMODS.Suits, 'convert_all_suit')
            for i = 1, #G.hand.cards do
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = G.hand.cards[i]
                        assert(SMODS.change_base(_card, _suit.key))
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                local percent = 0.85 + (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.5)
            __PRE_RETURN_CODE_END__`;
  } else {
    suitCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.cards do
                local percent = 1.15 - (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('card1', percent)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local _card = G.hand.cards[i]
                        assert(SMODS.change_base(_card, '${suit}'))
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.cards do
                local percent = 0.85 + (i - 0.999) / (#G.hand.cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.cards[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.5)
            __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement: suitCode,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\ConvertLeftToRightEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateConvertLeftToRightReturn = (
  effect: Effect
): EffectReturn => {
  const customMessage = effect.customMessage;

  const convertLeftToRightCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.highlighted do
                local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('card1', percent)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.2)
            local rightmost = G.hand.highlighted[1]
            for i = 1, #G.hand.highlighted do
                if G.hand.highlighted[i].T.x > rightmost.T.x then
                    rightmost = G.hand.highlighted[i]
                end
            end
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        if G.hand.highlighted[i] ~= rightmost then
                            copy_card(rightmost, G.hand.highlighted[i])
                        end
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.highlighted do
                local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    G.hand:unhighlight_all()
                    return true
                end
            }))
            delay(0.5)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: convertLeftToRightCode,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\CopyRandomJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCopyRandomJokerReturn = (effect: Effect): EffectReturn => {
  const amount = effect.params?.amount || 1;
  const edition = effect.params?.edition || "none";
  const customMessage = effect.customMessage;

  let copyJokerCode = `
            __PRE_RETURN_CODE__
            local jokers_to_copy = {}
            local available_jokers = {}
            
            for _, joker in pairs(G.jokers.cards) do
                if joker.ability.set == 'Joker' then
                    available_jokers[#available_jokers + 1] = joker
                end
            end
            
            if #available_jokers > 0 then
                local temp_jokers = {}
                for _, joker in ipairs(available_jokers) do 
                    temp_jokers[#temp_jokers + 1] = joker 
                end
                
                pseudoshuffle(temp_jokers, 54321)
                
                for i = 1, math.min(card.ability.extra.copy_amount, #temp_jokers, G.jokers.config.card_limit - #G.jokers.cards) do
                    jokers_to_copy[#jokers_to_copy + 1] = temp_jokers[i]
                end
            end

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('timpani')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))

            local _first_materialize = nil
            for _, joker_to_copy in pairs(jokers_to_copy) do
                G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.4,
                    func = function()
                        local copied_joker = copy_card(joker_to_copy, nil, nil, nil, false)
                        copied_joker:start_materialize(nil, _first_materialize)
                        copied_joker:add_to_deck()
                        G.jokers:emplace(copied_joker)
                        _first_materialize = true`;

  // Handle edition application
  if (edition === "remove") {
    copyJokerCode += `
                        copied_joker:set_edition(nil, true)`;
  } else if (edition === "random") {
    copyJokerCode += `
                        local edition = poll_edition('copy_joker_edition', nil, true, true, 
                            { 'e_polychrome', 'e_holo', 'e_foil' })
                        copied_joker:set_edition(edition, true)`;
  } else if (edition !== "none") {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };
    const editionLua = editionMap[edition as keyof typeof editionMap] || "foil";
    copyJokerCode += `
                        copied_joker:set_edition({ ${editionLua} = true }, true)`;
  }

  copyJokerCode += `
                        return true
                    end
                }))
            end
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: copyJokerCode,
    colour: "G.C.SECONDARY_SET.Spectral",
    configVariables: [`copy_amount = ${amount}`],
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\CopySelectedCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCopySelectedCardsReturn = (
  effect: Effect
): EffectReturn => {
  const copies = effect.params?.copies || 1;
  const enhancement = effect.params?.enhancement || "none";
  const seal = effect.params?.seal || "none";
  const edition = effect.params?.edition || "none";
  const customMessage = effect.customMessage;

  let copyCardsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                func = function()
                    local _first_materialize = nil
                    local new_cards = {}
                    
                    for _, selected_card in pairs(G.hand.highlighted) do
                        for i = 1, card.ability.extra.copy_cards_amount do
                            G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                            local copied_card = copy_card(selected_card, nil, nil, G.playing_card)
                            copied_card:add_to_deck()
                            G.deck.config.card_limit = G.deck.config.card_limit + 1
                            table.insert(G.playing_cards, copied_card)
                            G.hand:emplace(copied_card)
                            copied_card:start_materialize(nil, _first_materialize)
                            _first_materialize = true
                            new_cards[#new_cards + 1] = copied_card`;

  // Apply enhancement if specified
  if (enhancement !== "none") {
    if (enhancement === "random") {
      copyCardsCode += `
                            
                            local cen_pool = {}
                            for _, enhancement_center in pairs(G.P_CENTER_POOLS["Enhanced"]) do
                                if enhancement_center.key ~= 'm_stone' then
                                    cen_pool[#cen_pool + 1] = enhancement_center
                                end
                            end
                            local enhancement = pseudorandom_element(cen_pool, 'copy_cards_enhancement')
                            copied_card:set_ability(enhancement)`;
    } else {
      copyCardsCode += `
                            
                            copied_card:set_ability(G.P_CENTERS['${enhancement}'])`;
    }
  }

  // Apply seal if specified
  if (seal !== "none") {
    if (seal === "random") {
      copyCardsCode += `
                            
                            local seal_pool = {'Gold', 'Red', 'Blue', 'Purple'}
                            local random_seal = pseudorandom_element(seal_pool, 'copy_cards_seal')
                            copied_card:set_seal(random_seal, nil, true)`;
    } else {
      copyCardsCode += `
                            
                            copied_card:set_seal('${seal}', nil, true)`;
    }
  }

  // Apply edition if specified
  if (edition !== "none") {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };

    if (edition === "random") {
      copyCardsCode += `
                            
                            local edition = poll_edition('copy_cards_edition', nil, true, true, 
                                { 'e_polychrome', 'e_holo', 'e_foil' })
                            copied_card:set_edition(edition, true)`;
    } else if (edition === "remove") {
      copyCardsCode += `
                            
                            copied_card:set_edition(nil, true)`;
    } else {
      const editionLua =
        editionMap[edition as keyof typeof editionMap] || "foil";
      copyCardsCode += `
                            
                            copied_card:set_edition({ ${editionLua} = true }, true)`;
    }
  }

  copyCardsCode += `
                        end
                    end
                    
                    SMODS.calculate_context({ playing_card_added = true, cards = new_cards })
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: copyCardsCode,
    colour: "G.C.SECONDARY_SET.Spectral",
    configVariables: [`copy_cards_amount = ${copies}`],
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\CreateConsumableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCreateConsumableReturn = (
  effect: Effect
): EffectReturn => {
  const set = effect.params?.set || "random";
  const specificCard = effect.params?.specific_card || "random";
  const isNegative = (effect.params?.is_negative as string) == 'y';
  const isSoulable = (effect.params?.soulable as string) == 'y';

  const count = effect.params?.count || 1;
  const customMessage = effect.customMessage;


  const countCode = generateGameVariableCode(count);

  let createCode = `
    __PRE_RETURN_CODE__`
  
  if (!isNegative){createCode += `
    for i = 1, math.min(${countCode}, G.consumeables.config.card_limit - #G.consumeables.cards) do`
  }else{createCode += `
    for i = 1, ${countCode} do`
  }
  
  createCode += `
            G.E_MANAGER:add_event(Event({
            trigger = 'after',
            delay = 0.4,
            func = function()`
  if (isNegative){createCode += `
            if G.consumeables.config.card_limit > #G.consumeables.cards then`}

  createCode +=`
            play_sound('timpani')`
                 
  if (set === "random"){createCode += `
            local sets = {'Tarot', 'Planet', 'Spectral'}
            local random_set = pseudorandom_element(sets, 'random_consumable_set')`
  }

  createCode += `
            SMODS.add_card({ `

  if (set == "random"){createCode += `set = random_set, `}
  else if (specificCard == "random"){createCode += `set = ${set}, `}

  if (isNegative){createCode += `edition = 'e_negative', `}
  if (isSoulable && specificCard == "random"){createCode += `soulable = true, `}
  if (set !== "random" && specificCard !== "random"){createCode += `key = '${specificCard}'`}

  createCode += `})                            
            used_card:juice_up(0.3, 0.5)`

  if (isNegative){createCode += `
            end`}

  createCode +=`
            return true
        end
        }))
    end
    delay(0.6)
    __PRE_RETURN_CODE_END__`

  const configVariables =
    typeof count === "string" && count.startsWith("GAMEVAR:")
      ? []
      : [`
        consumable_count = ${count}`];

  const result: EffectReturn = {
    statement: createCode,
    colour: "G.C.SECONDARY_SET.Tarot",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\CreateJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateCreateJokerReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const jokerType = (effect.params?.joker_type as string) || "random";
  const rarity = (effect.params?.rarity as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const pool = (effect.params?.pool as string) || "";
  const edition = (effect.params?.edition as string) || "none";
  const sticker = (effect.params?.sticker as string) || "none";
  const ignoreSlotsParam = (effect.params?.ignore_slots as string) || "respect";
  const customMessage = effect.customMessage;

  const isNegative = edition === "e_negative";
  const hasSticker = sticker !== "none";
  const ignoreSlots = ignoreSlotsParam === "ignore";

  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  // Build SMODS.add_card parameters
  const cardParams = [];

  if (pool && pool.trim()) {
    const finalPool = modprefix ? `${modprefix}_${pool.trim()}` : pool.trim();
    cardParams.push(`set = '${finalPool}'`);
  } else {
    cardParams.push(`set = 'Joker'`);
  }

  if (jokerType === "specific" && normalizedJokerKey) {
    cardParams.push(`key = '${normalizedJokerKey}'`);
  } else if (rarity !== "random" && (!pool || !pool.trim())) {
    const rarityMap: Record<string, string> = {
      common: "Common",
      uncommon: "Uncommon",
      rare: "Rare",
      legendary: "Legendary",
    };
    const isVanillaRarity = Object.keys(rarityMap).includes(
      rarity.toLowerCase()
    );
    const finalRarity = isVanillaRarity
      ? rarityMap[rarity.toLowerCase()]
      : modprefix
      ? `${modprefix}_${rarity}`
      : rarity;
    cardParams.push(`rarity = '${finalRarity}'`);
  }

  // Build the creation code
  const lines: string[] = [
    "G.E_MANAGER:add_event(Event({",
    "    trigger = 'after',",
    "    delay = 0.4,",
    "    func = function()",
    "        play_sound('timpani')",
  ];

  // Handle slot limits
  if (!(isNegative || ignoreSlots)) {
    lines.push(
      "        if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then",
      "            G.GAME.joker_buffer = G.GAME.joker_buffer + 1"
    );
  }

  // Card creation
  lines.push(
    `        local new_joker = SMODS.add_card({ ${cardParams.join(", ")} })`
  );
  lines.push("        if new_joker then");

  if (edition !== "none") {
    lines.push(`            new_joker:set_edition("${edition}", true)`);
  }

  if (hasSticker) {
    lines.push(`            new_joker:add_sticker('${sticker}', true)`);
  }

  lines.push("        end");

  // Close slot limit check
  if (!(isNegative || ignoreSlots)) {
    lines.push("            G.GAME.joker_buffer = 0", "        end");
  }

  lines.push(
    "        used_card:juice_up(0.3, 0.5)",
    "        return true",
    "    end",
    "}))",
    "delay(0.6)"
  );

  const createJokerCode = lines.join("\n              ");

  const result: EffectReturn = {
    statement: `__PRE_RETURN_CODE__
              ${createJokerCode}
              __PRE_RETURN_CODE_END__`,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\CreateTagEffect.ts

```
import { Effect } from "../../../ruleBuilder/types";
import { EffectReturn } from "../effectUtils";
import { TAG_TYPES } from "../../../data/BalatroUtils";

export const generateCreateTagReturn = (
  effect: Effect
): EffectReturn => {
  const tagType = (effect.params?.tag_type as string) || "random";
  const specificTag = (effect.params?.specific_tag as string) || "double";
  const customMessage = effect.customMessage;

  let tagCreationCode = "";

  if (tagType === "random") {
    tagCreationCode = `
            G.E_MANAGER:add_event(Event({
                func = function()
                    local selected_tag = pseudorandom_element(G.P_TAGS, pseudoseed("create_tag")).key
                    local tag = Tag(selected_tag)
                    if tag.name == "Orbital Tag" then
                        local _poker_hands = {}
                        for k, v in pairs(G.GAME.hands) do
                            if v.visible then
                                _poker_hands[#_poker_hands + 1] = k
                            end
                        end
                        tag.ability.orbital_hand = pseudorandom_element(_poker_hands, "jokerforge_orbital")
                    end
                    tag:set_ability()
                    add_tag(tag)
                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)
                    return true
                end
            }))`;
  } else {
    const tagKey = TAG_TYPES[specificTag] || "tag_double";
    tagCreationCode = `
            G.E_MANAGER:add_event(Event({
                func = function()
                    local tag = Tag("${tagKey}")
                    if tag.name == "Orbital Tag" then
                        local _poker_hands = {}
                        for k, v in pairs(G.GAME.hands) do
                            if v.visible then
                                _poker_hands[#_poker_hands + 1] = k
                            end
                        end
                        tag.ability.orbital_hand = pseudorandom_element(_poker_hands, "jokerforge_orbital")
                    end
                    tag:set_ability()
                    add_tag(tag)
                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)
                    return true
                end
            }))`;
  }

  return {
    statement: `__PRE_RETURN_CODE__${tagCreationCode}
              __PRE_RETURN_CODE_END__`,
    message: customMessage ? `"${customMessage}"` : `"Created Tag!"`,
    colour: "G.C.GREEN",
  };
};
```

### src\components\codeGeneration\Consumables\effects\DestroyConsumableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateDestroyConsumableReturn = (
  effect: Effect
): EffectReturn => {
  const set = (effect.params?.set as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const customMessage = effect.customMessage;

  let destroyCode = "";
  const messageText = customMessage
    ? `"${customMessage}"`
    : `"Destroyed Consumable!"`;

  if (set === "random") {
    destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                table.insert(target_cards, consumable)
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
  } else {
    if (specificCard === "random") {
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    } else {
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${set}" and consumable.config.center.key == "${specificCard}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    }
  }

  return {
    statement: `__PRE_RETURN_CODE__${destroyCode}
              __PRE_RETURN_CODE_END__`,
    colour: "G.C.RED",
  };
};

```

### src\components\codeGeneration\Consumables\effects\DestroyRandomCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateDestroyRandomCardsReturn = (
  effect: Effect
): EffectReturn => {
  const count = effect.params?.count || 1;
  const customMessage = effect.customMessage;

  const countCode = generateGameVariableCode(count);

  const destroyCode = `
            local destroyed_cards = {}
            local temp_hand = {}

            for _, playing_card in ipairs(G.hand.cards) do temp_hand[#temp_hand + 1] = playing_card end
            table.sort(temp_hand,
                function(a, b)
                    return not a.playing_card or not b.playing_card or a.playing_card < b.playing_card
                end
            )

            pseudoshuffle(temp_hand, 12345)

            for i = 1, ${countCode} do destroyed_cards[#destroyed_cards + 1] = temp_hand[i] end

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            SMODS.destroy_cards(destroyed_cards)

            delay(0.5)`;

  const configVariables =
    typeof count === "string" && count.startsWith("GAMEVAR:")
      ? []
      : [`destroy_count = ${count}`];

  const result: EffectReturn = {
    statement: destroyCode,
    colour: "G.C.RED",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\DestroyRandomJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateDestroyRandomJokerReturn = (
  effect: Effect
): EffectReturn => {
  const amount = effect.params?.amount || 1;
  const amountCode = generateGameVariableCode(amount);
  const customMessage = effect.customMessage;

  const destroyJokerCode = `
            __PRE_RETURN_CODE__
            local jokers_to_destroy = {}
            local deletable_jokers = {}
            
            for _, joker in pairs(G.jokers.cards) do
                if joker.ability.set == 'Joker' and not SMODS.is_eternal(joker, card) then
                    deletable_jokers[#deletable_jokers + 1] = joker
                end
            end
            
            if #deletable_jokers > 0 then
                local temp_jokers = {}
                for _, joker in ipairs(deletable_jokers) do 
                    temp_jokers[#temp_jokers + 1] = joker 
                end
                
                pseudoshuffle(temp_jokers, 98765)
                
                for i = 1, math.min(${amountCode}, #temp_jokers) do
                    jokers_to_destroy[#jokers_to_destroy + 1] = temp_jokers[i]
                end
            end

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))

            local _first_dissolve = nil
            G.E_MANAGER:add_event(Event({
                trigger = 'before',
                delay = 0.75,
                func = function()
                    for _, joker in pairs(jokers_to_destroy) do
                        joker:start_dissolve(nil, _first_dissolve)
                        _first_dissolve = true
                    end
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const configVariables =
    typeof amount === "string" && amount.startsWith("GAMEVAR:")
      ? []
      : [`destroy_joker_amount = ${amount}`];
    
  const result: EffectReturn = {
    statement: destroyJokerCode,
    colour: "G.C.RED",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\DestroySelectedCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateDestroySelectedCardsReturn = (
  effect: Effect
): EffectReturn => {
  const customMessage = effect.customMessage;

  const destroyCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    SMODS.destroy_cards(G.hand.highlighted)
                    return true
                end
            }))
            delay(0.3)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: destroyCode,
    colour: "G.C.RED",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\DoubleDollarsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateDoubleDollarsReturn = (effect: Effect): EffectReturn => {
  const limit = effect.params?.limit || 20;
  const customMessage = effect.customMessage;

  const limitCode = generateGameVariableCode(limit);

  const doubleDollarsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('timpani')
                    used_card:juice_up(0.3, 0.5)
                    local double_amount = math.min(G.GAME.dollars, ${limitCode})
                    ease_dollars(double_amount, true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const configVariables =
    typeof limit === "string" && limit.startsWith("GAMEVAR:")
      ? []
      : [`double_limit = ${limit}`];

  const result: EffectReturn = {
    statement: doubleDollarsCode,
    colour: "G.C.MONEY",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\DrawCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateDrawCardsReturn = (effect: Effect): EffectReturn => {
  const value = effect.params?.value || 1;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  const defaultMessage = customMessage
  ? `"${customMessage}"`
  : `"+"..tostring(${valueCode}).." Cards Drawn"`;
  
  const drawCardsCode = `
      __PRE_RETURN_CODE__
      if G.GAME.blind.in_blind then
        G.E_MANAGER:add_event(Event({
            trigger = 'after',
            delay = 0.4,
            func = function()
                card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                SMODS.draw_cards(${valueCode})
                return true
            end
        }))
        delay(0.6)
      end
      __PRE_RETURN_CODE_END__`;

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`hand_size_value = ${value}`];

  return {
    statement: drawCardsCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditBoosterSlotsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditBoosterSlotsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value || 1;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let boosterSlotsCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Booster Slots"`;
      boosterSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                    SMODS.change_booster_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Booster Slots"`;
      boosterSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    SMODS.change_booster_limit(-${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Booster Slots set to "..tostring(${valueCode})`;
      boosterSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_booster_slots = G.GAME.modifiers.extra_boosters
                    local target_booster_slots = ${valueCode}
                    local difference = target_booster_slots - current_booster_slots
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    SMODS.change_booster_limit(difference)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Booster Slots"`;
      boosterSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                    SMODS.change_booster_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`booster_slots_value = ${value}`];

  return {
    statement: boosterSlotsCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditCardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateEditCardsReturn = (effect: Effect): EffectReturn => {
  const enhancement = effect.params?.enhancement || "none";
  const seal = effect.params?.seal || "none";
  const edition = effect.params?.edition || "none";
  const suit = effect.params?.suit || "none";
  const rank = effect.params?.rank || "none";
  const customMessage = effect.customMessage;

  const hasModifications = [enhancement, seal, edition, suit, rank].some(
    (param) => param !== "none"
  );

  if (!hasModifications) {
    return {
      statement: "",
      colour: "G.C.WHITE",
    };
  }

  let editCardsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.highlighted do
                local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('card1', percent)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.2)`;

  if (enhancement !== "none") {
    if (enhancement === "remove") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_ability(G.P_CENTERS.c_base)
                        return true
                    end
                }))
            end`;
    } else if (enhancement === "random") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local cen_pool = {}
                        for _, enhancement_center in pairs(G.P_CENTER_POOLS["Enhanced"]) do
                            if enhancement_center.key ~= 'm_stone' then
                                cen_pool[#cen_pool + 1] = enhancement_center
                            end
                        end
                        local enhancement = pseudorandom_element(cen_pool, 'random_enhance')
                        G.hand.highlighted[i]:set_ability(enhancement)
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_ability(G.P_CENTERS['${enhancement}'])
                        return true
                    end
                }))
            end`;
    }
  }

  if (seal !== "none") {
    if (seal === "remove") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_seal(nil, nil, true)
                        return true
                    end
                }))
            end`;
    } else if (seal === "random") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local seal_pool = {'Gold', 'Red', 'Blue', 'Purple'}
                        local random_seal = pseudorandom_element(seal_pool, 'random_seal')
                        G.hand.highlighted[i]:set_seal(random_seal, nil, true)
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_seal("${seal}", nil, true)
                        return true
                    end
                }))
            end`;
    }
  }

  if (edition !== "none") {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };

    if (edition === "remove") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_edition(nil, true)
                        return true
                    end
                }))
            end`;
    } else if (edition === "random") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local edition = poll_edition('random_edition', nil, true, true, 
                            { 'e_polychrome', 'e_holo', 'e_foil' })
                        G.hand.highlighted[i]:set_edition(edition, true)
                        return true
                    end
                }))
            end`;
    } else {
      const editionLua =
        editionMap[edition as keyof typeof editionMap] || "foil";
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i]:set_edition({ ${editionLua} = true }, true)
                        return true
                    end
                }))
            end`;
    }
  }

  if (suit !== "none") {
    if (suit === "random") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _suit = pseudorandom_element(SMODS.Suits, 'random_suit')
                        assert(SMODS.change_base(G.hand.highlighted[i], _suit.key))
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        assert(SMODS.change_base(G.hand.highlighted[i], '${suit}'))
                        return true
                    end
                }))
            end`;
    }
  }

  if (rank !== "none") {
    if (rank === "random") {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _rank = pseudorandom_element(SMODS.Ranks, 'random_rank')
                        assert(SMODS.change_base(G.hand.highlighted[i], nil, _rank.key))
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        assert(SMODS.change_base(G.hand.highlighted[i], nil, '${rank}'))
                        return true
                    end
                }))
            end`;
    }
  }

  editCardsCode += `
            for i = 1, #G.hand.highlighted do
                local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    G.hand:unhighlight_all()
                    return true
                end
            }))
            delay(0.5)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: editCardsCode,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\EditCardsInHandEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditCardsInHandReturn = (effect: Effect): EffectReturn => {
  const enhancement = effect.params?.enhancement || "none";
  const seal = effect.params?.seal || "none";
  const edition = effect.params?.edition || "none";
  const suit = effect.params?.suit || "none";
  const rank = effect.params?.rank || "none";
  const amount = generateGameVariableCode(effect.params?.amount ?? 1);
  const customMessage = effect.customMessage;

  // Check if any modifications are actually being made
  const hasModifications = [enhancement, seal, edition, suit, rank].some(
    (param) => param !== "none"
  );

  if (!hasModifications) {
    return {
      statement: "",
      colour: "G.C.WHITE",
    };
  }

  let editCardsCode = `
            local affected_cards = {}
            local temp_hand = {}

            for _, playing_card in ipairs(G.hand.cards) do temp_hand[#temp_hand + 1] = playing_card end
            table.sort(temp_hand,
                function(a, b)
                    return not a.playing_card or not b.playing_card or a.playing_card < b.playing_card
                end
            )

            pseudoshuffle(temp_hand, 12345)

            for i = 1, math.min(card.ability.extra.cards_amount, #temp_hand) do 
                affected_cards[#affected_cards + 1] = temp_hand[i] 
            end

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #affected_cards do
                local percent = 1.15 - (i - 0.999) / (#affected_cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        affected_cards[i]:flip()
                        play_sound('card1', percent)
                        affected_cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.2)`;

  // Apply enhancement if specified
  if (enhancement !== "none") {
    if (enhancement === "random") {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local cen_pool = {}
                        for _, enhancement_center in pairs(G.P_CENTER_POOLS["Enhanced"]) do
                            if enhancement_center.key ~= 'm_stone' then
                                cen_pool[#cen_pool + 1] = enhancement_center
                            end
                        end
                        local enhancement = pseudorandom_element(cen_pool, 'random_enhance')
                        affected_cards[i]:set_ability(enhancement)
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        affected_cards[i]:set_ability(G.P_CENTERS['${enhancement}'])
                        return true
                    end
                }))
            end`;
    }
  }

  // Apply seal if specified
  if (seal !== "none") {
    if (seal === "random") {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local seal_pool = {'Gold', 'Red', 'Blue', 'Purple'}
                        local random_seal = pseudorandom_element(seal_pool, 'random_seal')
                        affected_cards[i]:set_seal(random_seal, nil, true)
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        affected_cards[i]:set_seal("${seal}", nil, true)
                        return true
                    end
                }))
            end`;
    }
  }

  // Apply edition if specified
  if (edition !== "none") {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };

    if (edition === "random") {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local edition = poll_edition('random_edition', nil, true, true, 
                            { 'e_polychrome', 'e_holo', 'e_foil' })
                        affected_cards[i]:set_edition(edition, true)
                        return true
                    end
                }))
            end`;
    } else {
      const editionLua =
        editionMap[edition as keyof typeof editionMap] || "foil";
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        affected_cards[i]:set_edition({ ${editionLua} = true }, true)
                        return true
                    end
                }))
            end`;
    }
  }

  // Apply suit change if specified
  if (suit !== "none") {
    if (suit === "random") {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _suit = pseudorandom_element(SMODS.Suits, 'random_suit')
                        assert(SMODS.change_base(affected_cards[i], _suit.key))
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        assert(SMODS.change_base(affected_cards[i], '${suit}'))
                        return true
                    end
                }))
            end`;
    }
  }

  // Apply rank change if specified
  if (rank !== "none") {
    if (rank === "random") {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        local _rank = pseudorandom_element(SMODS.Ranks, 'random_rank')
                        assert(SMODS.change_base(affected_cards[i], nil, _rank.key))
                        return true
                    end
                }))
            end`;
    } else {
      editCardsCode += `
            for i = 1, #affected_cards do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        assert(SMODS.change_base(affected_cards[i], nil, '${rank}'))
                        return true
                    end
                }))
            end`;
    }
  }

  // Finish the animation sequence
  editCardsCode += `
            for i = 1, #affected_cards do
                local percent = 0.85 + (i - 0.999) / (#affected_cards - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        affected_cards[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        affected_cards[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.5)`;

  const result: EffectReturn = {
    statement: editCardsCode,
    colour: "G.C.SECONDARY_SET.Tarot",
    configVariables: [`cards_amount = ${amount}`],
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\EditDiscardsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditDiscardsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const duration = effect.params?.duration || "permanent";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let discardsCode = "";
  let editDiscardCode = "";

  switch (operation) {
    case "add": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + ${valueCode}
        ease_discard(${valueCode})
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = G.GAME.current_round.discards_left + ${valueCode}`;
      }
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Discard"`;
      discardsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.ORANGE})
                    ${editDiscardCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - ${valueCode}
        ease_discard(-${valueCode})
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = G.GAME.current_round.discards_left - ${valueCode}`;
      }
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Discard"`;
      discardsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    ${editDiscardCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = ${valueCode}
        ease_discard(${valueCode} - G.GAME.current_round.discards_left)
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = ${valueCode}`;
      }
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Discards"`;
      discardsCode = `
            __PRE_RETURN_CODE__
            local mod = ${valueCode} - G.GAME.round_resets.discards
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    ${editDiscardCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`discards_value = ${value}`];

  return {
    statement: discardsCode,
    colour: "G.C.ORANGE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditDiscardSizeEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditDiscardSizeReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let discardSizeCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      discardSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                    SMODS.change_discard_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand Size"`;
      discardSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    SMODS.change_discard_limit(-${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Hand Size set to "..tostring(${valueCode})`;
      discardSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_hand_size = G.hand.config.card_limit
                    local target_hand_size = ${valueCode}
                    local difference = target_hand_size - current_hand_size
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    SMODS.change_discard_limit(difference)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      discardSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                    SMODS.change_discard_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`hand_size_value = ${value}`];

  return {
    statement: discardSizeCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditDollarsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditDollarsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let dollarsCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." $"`;
      dollarsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.MONEY})
                    ease_dollars(${valueCode}, true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." $"`;
      dollarsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    ease_dollars(-math.min(G.GAME.dollars, ${valueCode}), true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to $"..tostring(${valueCode})`;
      dollarsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_dollars = G.GAME.dollars
                    local target_dollars = ${valueCode}
                    local difference = target_dollars - current_dollars
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.MONEY})
                    ease_dollars(difference, true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." $"`;
      dollarsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.MONEY})
                    ease_dollars(${valueCode}, true)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`dollars_value = ${value}`];

  return {
    statement: dollarsCode,
    colour: "G.C.MONEY",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditHandsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditHandsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const duration = effect.params?.duration || "permanent";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let handsCode = "";
  let editHandCode = "";

  switch (operation) {
    case "add": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + ${valueCode}
        ease_hands_played(${valueCode})
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = G.GAME.current_round.hands_left + ${valueCode}`;
      }
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand"`;
      handsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.GREEN})
                    ${editHandCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - ${valueCode}
        ease_hands_played(-${valueCode})
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = G.GAME.current_round.hands_left - ${valueCode}`;
      }
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand"`;
      handsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    ${editHandCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = ${valueCode}
        ease_hands_played(${valueCode} - G.GAME.current_round.hands_left)
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = ${valueCode}`;
      }
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Hands"`;
      handsCode = `
            __PRE_RETURN_CODE__
            local mod = ${valueCode} - G.GAME.round_resets.hands
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    ${editHandCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`hands_value = ${value}`];

  return {
    statement: handsCode,
    colour: "G.C.GREEN",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditHandSizeEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditHandSizeReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let handSizeCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      handSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                    G.hand:change_size(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand Size"`;
      handSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    G.hand:change_size(-${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Hand Size set to "..tostring(${valueCode})`;
      handSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_hand_size = G.hand.config.card_limit
                    local target_hand_size = ${valueCode}
                    local difference = target_hand_size - current_hand_size
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    G.hand:change_size(difference)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      handSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                    G.hand:change_size(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`hand_size_value = ${value}`];

  return {
    statement: handSizeCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditionRandomJokerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateEditionRandomJokerReturn = (
  effect: Effect
): EffectReturn => {
  const amount = effect.params?.amount;
  const edition = effect.params?.edition || "e_foil";
  const targetType = effect.params?.target_type || "editionless";
  const customMessage = effect.customMessage;

  let editionJokerCode = `
            __PRE_RETURN_CODE__
            local jokers_to_edition = {}
            local eligible_jokers = {}
            
            if '${targetType}' == 'editionless' then
                eligible_jokers = SMODS.Edition:get_edition_cards(G.jokers, true)
            else
                for _, joker in pairs(G.jokers.cards) do
                    if joker.ability.set == 'Joker' then
                        eligible_jokers[#eligible_jokers + 1] = joker
                    end
                end
            end
            
            if #eligible_jokers > 0 then
                local temp_jokers = {}
                for _, joker in ipairs(eligible_jokers) do 
                    temp_jokers[#temp_jokers + 1] = joker 
                end
                
                pseudoshuffle(temp_jokers, 76543)
                
                for i = 1, math.min(card.ability.extra.edition_amount, #temp_jokers) do
                    jokers_to_edition[#jokers_to_edition + 1] = temp_jokers[i]
                end
            end

            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('timpani')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))

            for _, joker in pairs(jokers_to_edition) do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.2,
                    func = function()`;

  // Handle different edition types
  if (edition === "random") {
    editionJokerCode += `
                        local edition = poll_edition('edition_random_joker', nil, true, true, 
                            { 'e_polychrome', 'e_holo', 'e_foil' })
                        joker:set_edition(edition, true)`;
  } else if (edition === "remove") {
    editionJokerCode += `
                        joker:set_edition(nil, true)`;
  } else {
    const editionMap: Record<string, string> = {
      e_foil: "foil",
      e_holo: "holo",
      e_polychrome: "polychrome",
      e_negative: "negative",
    };
    const editionLua = editionMap[edition as keyof typeof editionMap] || "foil";
    editionJokerCode += `
                        joker:set_edition({ ${editionLua} = true }, true)`;
  }

  editionJokerCode += `
                        return true
                    end
                }))
            end
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: editionJokerCode,
    colour: "G.C.SECONDARY_SET.Spectral",
    configVariables: [`edition_amount = ${amount}`],
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\EditJokerSlotsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditJokerSlotsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let jokerSlotsCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Joker Slot"`;
      jokerSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                    G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Joker Slot"`;
      jokerSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    G.jokers.config.card_limit = math.max(1, G.jokers.config.card_limit - ${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Joker Slots set to "..tostring(${valueCode})`;
      jokerSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    G.jokers.config.card_limit = ${valueCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Joker Slot"`;
      jokerSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.DARK_EDITION})
                    G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`joker_slots_value = ${value}`];

  return {
    statement: jokerSlotsCode,
    colour: "G.C.DARK_EDITION",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditPlaySizeEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditPlaySizeReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value || 1;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let playSizeCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      playSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                    SMODS.change_play_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand Size"`;
      playSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    SMODS.change_play_limit(-${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Hand Size set to "..tostring(${valueCode})`;
      playSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_hand_size = G.hand.config.card_limit
                    local target_hand_size = ${valueCode}
                    local difference = target_hand_size - current_hand_size
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    SMODS.change_play_limit(difference)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      playSizeCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                    SMODS.change_play_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`hand_size_value = ${value}`];

  return {
    statement: playSizeCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EditVoucherSlotsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditVoucherSlotsReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const value = effect.params?.value || 1;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  let voucherSlotsCode = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Voucher Slots"`;
      voucherSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                    SMODS.change_voucher_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Voucher Slots"`;
      voucherSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                    SMODS.change_voucher_limit(-${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Voucher Slots set to "..tostring(${valueCode})`;
      voucherSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    local current_voucher_slots = G.GAME.modifiers.extra_vouchers
                    local target_voucher_slots = ${valueCode}
                    local difference = target_voucher_slots - current_voucher_slots
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                    SMODS.change_voucher_limit(difference)
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Voucher Slots"`;
      voucherSlotsCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                    SMODS.change_voucher_limit(${valueCode})
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;
    }
  }

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`voucher_slots_value = ${value}`];

  return {
    statement: voucherSlotsCode,
    colour: "G.C.BLUE",
    configVariables,
  };
};

```

### src\components\codeGeneration\Consumables\effects\EmitFlagEffect.ts

```
import { Effect } from "../../../ruleBuilder";
import { EffectReturn } from "../effectUtils";

export const generateEmitFlagReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const flagName = (effect.params?.flag_name as string) || "custom_flag";
  const change = (effect.params?.change as string) || "true";
  const customMessage = effect.customMessage;

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore
  const changeCode = change === "invert" ? `not (G.GAME.pool_flags.${modprefix}_${safeFlagName} or false)` : change

  return {
    statement: `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('timpani')
                    used_card:juice_up(0.3, 0.5)
                    card_eval_status_text(used_card, 'extra', nil, nil, nil, {message = "${customMessage ?? safeFlagName}", colour = G.C.BLUE})
                    G.GAME.pool_flags.${modprefix}_${safeFlagName} = ${changeCode}
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`,
    colour: "G.C.BLUE"
  }
};
```

### src\components\codeGeneration\Consumables\effects\FoolEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateFoolEffectReturn = (effect: Effect): EffectReturn => {
  const customMessage = effect.customMessage;

  const foolEffectCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    if G.consumeables.config.card_limit > #G.consumeables.cards then
                        play_sound('timpani')
                        SMODS.add_card({ key = G.GAME.last_tarot_planet })
                        used_card:juice_up(0.3, 0.5)
                    end
                    return true
                end
            }))
            delay(0.6)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: foolEffectCode,
    colour: "G.C.SECONDARY_SET.Tarot",
    customCanUse:
      "G.consumeables.config.card_limit > #G.consumeables.cards and G.GAME.last_tarot_planet and G.GAME.last_tarot_planet ~= card.config.center.key",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\IncrementRankEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateIncrementRankReturn = (effect: Effect): EffectReturn => {
  const operation = effect.params?.operation || "increment";
  const value = effect.params?.value || 1;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);
  const actualValue = operation === "decrement" ? `-${valueCode}` : `${valueCode}`;

  const incrementRankCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.highlighted do
                local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('card1', percent)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.2)
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        assert(SMODS.modify_rank(G.hand.highlighted[i], ${actualValue}))
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.highlighted do
                local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    G.hand:unhighlight_all()
                    return true
                end
            }))
            delay(0.5)
            __PRE_RETURN_CODE_END__`;

  const result: EffectReturn = {
    statement: incrementRankCode,
    colour: "G.C.SECONDARY_SET.Tarot",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\LevelUpHandEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateLevelUpHandReturn = (effect: Effect): EffectReturn => {
  const handType = effect.params?.hand_type || "Pair";
  const levels = effect.params?.levels || 1;
  const customMessage = effect.customMessage;

  const levelsCode = generateGameVariableCode(levels);

  let levelUpCode = "";

  if (handType === "all") {
    levelUpCode = `
            __PRE_RETURN_CODE__
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },
                { handname = localize('k_all_hands'), chips = '...', mult = '...', level = '' })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = true
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { mult = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { chips = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = nil
                    return true
                end
            }))
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.9, delay = 0 }, { level = '+'..tostring(${levelsCode}) })
            delay(1.3)
            for poker_hand_key, _ in pairs(G.GAME.hands) do
                level_up_hand(card, poker_hand_key, true, ${levelsCode})
            end
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 1.1, delay = 0 },
                { mult = 0, chips = 0, handname = '', level = '' })
            __PRE_RETURN_CODE_END__`;
  } else if (handType === "random") {
    levelUpCode = `
            __PRE_RETURN_CODE__
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },
                { handname = '???', chips = '???', mult = '???', level = '' })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = true
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { mult = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { chips = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = nil
                    return true
                end
            }))
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.9, delay = 0 }, { level = '+'..tostring(${levelsCode}) })
            delay(1.3)
            
            local hand_pool = {}
            for hand_key, _ in pairs(G.GAME.hands) do
                table.insert(hand_pool, hand_key)
            end
            local random_hand = pseudorandom_element(hand_pool, 'random_hand_levelup')
            level_up_hand(card, random_hand, true, ${levelsCode})
            
            update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, 
                {handname=localize(random_hand, 'poker_hands'), 
                 chips = G.GAME.hands[random_hand].chips, 
                 mult = G.GAME.hands[random_hand].mult, 
                 level=G.GAME.hands[random_hand].level})
            delay(1.3)
            __PRE_RETURN_CODE_END__`;
  } else {
    levelUpCode = `
            __PRE_RETURN_CODE__
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },
                { handname = localize('${handType}', 'poker_hands'), 
                  chips = G.GAME.hands['${handType}'].chips, 
                  mult = G.GAME.hands['${handType}'].mult, 
                  level = G.GAME.hands['${handType}'].level })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = true
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { mult = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    return true
                end
            }))
            update_hand_text({ delay = 0 }, { chips = '+', StatusText = true })
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.9,
                func = function()
                    play_sound('tarot1')
                    card:juice_up(0.8, 0.5)
                    G.TAROT_INTERRUPT_PULSE = nil
                    return true
                end
            }))
            update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.9, delay = 0 }, { level = '+'..tostring(${levelsCode}) })
            delay(1.3)
            level_up_hand(card, "${handType}", true, ${levelsCode})
            update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, 
                {handname=localize('${handType}', 'poker_hands'), 
                 chips = G.GAME.hands['${handType}'].chips, 
                 mult = G.GAME.hands['${handType}'].mult, 
                 level=G.GAME.hands['${handType}'].level})
            delay(1.3)
            __PRE_RETURN_CODE_END__`;
  }

  // Only add config variable if it's not a game variable and not "all" or "random"
  const configVariables: string[] = [];
  if (handType !== "random" && handType !== "all") {
    configVariables.push(`hand_type = "${handType}"`);
  }
  if (!(typeof levels === "string" && levels.startsWith("GAMEVAR:"))) {
    configVariables.push(`levels = ${levels}`);
  }

  const result: EffectReturn = {
    statement: levelUpCode,
    colour: "G.C.SECONDARY_SET.Planet",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\PermaBonusEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generatePermaBonusReturn = (effect: Effect): EffectReturn => {
  const bonusType = effect.params?.bonus_type || "perma_bonus";
  const value = effect.params?.value || 10;
  const customMessage = effect.customMessage;

  const valueCode = generateGameVariableCode(value);

  const permaBonusCode = `
            __PRE_RETURN_CODE__
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.4,
                func = function()
                    play_sound('tarot1')
                    used_card:juice_up(0.3, 0.5)
                    return true
                end
            }))
            for i = 1, #G.hand.highlighted do
                local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('card1', percent)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            delay(0.2)
            for i = 1, #G.hand.highlighted do
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.1,
                    func = function()
                        G.hand.highlighted[i].ability.${bonusType} = G.hand.highlighted[i].ability.${bonusType} or 0
                        G.hand.highlighted[i].ability.${bonusType} = G.hand.highlighted[i].ability.${bonusType} + ${valueCode}
                        return true
                    end
                }))
            end
            for i = 1, #G.hand.highlighted do
                local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.15,
                    func = function()
                        G.hand.highlighted[i]:flip()
                        play_sound('tarot2', percent, 0.6)
                        G.hand.highlighted[i]:juice_up(0.3, 0.3)
                        return true
                    end
                }))
            end
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.2,
                func = function()
                    G.hand:unhighlight_all()
                    return true
                end
            }))
            delay(0.5)
            __PRE_RETURN_CODE_END__`;

  const configVariables =
    typeof value === "string" && value.startsWith("GAMEVAR:")
      ? []
      : [`perma_bonus_value = ${value}`];

  const result: EffectReturn = {
    statement: permaBonusCode,
    colour: "G.C.CHIPS",
    configVariables,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Consumables\effects\PlaySoundEffect.ts

```
import { Effect } from "../../../ruleBuilder";
import { EffectReturn } from "../effectUtils";

export const generatePlaySoundReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const key = effect.params.sound_key as string || "";

  const normalizedKey = key.startsWith(modprefix+"_")
    ? key
    : `${modprefix}_${key}`

  const customMessage = effect.customMessage

  return {
    colour: "G.C.BLUE",
    statement: `__PRE_RETURN_CODE__play_sound("${normalizedKey}")
    ${customMessage ? `SMODS.calculate_effect({message = "${customMessage}"}, card)` : ""}
    __PRE_RETURN_CODE_END__`
  }
}
```

### src\components\codeGeneration\Consumables\effects\RedeemVoucherEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateRedeemVoucherReturn = (
  effect: Effect
): EffectReturn => {
  const voucherType = (effect.params?.voucher_type as string) || "random";
  const voucherKey = (effect.params?.specific_voucher as string) || "v_overstock_norm";
  const customMessage = effect.customMessage;

  let voucherCode: string;

  if (voucherType === "random") {
    voucherCode = `local voucher_key = pseudorandom_element(G.P_CENTER_POOLS.Voucher, "${effect.id.substring(0,8)}").key`;
  } else {
    voucherCode = `local voucher_key = "${voucherKey}"`;
  }

  voucherCode += `
    local voucher_card = SMODS.create_card{area = G.play, key = voucher_key}
    voucher_card:start_materialize()
    voucher_card.cost = 0
    G.play:emplace(voucher_card)
    delay(0.8)
    voucher_card:redeem()

    G.E_MANAGER:add_event(Event({
        trigger = 'after',
        delay = 0.5,
        func = function()
            voucher_card:start_dissolve()                
            return true
        end
    }))`;

  return {
    statement: `__PRE_RETURN_CODE__${voucherCode}
              __PRE_RETURN_CODE_END__`,
    message: customMessage
      ? `"${customMessage}"`
      : `nil`,
    colour: "G.C.RED",
  };
};

```

### src\components\codeGeneration\Consumables\effectUtils.ts

```
import type { Effect, LoopGroup, RandomGroup } from "../../ruleBuilder/types";
import { generateLevelUpHandReturn } from "./effects/LevelUpHandEffect";
import { generateDestroySelectedCardsReturn } from "./effects/DestroySelectedCardsEffect";
import { generateDestroyRandomCardsReturn } from "./effects/DestroyRandomCardsEffect";
import { generateDoubleDollarsReturn } from "./effects/DoubleDollarsEffect";
import { generateAddDollarsFromJokersReturn } from "./effects/AddDollarsFromJokersEffect";
import { generateCreateConsumableReturn } from "./effects/CreateConsumableEffect";
import { generateEditHandSizeReturn } from "./effects/EditHandSizeEffect";
import { generateEditHandsReturn } from "./effects/EditHandsEffect";
import { generateEditDiscardsReturn } from "./effects/EditDiscardsEffect";
import { generateConvertAllCardsToSuitReturn } from "./effects/ConvertAllCardsToSuitEffect";
import { generateConvertAllCardsToRankReturn } from "./effects/ConvertAllCardsToRankEffect";
import { generateEditCardsReturn } from "./effects/EditCardsEffect";
import { generateEditCardsInHandReturn } from "./effects/EditCardsInHandEffect";
import { generateCreateJokerReturn } from "./effects/CreateJokerEffect";
import { generateIncrementRankReturn } from "./effects/IncrementRankEffect";
import { generateAddCardsToHandReturn } from "./effects/AddCardsToHandEffect";
import { generateEditDollarsReturn } from "./effects/EditDollarsEffect";
import { generateCopyRandomJokerReturn } from "./effects/CopyRandomJokerEffect";
import { generateDestroyRandomJokerReturn } from "./effects/DestroyRandomJokerEffect";
import { generateEditionRandomJokerReturn } from "./effects/EditionRandomJokerEffect";
import { generateCopySelectedCardsReturn } from "./effects/CopySelectedCardsEffect";
import { generateConvertLeftToRightReturn } from "./effects/ConvertLeftToRightEffect";
import { generateFoolEffectReturn } from "./effects/FoolEffect";
import { generateDrawCardsReturn } from "./effects/DrawCardsEffect";
import { generateEditPlaySizeReturn } from "./effects/EditPlaySizeEffect";
import { generateEditDiscardSizeReturn } from "./effects/EditDiscardSizeEffect";
import { generateEditBoosterSlotsReturn } from "./effects/EditBoosterSlotsEffect";
import { generateEditVoucherSlotsReturn } from "./effects/EditVoucherSlotsEffect";
import { generateCreateTagReturn } from "./effects/CreateTagEffect";
import { generatePermaBonusReturn } from "./effects/PermaBonusEffect";
import { generateEditJokerSlotsReturn } from "./effects/EditJokerSlotsEffect";
import { generateDestroyConsumableReturn } from "./effects/DestroyConsumableEffect";
import { generateRedeemVoucherReturn } from "./effects/RedeemVoucherEffect";
import { generateEmitFlagReturn } from "./effects/EmitFlagEffect";
import { generatePlaySoundReturn } from "./effects/PlaySoundEffect";

export interface EffectReturn {
  statement: string;
  message?: string;
  colour: string;
  configVariables?: string[];
  customCanUse?: string;
}

export interface ReturnStatementResult {
  statement: string;
  colour: string;
  preReturnCode?: string;
  isRandomChance?: boolean;
  configVariables?: string[];
  customCanUse?: string;
}

export function generateEffectReturnStatement(
  regularEffects: Effect[] = [],
  randomGroups: RandomGroup[] = [],
  loopGroups: LoopGroup[] = [],
  modprefix: string,
  consumableKey?: string
): ReturnStatementResult {
  if (regularEffects.length === 0 && randomGroups.length === 0 && loopGroups.length === 0) {
    return {
      statement: "",
      colour: "G.C.WHITE",
      configVariables: [],
    };
  }

  let combinedPreReturnCode = "";
  let mainReturnStatement = "";
  let primaryColour = "G.C.WHITE";
  const customCanUseConditions: string[] = [];
  const allConfigVariables: string[] = [];
  const configVariableSet = new Set<string>();

  if (regularEffects.length > 0) {
    const effectReturns: EffectReturn[] = regularEffects
      .map((effect) => generateSingleEffect(effect, modprefix))
      .filter((ret) => ret.statement || ret.message);

    effectReturns.forEach((effectReturn) => {
      if (effectReturn.configVariables) {
        effectReturn.configVariables.forEach((configVar) => {
          if (!configVariableSet.has(configVar)) {
            configVariableSet.add(configVar);
            allConfigVariables.push(configVar);
          }
        });
      }
      if (effectReturn.customCanUse) {
        customCanUseConditions.push(effectReturn.customCanUse);
      }
    });

    const processedEffects: EffectReturn[] = [];
    effectReturns.forEach((effect) => {
      const { cleanedStatement, preReturnCode } = extractPreReturnCode(
        effect.statement
      );

      if (preReturnCode) {
        combinedPreReturnCode +=
          (combinedPreReturnCode ? "\n            " : "") + preReturnCode;
      }

      processedEffects.push({
        ...effect,
        statement: cleanedStatement,
      });
    });

    if (processedEffects.length > 0) {
      mainReturnStatement = buildConsumableEffectCode(processedEffects);
      primaryColour = processedEffects[0]?.colour ?? "G.C.WHITE";
    }
  }

  if (randomGroups.length > 0) {
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator as number)),
    ];
    const denominatorToOddsVar: Record<number, string> = {};

    if (denominators.length === 1) {
      denominatorToOddsVar[denominators[0]] = "card.ability.extra.odds";
      const oddsVar = "odds = " + denominators[0];
      if (!configVariableSet.has(oddsVar)) {
        configVariableSet.add(oddsVar);
        allConfigVariables.push(oddsVar);
      }
    } else {
      denominators.forEach((denom, index) => {
        if (index === 0) {
          denominatorToOddsVar[denom] = "card.ability.extra.odds";
          const oddsVar = "odds = " + denom;
          if (!configVariableSet.has(oddsVar)) {
            configVariableSet.add(oddsVar);
            allConfigVariables.push(oddsVar);
          }
        } else {
          denominatorToOddsVar[denom] = `card.ability.extra.odds${index + 1}`;
          const oddsVar = `odds${index + 1} = ${denom}`;
          if (!configVariableSet.has(oddsVar)) {
            configVariableSet.add(oddsVar);
            allConfigVariables.push(oddsVar);
          }
        }
      });
    }

    randomGroups.forEach((group, groupIndex) => {
      const effectReturns: EffectReturn[] = group.effects
        .map((effect) => generateSingleEffect(effect, modprefix))
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          effectReturn.configVariables.forEach((configVar) => {
            if (!configVariableSet.has(configVar)) {
              configVariableSet.add(configVar);
              allConfigVariables.push(configVar);
            }
          });
        }
        if (effectReturn.customCanUse) {
          customCanUseConditions.push(effectReturn.customCanUse);
        }
      });

      if (effectReturns.length === 0) return;

      const oddsVar = denominatorToOddsVar[group.chance_denominator as number];
      const probabilityIdentifier = `group_${groupIndex}_${group.id.substring(
        0,
        8
      )}`;

      let groupContent = "";
      let groupPreReturnCode = "";

      effectReturns.forEach((effect) => {
        if (effect.statement && effect.statement.trim()) {
          const { cleanedStatement, preReturnCode } = extractPreReturnCode(
            effect.statement
          );

          if (preReturnCode) {
            groupPreReturnCode +=
              (groupPreReturnCode ? "\n                " : "") + preReturnCode;
          }

          if (cleanedStatement.trim()) {
            groupContent += `
                ${cleanedStatement}`;
          }
        }
      });

      let fullGroupContent = groupContent;
      if (groupPreReturnCode) {
        fullGroupContent = `
                ${groupPreReturnCode}${groupContent}`;
      }

      const probabilityStatement = `SMODS.pseudorandom_probability(card, '${probabilityIdentifier}', ${group.chance_numerator}, ${oddsVar}, '${group.custom_key || `c_${modprefix}_${consumableKey}`}', ${group.respect_probability_effects === false})`
      
      const groupStatement = `if ${probabilityStatement} then
                ${fullGroupContent}
            end`;

      combinedPreReturnCode +=
        (combinedPreReturnCode ? "\n            " : "") + groupStatement;
    });
  }
  
  if (loopGroups.length > 0) {
    const repetitions = [
      ...new Set(loopGroups.map((group) => group.repetitions as number)),
    ];
    const repetitionsToVar: Record<number, string> = {};

    if (repetitions.length === 1) {
      repetitionsToVar[repetitions[0]] = "card.ability.extra.repetitions";
      const repetitionsVar = "repetitions = " + repetitions[0];
      if (!(typeof repetitions[0] === "string") && !configVariableSet.has(repetitionsVar)) {
        configVariableSet.add(repetitionsVar);
        allConfigVariables.push(repetitionsVar);
      }
    } else {
      repetitions.forEach((denom, index) => {
        if (index === 0) {
          repetitionsToVar[denom] = "card.ability.extra.repetitions";
          const repetitionsVar = "repetitions = " + denom;
          if (!(typeof denom === "string") && !configVariableSet.has(repetitionsVar)) {
            configVariableSet.add(repetitionsVar);
            allConfigVariables.push(repetitionsVar);
          }
        } else {
          repetitionsToVar[denom] = `card.ability.extra.repetitions${index + 1}`;
          const repetitionsVar = `repetitions${index + 1} = ${denom}`;
          if (!(typeof denom === "string") && !configVariableSet.has(repetitionsVar)) {
            configVariableSet.add(repetitionsVar);
            allConfigVariables.push(repetitionsVar);
          }
        }
      });
    }

    loopGroups.forEach((group) => {
      const effectReturns: EffectReturn[] = group.effects
        .map((effect) => generateSingleEffect(effect, modprefix))
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          effectReturn.configVariables.forEach((configVar) => {
            if (!configVariableSet.has(configVar)) {
              configVariableSet.add(configVar);
              allConfigVariables.push(configVar);
            }
          });
        }
        if (effectReturn.customCanUse) {
          customCanUseConditions.push(effectReturn.customCanUse);
        }
      });

      if (effectReturns.length === 0) return;

      const repetitionsVar = typeof group.repetitions === "string" ? group.repetitions : repetitionsToVar[group.repetitions as number];

      let groupContent = "";
      let groupPreReturnCode = "";

      effectReturns.forEach((effect) => {
        if (effect.statement && effect.statement.trim()) {
          const { cleanedStatement, preReturnCode } = extractPreReturnCode(
            effect.statement
          );

          if (preReturnCode) {
            groupPreReturnCode +=
              (groupPreReturnCode ? "\n                " : "") + preReturnCode;
          }

          if (cleanedStatement.trim()) {
            groupContent += `
                ${cleanedStatement}`;
          }
        }
      });

      let fullGroupContent = groupContent;
      if (groupPreReturnCode) {
        fullGroupContent = `
                ${groupPreReturnCode}${groupContent}`;
      }

      const loopStatement =  `for i = 1, ${repetitionsVar} do`;
      
      const groupStatement = `${loopStatement}
              ${fullGroupContent}
          end`;

      combinedPreReturnCode +=
        (combinedPreReturnCode ? "\n            " : "") + groupStatement;
    });
  }

  return {
    statement: mainReturnStatement,
    colour: primaryColour,
    preReturnCode: combinedPreReturnCode || undefined,
    isRandomChance: randomGroups.length > 0,
    configVariables: allConfigVariables,
    customCanUse:
      customCanUseConditions.length > 0
        ? customCanUseConditions.join(" and ")
        : undefined,
  };
}

const generateSingleEffect = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  switch (effect.type) {
    case "edit_cards":
      return generateEditCardsReturn(effect);

    case "double_dollars":
      return generateDoubleDollarsReturn(effect);

    case "edit_dollars":
      return generateEditDollarsReturn(effect);

    case "add_dollars_from_jokers":
      return generateAddDollarsFromJokersReturn(effect);

    case "create_consumable":
      return generateCreateConsumableReturn(effect);

    case "level_up_hand":
      return generateLevelUpHandReturn(effect);

    case "destroy_selected_cards":
      return generateDestroySelectedCardsReturn(effect);

    case "destroy_random_cards":
      return generateDestroyRandomCardsReturn(effect);

    case "edit_hand_size":
      return generateEditHandSizeReturn(effect);

    case "draw_cards":
      return generateDrawCardsReturn(effect);

    case "edit_hands":
      return generateEditHandsReturn(effect);

    case "edit_discards":
      return generateEditDiscardsReturn(effect);

    case "convert_all_cards_to_suit":
      return generateConvertAllCardsToSuitReturn(effect);

    case "convert_all_cards_to_rank":
      return generateConvertAllCardsToRankReturn(effect);

    case "edit_cards_in_hand":
      return generateEditCardsInHandReturn(effect);

    case "create_joker":
      return generateCreateJokerReturn(effect, modprefix);

    case "increment_rank":
      return generateIncrementRankReturn(effect);

    case "add_cards_to_hand":
      return generateAddCardsToHandReturn(effect);

    case "copy_random_joker":
      return generateCopyRandomJokerReturn(effect);

    case "destroy_random_joker":
      return generateDestroyRandomJokerReturn(effect);

    case "edition_random_joker":
      return generateEditionRandomJokerReturn(effect);

    case "copy_selected_cards":
      return generateCopySelectedCardsReturn(effect);

    case "convert_left_to_right":
      return generateConvertLeftToRightReturn(effect);

    case "fool_effect":
      return generateFoolEffectReturn(effect);

    case "edit_play_size":
      return generateEditPlaySizeReturn(effect);

    case "edit_discard_size":
      return generateEditDiscardSizeReturn(effect);

    case "edit_booster_slots":
      return generateEditBoosterSlotsReturn(effect);

    case "edit_voucher_slots":
      return generateEditVoucherSlotsReturn(effect);

    case "create_tag":
      return generateCreateTagReturn(effect);

    case "perma_bonus":
      return generatePermaBonusReturn(effect);

    case "edit_joker_slots":
      return generateEditJokerSlotsReturn(effect);

    case "destroy_consumable":
      return generateDestroyConsumableReturn(effect);

    case "redeem_voucher":
      return generateRedeemVoucherReturn(effect);
    
    case "emit_flag":
      return generateEmitFlagReturn(effect, modprefix);
          
    case "play_sound":
      return generatePlaySoundReturn(effect, modprefix);

    default:
      return {
        statement: "",
        colour: "G.C.WHITE",
      };
  }
};

const buildConsumableEffectCode = (effects: EffectReturn[]): string => {
  if (effects.length === 0) return "";

  let effectCode = "";
  effects.forEach((effect) => {
    if (effect.statement.trim()) {
      effectCode += `
            ${effect.statement}`;
    }
  });

  return effectCode.trim();
};

function extractPreReturnCode(statement: string): {
  cleanedStatement: string;
  preReturnCode?: string;
} {
  const preReturnStart = "__PRE_RETURN_CODE__";
  const preReturnEnd = "__PRE_RETURN_CODE_END__";

  if (statement.includes(preReturnStart) && statement.includes(preReturnEnd)) {
    const startIndex =
      statement.indexOf(preReturnStart) + preReturnStart.length;
    const endIndex = statement.indexOf(preReturnEnd);

    if (startIndex < endIndex) {
      const preReturnCode = statement.substring(startIndex, endIndex).trim();
      const cleanedStatement = statement
        .replace(
          new RegExp(`${preReturnStart}[\\s\\S]*?${preReturnEnd}`, "g"),
          ""
        )
        .trim();

      return { cleanedStatement, preReturnCode };
    }
  }

  return { cleanedStatement: statement };
}

```

### src\components\codeGeneration\Consumables\gameVariableUtils.ts

```
import { getGameVariableById } from "../../data/Jokers/GameVars";
import type { Rule } from "../../ruleBuilder/types";

export interface ParsedGameVariable {
  isGameVariable: boolean;
  gameVariableId?: string;
  multiplier?: number;
  startsFrom?: number;
  code?: string;
}

export interface GameVariableConfig {
  name: string;
  code: string;
  startsFrom: number;
  multiplier: number;
}

export const parseGameVariable = (value: unknown): ParsedGameVariable => {
  if (typeof value === "string" && value.startsWith("GAMEVAR:")) {
    const parts = value.replace("GAMEVAR:", "").split("|");
    const gameVariableId = parts[0];
    const multiplier = parseFloat(parts[1] || "1");
    const startsFrom = parseFloat(parts[2] || "0");
    const gameVariable = getGameVariableById(gameVariableId);

    return {
      isGameVariable: true,
      gameVariableId,
      multiplier,
      startsFrom,
      code: gameVariable?.code,
    };
  }

  return {
    isGameVariable: false,
  };
};

export const generateGameVariableCode = (value: unknown): string => {
  const parsed = parseGameVariable(value);

  if (
    parsed.isGameVariable &&
    parsed.code &&
    parsed.multiplier !== undefined &&
    parsed.startsFrom !== undefined
  ) {
    const gameVariable = getGameVariableById(parsed.gameVariableId!);
    const configVarName = gameVariable?.label
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();

    if (parsed.multiplier === 1 && parsed.startsFrom === 0) {
      return parsed.code;
    } else if (parsed.startsFrom === 0) {
      return `(${parsed.code}) * ${parsed.multiplier}`;
    } else if (parsed.multiplier === 1) {
      return `card.ability.extra.${configVarName} + (${parsed.code})`;
    } else {
      return `card.ability.extra.${configVarName} + (${parsed.code}) * ${parsed.multiplier}`;
    }
  }

  if (typeof value === "string") {
    return `card.ability.extra.${value}`;
  }

  return typeof value === "number" ? value.toString() : "0";
};

export const extractGameVariablesFromRules = (
  rules: Rule[]
): GameVariableConfig[] => {
  const gameVariables = new Map<string, GameVariableConfig>();

  const extractFromValue = (value: unknown) => {
    const parsed = parseGameVariable(value);
    if (parsed.isGameVariable && parsed.gameVariableId && parsed.code) {
      const gameVariable = getGameVariableById(parsed.gameVariableId);
      if (gameVariable) {
        const configName = gameVariable.label.replace(/\s+/g, "").toLowerCase();
        gameVariables.set(configName, {
          name: configName,
          code: parsed.code,
          startsFrom: parsed.startsFrom || 0,
          multiplier: parsed.multiplier || 1,
        });
      }
    }
  };

  const extractFromObject = (obj: unknown) => {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      Object.values(obj as Record<string, unknown>).forEach((value) => {
        extractFromValue(value);
        if (value && typeof value === "object" && !Array.isArray(value)) {
          extractFromObject(value);
        }
      });
    }
  };

  rules.forEach((rule) => {
    // Extract from conditions
    rule.conditionGroups?.forEach((group) => {
      group.conditions?.forEach((condition) => {
        extractFromObject(condition.params);
      });
    });

    // Extract from effects
    rule.effects?.forEach((effect) => {
      extractFromObject(effect.params);
    });

    // Extract from random groups
    rule.randomGroups?.forEach((group) => {
      group.effects?.forEach((effect) => {
        extractFromObject(effect.params);
      });
    });
  });

  return Array.from(gameVariables.values());
};

```

### src\components\codeGeneration\Consumables\index.ts

```
import { ConsumableData } from "../../data/BalatroUtils";
import { ConsumableSetData } from "../../data/BalatroUtils";
import { generateConditionChain } from "./conditionUtils";
import { generateEffectReturnStatement } from "./effectUtils";
import { slugify } from "../../data/BalatroUtils";
import { extractGameVariablesFromRules, parseGameVariable } from "./gameVariableUtils";
import type { Rule } from "../../ruleBuilder/types";
import { generateGameVariableCode } from "./gameVariableUtils";
import { parseRangeVariable } from "../Jokers/gameVariableUtils";

interface ConsumableGenerationOptions {
  modPrefix?: string;
  atlasKey?: string;
  consumableSets?: ConsumableSetData[];
}

const ensureConsumableKeys = (
  consumables: ConsumableData[]
): ConsumableData[] => {
  return consumables.map((consumable) => ({
    ...consumable,
    consumableKey: consumable.consumableKey || slugify(consumable.name),
  }));
};

const convertRandomGroupsForCodegen = (
  randomGroups: import("../../ruleBuilder/types").RandomGroup[]
) => {
  return randomGroups.map((group) => ({
    ...group,
    chance_numerator:
      typeof group.chance_numerator === "string"
      ? generateGameVariableCode(group.chance_numerator)
      : group.chance_numerator,
    chance_denominator:
      typeof group.chance_denominator === "string"
        ? generateGameVariableCode(group.chance_denominator)
        : group.chance_denominator,
  }));
};

const convertLoopGroupsForCodegen = (
  loopGroups: import("../../ruleBuilder/types").LoopGroup[]
) => {
  return loopGroups.map((group) => ({
    ...group,
    repetitions:
      typeof group.repetitions === "string"
        ? (() => {
          const parsed = parseGameVariable(group.repetitions);
          const rangeParsed = parseRangeVariable(group.repetitions);
          if (parsed.isGameVariable) {
            return generateGameVariableCode(group.repetitions);
          } else if (rangeParsed.isRangeVariable) {
            const seedName = `repetitions_${group.id.substring(0, 8)}`;
            return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
          } else {
            return `card.ability.extra.${group.repetitions}`
          }
        })()
        : group.repetitions,
  }));
};

export const generateConsumablesCode = (
  consumables: ConsumableData[],
  options: ConsumableGenerationOptions = {}
): { consumablesCode: Record<string, string> } => {
  const { atlasKey = "CustomConsumables", consumableSets = [] } = options;

  const modPrefix = options.modPrefix || "";
  const consumablesWithKeys = ensureConsumableKeys(consumables);
  const consumablesCode: Record<string, string> = {};
  let currentPosition = 0;

  if (consumableSets.length > 0) {
    const setsCode = generateConsumableSetsCode(
      consumableSets,
      consumablesWithKeys,
      modPrefix
    );
    if (setsCode.trim()) {
      consumablesCode["sets.lua"] = setsCode;
    }
  }

  consumablesWithKeys.forEach((consumable) => {
    const result = generateSingleConsumableCode(
      consumable,
      atlasKey,
      currentPosition,
      modPrefix
    );
    consumablesCode[`${consumable.consumableKey}.lua`] = result.code;
    currentPosition = result.nextPosition;
  });

  return { consumablesCode };
};

const generateConsumableSetsCode = (
  consumableSets: ConsumableSetData[],
  consumables: ConsumableData[],
  modPrefix: string = ""
): string => {
  let setsCode = "";

  consumableSets.forEach((set, index) => {
    if (index > 0) {
      setsCode += "\n\n";
    }

    const setConsumables = consumables.filter(
      (consumable) => consumable.set === set.key
    );

    let cardsArray = "";
    if (setConsumables.length > 0) {
      const cardEntries = setConsumables.map((consumable) => {
        const prefix = modPrefix ? `${modPrefix}_` : "";
        return `        ['c_${prefix}${consumable.consumableKey}'] = true`;
      });
      cardsArray = `    cards = {
${cardEntries.join(",\n")}
    },`;
    } else {
      cardsArray = `    cards = {},`;
    }

    setsCode += `SMODS.ConsumableType {
    key = '${set.key}',`;

    const primaryColor = set.primary_colour.startsWith("#")
      ? set.primary_colour.substring(1)
      : set.primary_colour;
    const secondaryColor = set.secondary_colour.startsWith("#")
      ? set.secondary_colour.substring(1)
      : set.secondary_colour;

    setsCode += `
    primary_colour = HEX('${primaryColor}'),
    secondary_colour = HEX('${secondaryColor}'),
    collection_rows = { ${set.collection_rows[0]}, ${set.collection_rows[1]} },`;

    if (set.default_card) {
      setsCode += `
    default = '${set.default_card}',`;
    }

    if (set.shop_rate !== undefined) {
      setsCode += `
    shop_rate = ${set.shop_rate},`;
    }

    setsCode += `
${cardsArray}
    loc_txt = {
        name = "${set.name}",
        collection = "${set.collection_name || set.name + " Cards"}",
    }
}`;
  });

  return setsCode;
};

const generateSingleConsumableCode = (
  consumable: ConsumableData,
  atlasKey: string,
  currentPosition: number,
  modPrefix: string
): { code: string; nextPosition: number } => {
  const activeRules =
    consumable.rules?.filter((rule) => rule.trigger !== "passive") || [];

  const configItems: string[] = [];

  const gameVariables = extractGameVariablesFromRules(activeRules);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  activeRules.forEach((rule) => {
    const regularEffects = rule.effects || [];
    const randomGroups = convertRandomGroupsForCodegen(rule.randomGroups || []);
    const loopGroups = convertLoopGroupsForCodegen(rule.loops || []);

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      consumable.consumableKey
    );

    if (effectResult.configVariables) {
      configItems.push(...effectResult.configVariables);
    }
  });

  const effectsConfig = configItems.join(",\n        ");

  const consumablesPerRow = 10;
  const col = currentPosition % consumablesPerRow;
  const row = Math.floor(currentPosition / consumablesPerRow);

  let nextPosition = currentPosition + 1;

  let consumableCode = `SMODS.Consumable {
    key = '${consumable.consumableKey}',
    set = '${consumable.set}',
    pos = { x = ${col}, y = ${row} },`;

  if (effectsConfig.trim()) {
    consumableCode += `
    config = { extra = {
        ${effectsConfig}
    } },`;
  }

  consumableCode += `
    loc_txt = {
        name = '${consumable.name}',
        text = ${formatConsumableDescription(consumable)}
    },`;

  if (consumable.cost !== undefined) {
    consumableCode += `
    cost = ${consumable.cost},`;
  }

  if (consumable.unlocked !== undefined) {
    consumableCode += `
    unlocked = ${consumable.unlocked},`;
  }

  if (consumable.discovered !== undefined) {
    consumableCode += `
    discovered = ${consumable.discovered},`;
  }

  if (consumable.hidden !== undefined) {
    consumableCode += `
    hidden = ${consumable.hidden},`;
  }

  if (consumable.can_repeat_soul !== undefined) {
    consumableCode += `
    can_repeat_soul = ${consumable.can_repeat_soul},`;
  }

  consumableCode += `
    atlas = '${atlasKey}',`;

  if (consumable.overlayImagePreview) {
    const soulCol = nextPosition % consumablesPerRow;
    const soulRow = Math.floor(nextPosition / consumablesPerRow);

    consumableCode += `
    soul_pos = {
        x = ${soulCol},
        y = ${soulRow}
    },`;

    nextPosition++;
  }

  const locVarsCode = generateLocVarsFunction(
    consumable,
    gameVariables,
    modPrefix
  );
  if (locVarsCode) {
    consumableCode += `
    ${locVarsCode},`;
  }

  const useCode = generateUseFunction(activeRules, modPrefix, consumable.consumableKey);
  if (useCode) {
    consumableCode += `
    ${useCode},`;
  }

  const canUseCode = generateCanUseFunction(activeRules, modPrefix);
  if (canUseCode) {
    consumableCode += `
    ${canUseCode},`;
  }

  consumableCode = consumableCode.replace(/,$/, "");
  consumableCode += `
}`;

  return {
    code: consumableCode,
    nextPosition,
  };
};

export const exportSingleConsumable = (consumable: ConsumableData): void => {
  try {
    const consumableWithKey = consumable.consumableKey
      ? consumable
      : { ...consumable, consumableKey: slugify(consumable.name) };

    const result = generateSingleConsumableCode(
      consumableWithKey,
      "Consumable",
      0,
      "modprefix"
    );
    const jokerCode = result.code;

    const blob = new Blob([jokerCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${consumableWithKey.consumableKey}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export consumable:", error);
    throw error;
  }
};

const generateUseFunction = (
  rules: Rule[],
  modPrefix: string,
  consumableKey?: string,
): string => {
  if (rules.length === 0) {
    return `use = function(self, card, area, copier)
        
    end`;
  }

  let useFunction = `use = function(self, card, area, copier)
        local used_card = copier or card`;

  rules.forEach((rule) => {
    const conditionCode = generateConditionChain(rule);

    let ruleCode = "";
    if (conditionCode) {
      ruleCode += `
        if ${conditionCode} then`;
    }

    const regularEffects = rule.effects || [];
    const randomGroups = convertRandomGroupsForCodegen(rule.randomGroups || []);
    const loopGroups = convertLoopGroupsForCodegen(rule.loops || []);

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix,
      consumableKey
    );

    if (effectResult.preReturnCode) {
      ruleCode += `
            ${effectResult.preReturnCode}`;
    }

    if (effectResult.statement) {
      ruleCode += `
            ${effectResult.statement}`;
    }

    if (conditionCode) {
      ruleCode += `
        end`;
    }

    useFunction += ruleCode;
  });

  useFunction += `
    end`;

  return useFunction;
};

const generateCanUseFunction = (rules: Rule[], modPrefix: string): string => {
  if (rules.length === 0) {
    return `can_use = function(self, card)
        return true
    end`;
  }

  const ruleConditions: string[] = [];
  const customCanUseConditions: string[] = [];

  rules.forEach((rule) => {
    const conditionCode = generateConditionChain(rule);
    if (conditionCode) {
      ruleConditions.push(`(${conditionCode})`);
    }

    const regularEffects = rule.effects || [];
    const randomGroups = convertRandomGroupsForCodegen(rule.randomGroups || []);
    const loopGroups = convertLoopGroupsForCodegen(rule.loops || []);

    const effectResult = generateEffectReturnStatement(
      regularEffects,
      randomGroups,
      loopGroups,
      modPrefix
    );

    if (effectResult.customCanUse) {
      customCanUseConditions.push(`(${effectResult.customCanUse})`);
    }
  });

  if (ruleConditions.length === 0 && customCanUseConditions.length === 0) {
    return `can_use = function(self, card)
        return true
    end`;
  }

  let combinedCondition = "";

  if (ruleConditions.length > 0) {
    combinedCondition = ruleConditions.join(" or ");
  }

  if (customCanUseConditions.length > 0) {
    const customCondition = customCanUseConditions.join(" and ");
    if (combinedCondition) {
      combinedCondition = `(${combinedCondition}) and (${customCondition})`;
    } else {
      combinedCondition = customCondition;
    }
  }

  return `can_use = function(self, card)
        return ${combinedCondition}
    end`;
};

const generateLocVarsFunction = (
  consumable: ConsumableData,
  gameVariables: Array<{
    name: string;
    code: string;
    startsFrom: number;
    multiplier: number;
  }>,
  modPrefix: string
): string | null => {
  const descriptionHasVariables = consumable.description.includes("#");
  if (!descriptionHasVariables) {
    return null;
  }

  const variablePlaceholders = consumable.description.match(/#(\d+)#/g) || [];
  const maxVariableIndex = Math.max(
    ...variablePlaceholders.map((placeholder) =>
      parseInt(placeholder.replace(/#/g, ""))
    ),
    0
  );

  if (maxVariableIndex === 0) {
    return null;
  }

  const activeRules =
    consumable.rules?.filter((rule) => rule.trigger !== "passive") || [];
  const hasRandomGroups = activeRules.some(
    (rule) => rule.randomGroups && rule.randomGroups.length > 0
  );

  const wrapGameVariableCode = (code: string): string => {
    if (code.includes("G.jokers.cards")) {
      return code.replace(
        "G.jokers.cards",
        "(G.jokers and G.jokers.cards or {})"
      );
    }
    if (code.includes("#G.jokers.cards")) {
      return code.replace(
        "#G.jokers.cards",
        "(G.jokers and G.jokers.cards and #G.jokers.cards or 0)"
      );
    }
    if (code.includes("#G.hand.cards")) {
      return code.replace(
        "#G.hand.cards",
        "(G.hand and G.hand.cards and #G.hand.cards or 0)"
      );
    }
    if (code.includes("#G.deck.cards")) {
      return code.replace(
        "#G.deck.cards",
        "(G.deck and G.deck.cards and #G.deck.cards or 0)"
      );
    }
    if (code.includes("#G.consumeables.cards")) {
      return code.replace(
        "#G.consumeables.cards",
        "(G.consumeables and G.consumeables.cards and #G.consumeables.cards or 0)"
      );
    }
    if (
      code.includes("G.GAME") ||
      code.includes("G.jokers") ||
      code.includes("G.hand") ||
      code.includes("G.deck") ||
      code.includes("G.consumeables")
    ) {
      return `(${code} or 0)`;
    }
    return code;
  };

  const variableMapping: string[] = [];

  gameVariables.forEach((gameVar) => {
    if (variableMapping.length >= maxVariableIndex) return;

    let gameVarCode: string;
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
      gameVarCode = wrapGameVariableCode(gameVar.code);
    } else if (gameVar.startsFrom === 0) {
      gameVarCode = `(${wrapGameVariableCode(gameVar.code)}) * ${
        gameVar.multiplier
      }`;
    } else if (gameVar.multiplier === 1) {
      gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
        gameVar.code
      )})`;
    } else {
      gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
        gameVar.code
      )}) * ${gameVar.multiplier}`;
    }

    variableMapping.push(gameVarCode);
  });

  if (hasRandomGroups) {
    const randomGroups = activeRules.flatMap((rule) => rule.randomGroups || []);
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator)),
    ];

    if (denominators.length === 1) {
      return `loc_vars = function(self, info_queue, card)
        local numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'c_${modPrefix}_${
        consumable.consumableKey
      }')
        return {vars = {${variableMapping.join(", ")}${
        variableMapping.length > 0 ? ", " : ""
      }numerator, denominator}}
    end`;
    } else {
      const probabilityVars: string[] = [];
      denominators.forEach((index) => {
        const varName =
          index === 0
            ? "card.ability.extra.odds"
            : `card.ability.extra.odds${Number(index) + 1}`;
        probabilityVars.push(varName);
      });

      return `loc_vars = function(self, info_queue, card)
        return {vars = {${[...variableMapping, ...probabilityVars]
          .slice(0, maxVariableIndex)
          .join(", ")}}}
    end`;
    }
  }

  const finalVars = variableMapping.slice(0, maxVariableIndex);

  return `loc_vars = function(self, info_queue, card)
        return {vars = {${finalVars.join(", ")}}}
    end`;
};

const formatConsumableDescription = (consumable: ConsumableData): string => {
  const formatted = consumable.description.replace(/<br\s*\/?>/gi, "[s]");

  const escaped = formatted.replace(/\n/g, "[s]");
  const lines = escaped.split("[s]").map((line) => line.trim());

  if (lines.length === 0) {
    lines.push(escaped.trim());
  }

  return `{
${lines
  .map(
    (line, i) =>
      `        [${i + 1}] = '${line
        .replace(/\\/g, "\\\\")
        .replace(/"/g, '\\"')
        .replace(/'/g, "\\'")}'`
  )
  .join(",\n")}
    }`;
};

```

### src\components\codeGeneration\entry.ts

```
import JSZip from "jszip";
import {
  JokerData,
  BoosterData,
  RarityData,
  ConsumableData,
  EnhancementData,
  SealData,
  ModMetadata,
  EditionData,
  isCustomShader,
  getCustomShaderFilepath,
  SoundData,
} from "../data/BalatroUtils";
import { addAtlasToZip } from "./ImageProcessor";
import { generateJokersCode, generateCustomRaritiesCode } from "./Jokers/index";
import { generateConsumablesCode } from "./Consumables/index";
import { generateBoostersCode } from "./boosters";
import { ConsumableSetData, slugify, getModPrefix } from "../data/BalatroUtils";
import { modToJson } from "../JSONImportExport";
import {
  generateEnhancementsCode,
  generateSealsCode,
  generateEditionsCode,
} from "./Card/index";

const sortForExport = <T extends { id: string; name: string }>(
  items: T[]
): T[] => {
  return [...items].sort((a, b) => {
    const nameA = a.name || "";
    const nameB = b.name || "";
    const idA = a.id || "";
    const idB = b.id || "";

    const nameComparison = nameA.localeCompare(nameB);
    if (nameComparison !== 0) return nameComparison;
    return idA.localeCompare(idB);
  });
};

const collectJokerPools = (jokers: JokerData[]): Record<string, string[]> => {
  const poolsMap: Record<string, string[]> = {};

  // Vanilla food jokers to include in food pool
  const vanillaFoodJokers = [
    "j_gros_michel",
    "j_egg",
    "j_ice_cream",
    "j_cavendish",
    "j_turtle_bean",
    "j_diet_cola",
    "j_popcorn",
    "j_ramen",
    "j_selzer",
  ];

  // Always generate the food pool with vanilla food jokers
  // This ensures it exists even if no custom jokers use the food pool
  // Technically you could systematically search every item that may want to use the pool, then generate it
  // But that is too much effort for something most people will never even see lol
  poolsMap["food"] = [...vanillaFoodJokers];

  jokers.forEach((joker) => {
    if (joker.pools && joker.pools.length > 0) {
      joker.pools.forEach((poolName) => {
        if (!poolsMap[poolName]) {
          poolsMap[poolName] = [];
        }
        const jokerKey = joker.jokerKey || slugify(joker.name);
        poolsMap[poolName].push(`j_${getModPrefix()}_${jokerKey}`);
      });
    }
  });

  return poolsMap;
};

const generateObjectTypes = (
  poolsMap: Record<string, string[]>,
  modPrefix: string
): string => {
  if (Object.keys(poolsMap).length === 0) {
    return "";
  }

  let output = "";

  Object.entries(poolsMap).forEach(([poolName, jokerKeys]) => {
    const cardsObject = jokerKeys
      .map((key) => `["${key}"] = true`)
      .join(",\n        ");

    output += `SMODS.ObjectType({
    key = "${modPrefix}_${poolName}",
    cards = {
        ${cardsObject}
    },
})

`;
  });

  return output;
};

const collectCustomShaders = (editions: EditionData[]): string[] => {
  const usedShaders = new Set<string>();

  editions.forEach((edition) => {
    if (typeof edition.shader === "string" && isCustomShader(edition.shader)) {
      usedShaders.add(edition.shader);
    }
  });

  return Array.from(usedShaders);
};

const addCustomShadersToZip = async (
  zip: JSZip,
  customShaders: string[]
): Promise<void> => {
  if (customShaders.length === 0) return;

  const assetsFolder = zip.folder("assets");
  const shadersFolder = assetsFolder!.folder("shaders");

  for (const shaderKey of customShaders) {
    const filepath = getCustomShaderFilepath(shaderKey);
    if (filepath) {
      try {
        const response = await fetch(filepath);
        if (response.ok) {
          const shaderContent = await response.text();
          shadersFolder!.file(`${shaderKey}.fs`, shaderContent);
        } else {
          console.warn(`Failed to fetch shader file: ${filepath}`);
        }
      } catch (error) {
        console.warn(`Error loading shader file ${filepath}:`, error);
      }
    }
  }
};

export const exportModCode = async (
  jokers: JokerData[],
  sounds: SoundData[],
  consumables: ConsumableData[],
  metadata: ModMetadata,
  customRarities: RarityData[] = [],
  consumableSets: ConsumableSetData[] = [],
  boosters: BoosterData[] = [],
  enhancements: EnhancementData[] = [],
  seals: SealData[] = [],
  editions: EditionData[] = []
): Promise<boolean> => {
  try {
    console.log("Generating mod code...");

    // Validate metadata before proceeding
    if (
      !metadata.id ||
      !metadata.name ||
      !metadata.author ||
      metadata.author.length === 0
    ) {
      throw new Error("Missing required metadata fields");
    }

    // Filter out items with missing required fields
    const validJokers = jokers.filter((j) => j.id && j.name);
    const validConsumables = consumables.filter((c) => c.id && c.name);
    const validBoosters = boosters.filter((b) => b.id && b.name);
    const validEnhancements = enhancements.filter((e) => e.id && e.name);
    const validSeals = seals.filter((s) => s.id && s.name);
    const validEditions = editions.filter((e) => e.id && e.name);

    console.log(
      `Filtered items - Jokers: ${validJokers.length}, Consumables: ${validConsumables.length}, Boosters: ${validBoosters.length}, Enhancements: ${validEnhancements.length}, Seals: ${validSeals.length}, Editions: ${validEditions.length}`
    );

    const zip = new JSZip();

    const sortedJokers = sortForExport(validJokers);
    const sortedConsumables = sortForExport(validConsumables);
    const sortedBoosters = sortForExport(validBoosters);
    const sortedEnhancements = sortForExport(validEnhancements);
    const sortedSeals = sortForExport(validSeals);
    const sortedEditions = sortForExport(validEditions);
    const customShaders = collectCustomShaders(sortedEditions);

    const hasModIcon = !!(metadata.hasUserUploadedIcon || metadata.iconImage);

    const mainLuaCode = generateMainLuaCode(
      sortedJokers,
      sounds,
      sortedConsumables,
      customRarities,
      sortedBoosters,
      sortedEnhancements,
      sortedSeals,
      sortedEditions,
      hasModIcon,
      metadata
    );
    zip.file(metadata.main_file, mainLuaCode);

    const ret = modToJson(
      metadata,
      sortedJokers,
      sounds,
      customRarities,
      sortedConsumables,
      consumableSets,
      sortedBoosters,
      sortedEnhancements,
      sortedSeals,
      sortedEditions
    );
    zip.file(ret.filename, ret.jsonString);

    if (customRarities.length > 0) {
      const raritiesCode = generateCustomRaritiesCode(customRarities);
      zip.file("rarities.lua", raritiesCode);
    }

    console.log("mod metadata: ", metadata.prefix);

    if (sortedJokers.length > 0) {
      const { jokersCode } = generateJokersCode(
        sortedJokers,
        "CustomJokers",
        metadata.prefix
      );

      const jokersFolder = zip.folder("jokers");
      Object.entries(jokersCode).forEach(([filename, code]) => {
        jokersFolder!.file(filename, code);
      });
    }
    
    if (sounds.length > 0) {
      let soundsCode = ""
      sounds.forEach((sound) => {
        soundsCode += `SMODS.Sound{
    key="${sound.key}",
    path="${sound.key}.ogg",
    pitch=${sound.pitch ?? 0.7},
    volume=${sound.volume ?? 0.6}
}\n\n`
      })

      zip.file("sounds.lua", soundsCode.trim());
    }

    if (sortedConsumables.length > 0 || consumableSets.length > 0) {
      const { consumablesCode } = generateConsumablesCode(sortedConsumables, {
        modPrefix: metadata.prefix,
        atlasKey: "CustomConsumables",
        consumableSets: consumableSets,
      });

      const consumablesFolder = zip.folder("consumables");
      Object.entries(consumablesCode).forEach(([filename, code]) => {
        consumablesFolder!.file(filename, code);
      });
    }

    if (sortedBoosters.length > 0) {
      const { boostersCode } = generateBoostersCode(
        sortedBoosters,
        metadata.prefix
      );
      zip.file("boosters.lua", boostersCode);
    }

    if (sortedEnhancements.length > 0) {
      const { enhancementsCode } = generateEnhancementsCode(
        sortedEnhancements,
        {
          modPrefix: metadata.prefix,
          atlasKey: "CustomEnhancements",
        }
      );

      const enhancementsFolder = zip.folder("enhancements");
      Object.entries(enhancementsCode).forEach(([filename, code]) => {
        enhancementsFolder!.file(filename, code);
      });
    }

    if (sortedSeals.length > 0) {
      const { sealsCode } = generateSealsCode(sortedSeals, {
        modPrefix: metadata.prefix,
        atlasKey: "CustomSeals",
      });

      const sealsFolder = zip.folder("seals");
      Object.entries(sealsCode).forEach(([filename, code]) => {
        sealsFolder!.file(filename, code);
      });
    }

    if (sortedEditions.length > 0) {
      const { editionsCode } = generateEditionsCode(sortedEditions, {
        modPrefix: metadata.prefix,
      });

      const editionsFolder = zip.folder("editions");
      Object.entries(editionsCode).forEach(([filename, code]) => {
        editionsFolder!.file(filename, code);
      });
    }
    zip.file(`${metadata.id}.json`, generateModJson(metadata));

    let modIconData: string | undefined;
    if (metadata.hasUserUploadedIcon && metadata.iconImage) {
      modIconData = metadata.iconImage;
    } else if (!metadata.hasUserUploadedIcon) {
      try {
        const response = await fetch("/images/modicon.png");
        const blob = await response.blob();
        modIconData = await new Promise<string>((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result as string);
          reader.readAsDataURL(blob);
        });
      } catch {
        console.log("Default mod icon not available");
        modIconData = undefined;
      }
    }

    await addCustomShadersToZip(zip, customShaders);

    await addAtlasToZip(
      zip,
      sortedJokers,
      sortedConsumables,
      sortedBoosters,
      sortedEnhancements,
      sortedSeals,
      modIconData
    );

    if (sounds.length > 0) {
      const soundsFolder = zip.folder("assets")!.folder("sounds");

      sounds.forEach((sound) => {
        const soundData = sound.soundString.replace("data:audio/ogg;base64,", "") 
        soundsFolder!.file(`${sound.key}.ogg`, soundData, { base64: true });
      })
    }

    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${metadata.id}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return true;
  } catch (error) {
    console.error("Failed to generate mod:", error);
    throw error;
  }
};

const generateMainLuaCode = (
  jokers: JokerData[],
  sounds: SoundData[],
  consumables: ConsumableData[],
  customRarities: RarityData[],
  boosters: BoosterData[],
  enhancements: EnhancementData[],
  seals: SealData[],
  editions: EditionData[],
  hasModIcon: boolean,
  metadata: ModMetadata
): string => {
  let output = "";

  if (hasModIcon) {
    output += `SMODS.Atlas({
    key = "modicon", 
    path = "ModIcon.png", 
    px = 34,
    py = 34,
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  if (jokers.length > 0) {
    output += `SMODS.Atlas({
    key = "CustomJokers", 
    path = "CustomJokers.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  if (consumables.length > 0) {
    output += `SMODS.Atlas({
    key = "CustomConsumables", 
    path = "CustomConsumables.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  if (boosters.length > 0) {
    output += `SMODS.Atlas({
    key = "CustomBoosters", 
    path = "CustomBoosters.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  if (enhancements.length > 0) {
    output += `SMODS.Atlas({
    key = "CustomEnhancements", 
    path = "CustomEnhancements.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  if (seals.length > 0) {
    output += `SMODS.Atlas({
    key = "CustomSeals", 
    path = "CustomSeals.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  output += `local NFS = require("nativefs")
to_big = to_big or function(a) return a end
lenient_bignum = lenient_bignum or function(a) return a end

`;

  if (jokers.length > 0) {
    output += `local function load_jokers_folder()
    local mod_path = SMODS.current_mod.path
    local jokers_path = mod_path .. "/jokers"
    local files = NFS.getDirectoryItemsInfo(jokers_path)
    for i = 1, #files do
        local file_name = files[i].name
        if file_name:sub(-4) == ".lua" then
            assert(SMODS.load_file("jokers/" .. file_name))()
        end
    end
end

`;
  }

  if (consumables.length > 0) {
    output += `local function load_consumables_folder()
    local mod_path = SMODS.current_mod.path
    local consumables_path = mod_path .. "/consumables"
    local files = NFS.getDirectoryItemsInfo(consumables_path)
    for i = 1, #files do
        local file_name = files[i].name
        if file_name:sub(-4) == ".lua" then
            assert(SMODS.load_file("consumables/" .. file_name))()
        end
    end
end

`;
  }

  if (enhancements.length > 0) {
    output += `local function load_enhancements_folder()
    local mod_path = SMODS.current_mod.path
    local enhancements_path = mod_path .. "/enhancements"
    local files = NFS.getDirectoryItemsInfo(enhancements_path)
    for i = 1, #files do
        local file_name = files[i].name
        if file_name:sub(-4) == ".lua" then
            assert(SMODS.load_file("enhancements/" .. file_name))()
        end
    end
end

`;
  }

  if (seals.length > 0) {
    output += `local function load_seals_folder()
    local mod_path = SMODS.current_mod.path
    local seals_path = mod_path .. "/seals"
    local files = NFS.getDirectoryItemsInfo(seals_path)
    for i = 1, #files do
        local file_name = files[i].name
        if file_name:sub(-4) == ".lua" then
            assert(SMODS.load_file("seals/" .. file_name))()
        end
    end
end

`;
  }

  if (editions.length > 0) {
    output += `local function load_editions_folder()
    local mod_path = SMODS.current_mod.path
    local editions_path = mod_path .. "/editions"
    local files = NFS.getDirectoryItemsInfo(editions_path)
    for i = 1, #files do
        local file_name = files[i].name
        if file_name:sub(-4) == ".lua" then
            assert(SMODS.load_file("editions/" .. file_name))()
        end
    end
end

`;
  }

  if (metadata.disable_vanilla) {
    output += `function SMODS.current_mod.reset_game_globals(run_start)
      local jokerPool = {}
      for k, v in pairs(G.P_CENTERS) do
          if v.set == 'Joker' then
              if (not v.mod) then
                  G.GAME.banned_keys[k] = true
              end
          end
      end
  end

  `;
  }

  if (customRarities.length > 0) {
    output += `local function load_rarities_file()
    local mod_path = SMODS.current_mod.path
    assert(SMODS.load_file("rarities.lua"))()
end

load_rarities_file()
`;
  }

  if (boosters.length > 0) {
    output += `local function load_boosters_file()
    local mod_path = SMODS.current_mod.path
    assert(SMODS.load_file("boosters.lua"))()
end

load_boosters_file()
`;
  }

  if (sounds.length > 0) {
    output += `assert(SMODS.load_file("sounds.lua"))()\n`;
  }

  if (jokers.length > 0) {
    output += `load_jokers_folder()
`;
  }

  if (consumables.length > 0) {
    output += `load_consumables_folder()
`;
  }

  if (enhancements.length > 0) {
    output += `load_enhancements_folder()
`;
  }

  if (seals.length > 0) {
    output += `load_seals_folder()
`;
  }

  if (editions.length > 0) {
    output += `load_editions_folder()
`;
  }

  if (jokers.length > 0) {
    const poolsMap = collectJokerPools(jokers);
    const objectTypesCode = generateObjectTypes(poolsMap, metadata.prefix);
    if (objectTypesCode) {
      output += objectTypesCode;
    }
  }

  return output.trim();
};

const generateModJson = (metadata: ModMetadata): string => {
  const modJson: Record<string, unknown> = {
    id: metadata.id,
    name: metadata.name,
    author: metadata.author,
    description: metadata.description,
    prefix: metadata.prefix,
    main_file: metadata.main_file,
    version: metadata.version,
    priority: metadata.priority,
    badge_colour: metadata.badge_colour,
    badge_text_colour: metadata.badge_text_colour,
  };

  if (metadata.display_name && metadata.display_name !== metadata.name) {
    modJson.display_name = metadata.display_name;
  }

  if (metadata.dependencies && metadata.dependencies.length > 0) {
    modJson.dependencies = metadata.dependencies;
  }

  if (metadata.conflicts && metadata.conflicts.length > 0) {
    modJson.conflicts = metadata.conflicts;
  }

  if (metadata.provides && metadata.provides.length > 0) {
    modJson.provides = metadata.provides;
  }

  if (metadata.dump_loc) {
    modJson.dump_loc = metadata.dump_loc;
  }

  return JSON.stringify(modJson, null, 2);
};

```

### src\components\codeGeneration\ImageProcessor.ts

```
import JSZip from "jszip";
import {
  JokerData,
  BoosterData,
  EnhancementData,
  ConsumableData,
  SealData,
} from "../data/BalatroUtils";

export const processImages = async (
  items: (
    | JokerData
    | ConsumableData
    | BoosterData
    | EnhancementData
    | SealData
  )[],
  scale: number = 1
): Promise<{
  atlasDataUrl: string;
  soulPositions: Record<number, { x: number; y: number }>;
}> => {
  try {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      throw new Error("Failed to get canvas context");
    }

    ctx.imageSmoothingEnabled = false;

    const itemsPerRow = 10;

    const totalPositions = items.reduce((total, item) => {
      return (
        total +
        ("overlayImagePreview" in item && item.overlayImagePreview ? 2 : 1)
      );
    }, 0);

    const rows = Math.ceil(totalPositions / itemsPerRow);

    canvas.width = itemsPerRow * 71 * scale;
    canvas.height = rows * 95 * scale;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const soulPositions: Record<number, { x: number; y: number }> = {};
    let currentPosition = 0;

    const imagePromises = items.map((item, index) => {
      const promises: Promise<void>[] = [];

      promises.push(
        new Promise<void>((resolve) => {
          const imageSrc =
            item.imagePreview ||
            "/images/placeholderjokers/placeholder-joker-1.png";
          const img = new Image();
          img.onload = () => {
            const col = currentPosition % itemsPerRow;
            const row = Math.floor(currentPosition / itemsPerRow);
            const x = col * 71 * scale;
            const y = row * 95 * scale;

            ctx.drawImage(
              img,
              0,
              0,
              img.width,
              img.height,
              x,
              y,
              71 * scale,
              95 * scale
            );

            currentPosition++;
            resolve();
          };

          img.onerror = () => {
            if (
              imageSrc !== "/images/placeholderjokers/placeholder-joker-1.png"
            ) {
              img.src = "/images/placeholderjokers/placeholder-joker-1.png";
            } else {
              currentPosition++;
              resolve();
            }
          };

          img.src = imageSrc;
        })
      );

      if ("overlayImagePreview" in item && item.overlayImagePreview) {
        promises.push(
          new Promise<void>((resolve) => {
            const img = new Image();
            img.onload = () => {
              const col = currentPosition % itemsPerRow;
              const row = Math.floor(currentPosition / itemsPerRow);
              const x = col * 71 * scale;
              const y = row * 95 * scale;

              soulPositions[index] = { x: col, y: row };

              ctx.drawImage(
                img,
                0,
                0,
                img.width,
                img.height,
                x,
                y,
                71 * scale,
                95 * scale
              );

              currentPosition++;
              resolve();
            };

            img.onerror = () => {
              currentPosition++;
              resolve();
            };

            img.src =
              ("overlayImagePreview" in item
                ? item.overlayImagePreview
                : null) || "/images/placeholderjokers/placeholder-joker-1.png";
          })
        );
      }

      return Promise.all(promises);
    });

    await Promise.all(imagePromises);

    return {
      atlasDataUrl: canvas.toDataURL("image/png"),
      soulPositions,
    };
  } catch (error) {
    console.error("Error processing images:", error);
    throw error;
  }
};

// THIS FUNCTION IS FUCKING STUPID AND SHOULD NOT EXIST BUT IT DOES BECUASE BROWSER SUPPORT IS FUCKING STUPID
export const processModIcon = async (
  iconDataUrl: string,
  scale: number = 1
): Promise<string> => {
  try {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      throw new Error("Failed to get canvas context");
    }

    canvas.width = 34 * scale;
    canvas.height = 34 * scale;

    canvas.style.imageRendering = "pixelated";
    canvas.style.imageRendering = "-moz-crisp-edges";
    canvas.style.imageRendering = "crisp-edges";

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        if (scale === 1) {
          // No scaling needed, direct draw
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(img, 0, 0, 34, 34);
        } else {
          // Create a temporary 1x canvas first
          const tempCanvas = document.createElement("canvas");
          const tempCtx = tempCanvas.getContext("2d");

          if (!tempCtx) {
            reject(new Error("Failed to get temp canvas context"));
            return;
          }

          tempCanvas.width = 34;
          tempCanvas.height = 34;
          tempCtx.imageSmoothingEnabled = false;

          // Draw to 1x first
          tempCtx.drawImage(img, 0, 0, 34, 34);

          // Now scale up using putImageData for pixel-perfect scaling
          const imageData = tempCtx.getImageData(0, 0, 34, 34);
          const scaledImageData = ctx.createImageData(34 * scale, 34 * scale);

          for (let y = 0; y < 34; y++) {
            for (let x = 0; x < 34; x++) {
              const sourceIndex = (y * 34 + x) * 4;
              const r = imageData.data[sourceIndex];
              const g = imageData.data[sourceIndex + 1];
              const b = imageData.data[sourceIndex + 2];
              const a = imageData.data[sourceIndex + 3];

              // Scale this pixel up
              for (let sy = 0; sy < scale; sy++) {
                for (let sx = 0; sx < scale; sx++) {
                  const targetIndex =
                    ((y * scale + sy) * (34 * scale) + (x * scale + sx)) * 4;
                  scaledImageData.data[targetIndex] = r;
                  scaledImageData.data[targetIndex + 1] = g;
                  scaledImageData.data[targetIndex + 2] = b;
                  scaledImageData.data[targetIndex + 3] = a;
                }
              }
            }
          }

          ctx.putImageData(scaledImageData, 0, 0);
        }

        resolve(canvas.toDataURL("image/png"));
      };

      img.onerror = () => reject(new Error("Failed to load mod icon"));
      img.src = iconDataUrl;
    });
  } catch (error) {
    console.error("Error processing mod icon:", error);
    throw error;
  }
};

export const dataURLToBlob = (dataUrl: string): Blob => {
  const arr = dataUrl.split(",");
  const mime = arr[0].match(/:(.*?);/)?.[1] || "image/png";
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);

  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }

  return new Blob([u8arr], { type: mime });
};

export const addAtlasToZip = async (
  zip: JSZip,
  jokers: JokerData[],
  consumables: ConsumableData[],
  boosters: BoosterData[] = [],
  enhancements: EnhancementData[] = [],
  seals: SealData[] = [],
  modIconData?: string
): Promise<Record<string, Record<number, { x: number; y: number }>>> => {
  try {
    const assetsFolder = zip.folder("assets");
    const assets1xFolder = assetsFolder!.folder("1x");
    const assets2xFolder = assetsFolder!.folder("2x");

    const soulPositions: Record<
      string,
      Record<number, { x: number; y: number }>
    > = {};

    if (modIconData) {
      const modIcon1xResult = await processModIcon(modIconData, 1);
      const modIcon1xBlob = dataURLToBlob(modIcon1xResult);
      assets1xFolder!.file("ModIcon.png", modIcon1xBlob);

      const modIcon2xResult = await processModIcon(modIconData, 2);
      const modIcon2xBlob = dataURLToBlob(modIcon2xResult);
      assets2xFolder!.file("ModIcon.png", modIcon2xBlob);
    }

    if (jokers.length > 0) {
      const jokerAtlas1xResult = await processImages(jokers, 1);
      const jokerAtlas1xBlob = dataURLToBlob(jokerAtlas1xResult.atlasDataUrl);
      assets1xFolder!.file("CustomJokers.png", jokerAtlas1xBlob);

      const jokerAtlas2xResult = await processImages(jokers, 2);
      const jokerAtlas2xBlob = dataURLToBlob(jokerAtlas2xResult.atlasDataUrl);
      assets2xFolder!.file("CustomJokers.png", jokerAtlas2xBlob);

      soulPositions["jokers"] = jokerAtlas1xResult.soulPositions;
    }

    if (consumables.length > 0) {
      const consumableAtlas1xResult = await processImages(consumables, 1);
      const consumableAtlas1xBlob = dataURLToBlob(
        consumableAtlas1xResult.atlasDataUrl
      );
      assets1xFolder!.file("CustomConsumables.png", consumableAtlas1xBlob);

      const consumableAtlas2xResult = await processImages(consumables, 2);
      const consumableAtlas2xBlob = dataURLToBlob(
        consumableAtlas2xResult.atlasDataUrl
      );
      assets2xFolder!.file("CustomConsumables.png", consumableAtlas2xBlob);

      soulPositions["consumables"] = consumableAtlas1xResult.soulPositions;
    }

    if (boosters.length > 0) {
      const boosterAtlas1xResult = await processImages(boosters, 1);
      const boosterAtlas1xBlob = dataURLToBlob(
        boosterAtlas1xResult.atlasDataUrl
      );
      assets1xFolder!.file("CustomBoosters.png", boosterAtlas1xBlob);

      const boosterAtlas2xResult = await processImages(boosters, 2);
      const boosterAtlas2xBlob = dataURLToBlob(
        boosterAtlas2xResult.atlasDataUrl
      );
      assets2xFolder!.file("CustomBoosters.png", boosterAtlas2xBlob);

      soulPositions["boosters"] = boosterAtlas1xResult.soulPositions;
    }

    if (enhancements.length > 0) {
      const enhancementAtlas1xResult = await processImages(enhancements, 1);
      const enhancementAtlas1xBlob = dataURLToBlob(
        enhancementAtlas1xResult.atlasDataUrl
      );
      assets1xFolder!.file("CustomEnhancements.png", enhancementAtlas1xBlob);

      const enhancementAtlas2xResult = await processImages(enhancements, 2);
      const enhancementAtlas2xBlob = dataURLToBlob(
        enhancementAtlas2xResult.atlasDataUrl
      );
      assets2xFolder!.file("CustomEnhancements.png", enhancementAtlas2xBlob);

      soulPositions["enhancements"] = enhancementAtlas1xResult.soulPositions;
    }

    if (seals.length > 0) {
      const sealAtlas1xResult = await processImages(seals, 1);
      const sealAtlas1xBlob = dataURLToBlob(sealAtlas1xResult.atlasDataUrl);
      assets1xFolder!.file("CustomSeals.png", sealAtlas1xBlob);

      const sealAtlas2xResult = await processImages(seals, 2);
      const sealAtlas2xBlob = dataURLToBlob(sealAtlas2xResult.atlasDataUrl);
      assets2xFolder!.file("CustomSeals.png", sealAtlas2xBlob);

      soulPositions["seals"] = sealAtlas1xResult.soulPositions;
    }

    return soulPositions;
  } catch (error) {
    console.error("Error adding atlas to zip:", error);
    throw error;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\AnteLevelCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateAnteLevelConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.round_resets.ante ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\BlindNameCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateBlindNameConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = condition.params?.value || "Small Blind";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== "${value}"`;
      break;
    case "not_equals":
      comparison = `~= "${value}"`;
      break;
    default:
        comparison = `== "${value}"`;
  }

  return `G.GAME.blind.name ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\BlindRequirementsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCheckBlindRequirementsConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "greater_equals";
  const percentageValue =
    generateGameVariableCode(condition.params.percentage) || 25;

  const decimal = Number(percentageValue) / 100;

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== to_big(${decimal})`;
      break;
    case "not_equals":
      comparison = `~= to_big(${decimal})`;
      break;
    case "greater_than":
      comparison = `> to_big(${decimal})`;
      break;
    case "less_than":
      comparison = `< to_big(${decimal})`;
      break;
    case "greater_equals":
      comparison = `>= to_big(${decimal})`;
      break;
    case "less_equals":
      comparison = `<= to_big(${decimal})`;
      break;
    default:
      comparison = `>= to_big(${decimal})`;
  }

  return `G.GAME.chips / G.GAME.blind.chips ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\BlindTypeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateBlindTypeConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const blindType = (condition.params.blind_type as string) || "small";

  switch (blindType) {
    case "small":
      return `G.GAME.blind:get_type() == 'Small'`;
    case "big":
      return `G.GAME.blind:get_type() == 'Big'`;
    case "boss":
      return `G.GAME.blind.boss`;
    default:
      return `G.GAME.blind.small`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\BossBlindTypeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateBossBlindTypeConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = condition.params?.value || "bl_hook";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== "${value}"`;
      break;
    case "not_equals":
      comparison = `~= "${value}"`;
      break;
    default:
      comparison = `== "${value}"`;
  }

  return `G.GAME.blind.config.blind.key ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\CardEditionCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardEditionConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_played";
  const editionType = (condition.params.edition as string) || "any";

  if (triggerType === "card_destroyed") {
    if (editionType === "any") {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.edition ~= nil then
            return true
        end
    end
    return false
end)()`;
    } else if (editionType === "none") {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.edition == nil then
            return true
        end
    end
    return false
end)()`;
    } else {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.edition and removed_card.edition.key == "${editionType}" then
            return true
        end
    end
    return false
end)()`;
    }
  }

  if (editionType === "any") {
    return `context.other_card.edition ~= nil`;
  } else if (editionType === "none") {
    return `context.other_card.edition == nil`;
  } else {
    return `context.other_card.edition and context.other_card.edition.key == "${editionType}"`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\CardEnhancementCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardEnhancementConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_played";
  const enhancementType = (condition.params.enhancement as string) || "any";

  if (triggerType === "card_destroyed") {
    if (enhancementType === "any") {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        local enhancements = SMODS.get_enhancements(removed_card)
        for k, v in pairs(enhancements) do
            if v then
                return true
            end
        end
    end
    return false
end)()`;
    } else {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if SMODS.get_enhancements(removed_card)["${enhancementType}"] == true then
            return true
        end
    end
    return false
end)()`;
    }
  }

  if (enhancementType === "any") {
    return `(function()
        local enhancements = SMODS.get_enhancements(context.other_card)
        for k, v in pairs(enhancements) do
            if v then
                return true
            end
        end
        return false
    end)()`;
  } else {
    return `SMODS.get_enhancements(context.other_card)["${enhancementType}"] == true`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\CardIndexCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCardIndexConditionCode = (
  rules: Rule[]
): string | null => {
  const triggerType = rules[0].trigger || "card_scored";
  const condition = rules[0].conditionGroups[0].conditions[0];
  const indexType = (condition.params.index_type as string) || "number";
  const indexNumber =
    generateGameVariableCode(condition.params.index_number) || "1";

  const handType = triggerType === "card_discarded" ? "full_hand" : "scoring_hand";

  if (indexType === "first") {
    return `context.other_card == context.${handType}[1]`;
  } else if (indexType === "last") {
    return `context.other_card == context.${handType}[#context.${handType}]`;
  } else {
    return `context.other_card == context.${handType}[${indexNumber}]`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\CardSealCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateCardSealConditionCode = (rules: Rule[]): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_played";
  const sealType = (condition.params.seal as string) || "any";

  const capitalizedSealType =
    sealType === "any"
      ? "any"
      : sealType.charAt(0).toUpperCase() + sealType.slice(1).toLowerCase();

  if (triggerType === "card_destroyed") {
    if (sealType === "any") {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.seal ~= nil then
            return true
        end
    end
    return false
end)()`;
    } else {
      return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.seal == "${capitalizedSealType}" then
            return true
        end
    end
    return false
end)()`;
    }
  }

  return sealType === "any"
    ? `context.other_card.seal ~= nil`
    : `context.other_card.seal == "${capitalizedSealType}"`;
};

```

### src\components\codeGeneration\Jokers\conditions\CheckFlagCondition.ts

```
import { getModPrefix } from "../../../data/BalatroUtils";
import type { Rule } from "../../../ruleBuilder/types";

export const generateCheckFlagConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const flagName = (condition.params.flag_name as string) || "custom_flag";

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore

  const modPrefix = getModPrefix()

  return `(G.GAME.pool_flags.${modPrefix}_${safeFlagName} or false)`;
};

```

### src\components\codeGeneration\Jokers\conditions\ConsumableCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateConsumableCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const consumableType = (condition.params.consumable_type as string) || "any";
  const specificCard = (condition.params.specific_card as string) || "any";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  if (consumableType === "any") {
    return `#G.consumeables.cards ${comparison}`;
  }

  // Handle vanilla sets
  if (consumableType === "Tarot" || consumableType === "Planet" || consumableType === "Spectral") {
    if (specificCard === "any") {
      return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.ability.set == '${consumableType}' then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
    } else {
      const normalizedCardKey = specificCard.startsWith("c_")
        ? specificCard
        : `c_${specificCard}`;

      return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.config.center.key == "${normalizedCardKey}" then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
    }
  }

  // Handle custom consumable sets
  const setKey = consumableType.includes("_")
    ? consumableType.split("_").slice(1).join("_")
    : consumableType;

  if (specificCard === "any") {
    return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.ability.set == '${setKey}' or consumable_card.ability.set == '${consumableType}' then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
  } else {
    const normalizedCardKey = specificCard.startsWith("c_")
      ? specificCard
      : `c_${specificCard}`;

    return `(function()
    local count = 0
    for _, consumable_card in pairs(G.consumeables.cards or {}) do
        if consumable_card.config.center.key == "${normalizedCardKey}" then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\ConsumableTypeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateConsumableTypeConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "consumable_used";
  const consumableType = (condition.params.consumable_type as string) || "any";
  const specificCard = (condition.params.specific_card as string) || "any";

  // Determine the card reference based on trigger type
  const cardRef =
    triggerType === "card_bought" ? "context.card" : "context.consumeable";

  if (consumableType === "any") {
    return `${cardRef} and (${cardRef}.ability.set == 'Tarot' or ${cardRef}.ability.set == 'Planet' or ${cardRef}.ability.set == 'Spectral')`;
  }

  // Handle vanilla sets
  if (consumableType === "Tarot") {
    if (specificCard === "any") {
      return `${cardRef} and ${cardRef}.ability.set == 'Tarot'`;
    } else {
      const normalizedCardKey = specificCard.startsWith("c_")
        ? specificCard
        : `c_${specificCard}`;

      return `${cardRef} and ${cardRef}.ability.set == 'Tarot' and ${cardRef}.config.center.key == '${normalizedCardKey}'`;
    }
  }

  if (consumableType === "Planet") {
    if (specificCard === "any") {
      return `${cardRef} and ${cardRef}.ability.set == 'Planet'`;
    } else {
      const normalizedCardKey = specificCard.startsWith("c_")
        ? specificCard
        : `c_${specificCard}`;

      return `${cardRef} and ${cardRef}.ability.set == 'Planet' and ${cardRef}.config.center.key == '${normalizedCardKey}'`;
    }
  }

  if (consumableType === "Spectral") {
    if (specificCard === "any") {
      return `${cardRef} and ${cardRef}.ability.set == 'Spectral'`;
    } else {
      const normalizedCardKey = specificCard.startsWith("c_")
        ? specificCard
        : `c_${specificCard}`;

      return `${cardRef} and ${cardRef}.ability.set == 'Spectral' and ${cardRef}.config.center.key == '${normalizedCardKey}'`;
    }
  }

  // Handle custom consumable sets
  const setKey = consumableType.includes("_")
    ? consumableType.split("_").slice(1).join("_")
    : consumableType;

  if (specificCard === "any") {
    return `${cardRef} and (${cardRef}.ability.set == '${setKey}' or ${cardRef}.ability.set == '${consumableType}')`;
  } else {
    const normalizedCardKey = specificCard.startsWith("c_")
      ? specificCard
      : `c_${specificCard}`;

    return `${cardRef} and (${cardRef}.ability.set == '${setKey}' or ${cardRef}.ability.set == '${consumableType}') and ${cardRef}.config.center.key == '${normalizedCardKey}'`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\CountHandCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCountCardConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "5";
  const scope = (condition.params.card_scope as string) || "scoring";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  let cardsToCheck = ""
  switch (scope) {
    case "scoring":
      cardsToCheck = "#context.scoring_hand"
      break
    case "all_played":
      cardsToCheck = "#context.full_hand"
      break
    case "unscored":
      cardsToCheck = "(#context.full_hand - #context.scoring_hand)"
      break
  }  
  
  return `${cardsToCheck} ${comparison}`;
};

export const generateDiscardedCardCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "5";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `#context.full_hand ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\CumulativeChipsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateCumulativeChipsConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const hand = (condition.params.hand as string) || "played";
  const check = (condition.params.check as string) || "base";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const cardsToCheck = hand === "played" ? "context.scoring_hand" : "G.hand.cards"
  const propertyCheck = check === "base" ? 'playing_card.base.nominal' : "playing_card:get_chip_bonus()"

  return `(function()
    local chips_sum = 0
    for _, playing_card in pairs(${cardsToCheck} or {}) do
        chips_sum = chips_sum + ${propertyCheck}
    end
    return chips_sum ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\DeckCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";
import { getRankId } from "../../../data/BalatroUtils";

export const generateDeckCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const propertyType =
    (condition.params.property_type as string) || "enhancement";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let propertyCheck = "";

  switch (propertyType) {
    case "rank": {
      const rank = condition.params.rank as string;
      if (rank === "any") {
        propertyCheck = "true";
      } else {
        const rankId = getRankId(rank);
        propertyCheck = `playing_card:get_id() == ${rankId}`;
      }
      break;
    }

    case "suit": {
      const suit = condition.params.suit as string;
      if (suit === "any") {
        propertyCheck = "true";
      } else if (suit === "red") {
        propertyCheck = `(playing_card:is_suit("Hearts") or playing_card:is_suit("Diamonds"))`;
      } else if (suit === "black") {
        propertyCheck = `(playing_card:is_suit("Spades") or playing_card:is_suit("Clubs"))`;
      } else {
        propertyCheck = `playing_card:is_suit("${suit}")`;
      }
      break;
    }

    case "enhancement": {
      const enhancement = condition.params.enhancement as string;
      if (enhancement === "any") {
        propertyCheck = "next(SMODS.get_enhancements(playing_card))";
      } else if (enhancement === "none") {
        propertyCheck = "not next(SMODS.get_enhancements(playing_card))";
      } else {
        propertyCheck = `SMODS.get_enhancements(playing_card)["${enhancement}"] == true`;
      }
      break;
    }

    case "seal": {
      const seal = condition.params.seal as string;
      if (seal === "any") {
        propertyCheck = "playing_card.seal ~= nil";
      } else if (seal === "none") {
        propertyCheck = "playing_card.seal == nil";
      } else {
        propertyCheck = `playing_card.seal == "${seal}"`;
      }
      break;
    }

    case "edition": {
      const edition = condition.params.edition as string;
      if (edition === "any") {
        propertyCheck = "playing_card.edition ~= nil";
      } else if (edition === "none") {
        propertyCheck = "playing_card.edition == nil";
      } else {
        propertyCheck = `playing_card.edition and playing_card.edition.key == "${edition}"`;
      }
      break;
    }

    default:
      propertyCheck = "true";
  }

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `(function()
    local count = 0
    for _, playing_card in pairs(G.playing_cards or {}) do
        if ${propertyCheck} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\DeckSizeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateDeckSizeConditionCode = (rules: Rule[]): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const sizeType = (condition.params.size_type as string) || "remaining";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "52";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const deckSizeRef =
    sizeType === "remaining" ? "#G.deck.cards" : "#G.playing_cards";

  return `${deckSizeRef} ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\EditionCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEditionCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);
  const scope = (condition.params.card_scope as string) || "scoring";

  let propertyCheck = "";
  const edition = condition.params.edition as string;
  if (edition === "any") {
    propertyCheck = "playing_card.edition ~= nil";
  } else if (edition === "none") {
    propertyCheck = "playing_card.edition == nil";
  } else {
    propertyCheck = `playing_card.edition and playing_card.edition.key == "${edition}"`;
  }
    
  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const cardsToCheck =
    scope === "scoring" ? "context.scoring_hand" : "context.full_hand";

  return `(function()
    local count = 0
    for _, playing_card in pairs(${cardsToCheck} or {}) do
        if ${propertyCheck} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\EnhancementCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateEnhancementCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);
  const scope = (condition.params.card_scope as string) || "scoring";

  let propertyCheck = "";
  const enhancement = condition.params.enhancement as string;
  if (enhancement === "any") {
      propertyCheck = "next(SMODS.get_enhancements(playing_card))";
  } else if (enhancement === "none") {
      propertyCheck = "not next(SMODS.get_enhancements(playing_card))";
  } else {
      propertyCheck = `SMODS.get_enhancements(playing_card)["${enhancement}"] == true`;
  }
    
  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const cardsToCheck =
    scope === "scoring" ? "context.scoring_hand" : "context.full_hand";

  return `(function()
    local count = 0
    for _, playing_card in pairs(${cardsToCheck} or {}) do
        if ${propertyCheck} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\FirstDiscardedHandCondition.ts

```
export const generateFirstDiscardedHandConditionCode = (): string => {
  return `G.GAME.current_round.discards_used <= 0`;
};

```

### src\components\codeGeneration\Jokers\conditions\FirstHandPlayedCondition.ts

```
export const generateFirstPlayedHandConditionCode = (): string => {
  return `G.GAME.current_round.hands_played == 0`;
};

```

### src\components\codeGeneration\Jokers\conditions\FirstLastScoredCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import type { JokerData } from "../../../data/BalatroUtils";
import { parseRankVariable, parseSuitVariable } from "../variableUtils";
import { getRankId } from "../../../data/BalatroUtils";

export const generateFirstLastScoredConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const position = (condition.params.position as string) || "first";
  const checkType = (condition.params.check_type as string) || "any";
  const specificRank = condition.params.specific_rank;
  const specificSuit = condition.params.specific_suit;

  const rankVarInfo = parseRankVariable(specificRank, joker);
  const suitVarInfo = parseSuitVariable(specificSuit, joker);

  if (checkType === "rank") {
    let rankCheck = "";
    if (rankVarInfo.isRankVariable) {
      rankCheck = `scoring_card:get_id() == ${rankVarInfo.code}`;
    } else if (typeof specificRank === "string") {
      // Handle rank groups
      if (specificRank === "face") {
        rankCheck = `scoring_card:is_face()`;
      } else if (specificRank === "even") {
        rankCheck = `(scoring_card:get_id() == 2 or scoring_card:get_id() == 4 or scoring_card:get_id() == 6 or scoring_card:get_id() == 8 or scoring_card:get_id() == 10)`;
      } else if (specificRank === "odd") {
        rankCheck = `(scoring_card:get_id() == 14 or scoring_card:get_id() == 3 or scoring_card:get_id() == 5 or scoring_card:get_id() == 7 or scoring_card:get_id() == 9)`;
      } else {
        // Handle specific ranks
        const rankId = getRankId(specificRank);
        rankCheck = `scoring_card:get_id() == ${rankId}`;
      }
    }

    if (position === "first") {
      return `(function()
    for i = 1, #context.scoring_hand do
        local scoring_card = context.scoring_hand[i]
        if ${rankCheck} then
            return scoring_card == context.other_card
        end
    end
    return false
end)()`;
    } else {
      return `(function()
    for i = #context.scoring_hand, 1, -1 do
        local scoring_card = context.scoring_hand[i]
        if ${rankCheck} then
            return scoring_card == context.other_card
        end
    end
    return false
end)()`;
    }
  } else if (checkType === "suit") {
    let suitCheck = "";
    if (suitVarInfo.isSuitVariable) {
      suitCheck = `scoring_card:is_suit(${suitVarInfo.code})`;
    } else if (typeof specificSuit === "string") {
      suitCheck = `scoring_card:is_suit("${specificSuit}")`;
    }

    if (position === "first") {
      return `(function()
    for i = 1, #context.scoring_hand do
        local scoring_card = context.scoring_hand[i]
        if ${suitCheck} then
            return scoring_card == context.other_card
        end
    end
    return false
end)()`;
    } else {
      return `(function()
    for i = #context.scoring_hand, 1, -1 do
        local scoring_card = context.scoring_hand[i]
        if ${suitCheck} then
            return scoring_card == context.other_card
        end
    end
    return false
end)()`;
    }
  } else {
    if (position === "first") {
      return `context.other_card == context.scoring_hand[1]`;
    } else {
      return `context.other_card == context.scoring_hand[#context.scoring_hand]`;
    }
  }
};

```

### src\components\codeGeneration\Jokers\conditions\GenericCompareCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateGenericCompareConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const value1 = generateGameVariableCode(condition.params.value1) || "0";
  const operator = (condition.params.operator as string) || "equals";
  const value2 = generateGameVariableCode(condition.params.value2) || "0";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value2}`;
      break;
    case "not_equals":
      comparison = `~= ${value2}`;
      break;
    case "greater_than":
      comparison = `> ${value2}`;
      break;
    case "less_than":
      comparison = `< ${value2}`;
      break;
    case "greater_equals":
      comparison = `>= ${value2}`;
      break;
    case "less_equals":
      comparison = `<= ${value2}`;
      break;
    default:
      comparison = `== ${value2}`;
  }

  return `${value1} ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\GlassCardDestroyedCondition.ts

```
export const generateGlassCardDestroyedConditionCode = (): string | null => {
  return `(function()
    for k, removed_card in ipairs(context.removed) do
        if removed_card.shattered then
            return true
        end
    end
    return false
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\HandLevelCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateHandLevelConditionCode = (
  rules: Rule[],
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "1";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const handSelection = (condition?.params?.hand_selection as string) || "played";
  const specificHand = (condition?.params?.specific_hand as string) || "High Card";

  let handDeterminationCode = "";
  switch (handSelection) {
    case "played":
      handDeterminationCode = `hand == context.scoring_name` 
      break
    case "specific":
      handDeterminationCode = `hand == "${specificHand}"`;
      break
    case "any":
      handDeterminationCode = `hand`
      break
    default:
      handDeterminationCode = `hand == "High Card"`
  }

  return `(function()
    for hand, data in pairs(G.GAME.hands) do
        if ${handDeterminationCode} and data.level ${comparison} then
            return true
        end
    end
    return false
  end)()`
};
```

### src\components\codeGeneration\Jokers\conditions\HandSizeCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateHandSizeConditionCode = (rules: Rule[]): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "8";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.hand.config.card_limit ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\InternalVariableCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateInternalVariableConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const variableName = (condition.params.variable_name as string) || "var1";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "0";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `(card.ability.extra.${variableName} or 0) ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\JokerCountCondition.ts

```
import { getAllRarities, getModPrefix} from "../../../data/BalatroUtils";
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateJokerCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const rarity = (condition.params.rarity as string) || "any";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  if (rarity === "any") {
    return `#G.jokers.cards ${comparison}`;
  }

  const rarityData = getAllRarities().find((r) => r.key === rarity);
  const modPrefix = getModPrefix();
  const rarityValue = rarityData?.isCustom ? `"${modPrefix}_${rarity}"`: rarityData?.value;

  return `(function()
    local count = 0
    for _, joker_owned in pairs(G.jokers.cards or {}) do
        if joker_owned.config.center.rarity == ${rarityValue} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`
};

```

### src\components\codeGeneration\Jokers\conditions\JokerFlippedCondition.ts

```

export const generateJokerFlippedConditionCode = (): string | null => {
    return `(function()
        return context.other_joker.facing == "back"
    end)()`
};

export const generateThisJokerFlippedConditionCode = (): string | null => {
    return `(function()
        return card.facing == "back"
    end)()`
};

```

### src\components\codeGeneration\Jokers\conditions\JokerKeyCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateJokerKeyConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const jokerKey = (condition.params?.joker_key as string) || "";

  const normalizedJokerKey = jokerKey.startsWith("j_") 
  ? jokerKey 
  : `j_${jokerKey}`

  return `(function()
        return context.other_joker.config.center.key == "${normalizedJokerKey}"
    end)()`;
}
```

### src\components\codeGeneration\Jokers\conditions\JokerPositionCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateJokerPositionConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const position = (condition.params.position as string) || "first";
  const specificIndex = condition.params?.specific_index as number;

  switch (position) {
    default:
    case "first":
      return `(function()
        return G.jokers.cards[1] == context.other_joker
    end)()`
    case "last":
      return `(function()
        return G.jokers.cards[#G.jokers.cards] == context.other_joker
    end)()`
    case "specific":
      return `(function()
        return G.jokers.cards[${specificIndex}] == context.other_joker
    end)()`
  }
};

export const generateThisJokerPositionConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const position = (condition.params.position as string) || "first";
  const specificIndex = condition.params?.specific_index as number;

  switch (position) {
    default:
    case "first":
      return `(function()
        return G.jokers.cards[1] == card
    end)()`
    case "last":
      return `(function()
        return G.jokers.cards[#G.jokers.cards] == card
    end)()`
    case "specific":
      return `(function()
        return G.jokers.cards[${specificIndex}] == card
    end)()`
  }
};

```

### src\components\codeGeneration\Jokers\conditions\JokerRarityCondition.ts

```
import { getAllRarities, getModPrefix} from "../../../data/BalatroUtils";
import type { Rule } from "../../../ruleBuilder/types";

export const generateJokerRarityConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const rarity = (condition.params.rarity as string) || "any";

  const rarityData = getAllRarities().find((r) => r.key === rarity);
  const modPrefix = getModPrefix();
  const rarityValue = rarityData?.isCustom ? `"${modPrefix}_${rarity}"`: rarityData?.value;

  return `(function()
    return context.other_joker.config.center.rarity == ${rarityValue}
end)()`
};

```

### src\components\codeGeneration\Jokers\conditions\JokerStickerCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateJokerStickerConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const sticker = (condition.params.sticker as string) || "eternal";

  return `(function()
    return context.other_joker.ability.${sticker}
end)()`
};

export const generateThisJokerStickerConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const sticker = (condition.params.sticker as string) || "eternal";

  return `(function()
    return card.ability.${sticker}
end)()`
};


```

### src\components\codeGeneration\Jokers\conditions\LuckyCardTriggeredCondition.ts

```
export const generateLuckyCardTriggeredConditionCode = (): string | null => {
  return `context.other_card.lucky_trigger`;
};

```

### src\components\codeGeneration\Jokers\conditions\PlayerMoneyCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generatePlayerMoneyConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== to_big(${value})`;
      break;
    case "not_equals":
      comparison = `~= to_big(${value})`;
      break;
    case "greater_than":
      comparison = `> to_big(${value})`;
      break;
    case "less_than":
      comparison = `< to_big(${value})`;
      break;
    case "greater_equals":
      comparison = `>= to_big(${value})`;
      break;
    case "less_equals":
      comparison = `<= to_big(${value})`;
      break;
    default:
      comparison = `== to_big(${value})`;
  }

  return `G.GAME.dollars ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\PokerHandBeenPlayedCondition.ts

```
export const generatePokerHandBeenPlayedConditionCode = (): string | null => {
  return `G.GAME.hands[context.scoring_name] and G.GAME.hands[context.scoring_name].played_this_round > 1`;
};

```

### src\components\codeGeneration\Jokers\conditions\PokerHandCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import type { JokerData } from "../../../data/BalatroUtils";
import { parsePokerHandVariable } from "../variableUtils";

export const generatePokerHandConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const scope = condition.params.card_scope as string || "scoring";
  const operator = condition.params.operator as string || "contains";
  const handType = condition.params.value as string || "High Card";

    if (handType === "most_played_hand") {
      return `(function()
    local current_played = G.GAME.hands[context.scoring_name].played or 0
    for handname, values in pairs(G.GAME.hands) do
        if handname ~= context.scoring_name and values.played > current_played and values.visible then
            return false
        end
    end
    return true
end)()`;
    }

    if (handType === "least_played_hand") {
      return `(function()
    local current_played = G.GAME.hands[context.scoring_name].played or 0
    for handname, values in pairs(G.GAME.hands) do
        if handname ~= context.scoring_name and values.played < current_played and values.visible then
            return false
        end
    end
    return true
end)()`;
    }

    const pokerHandVarInfo = parsePokerHandVariable(handType, joker);
    const handReference = pokerHandVarInfo.isPokerHandVariable 
    ? `G.GAME.current_round.${pokerHandVarInfo.variableName}_hand` 
    : `"${handType}"`

    if (operator === "contains") {
      return `next(context.poker_hands[${handReference}])`;
    }

    if (scope === "scoring") {
      return `context.scoring_name == ${handReference}`;
    } else if (scope === "all_played") {
      return `next(context.poker_hands[${handReference}])`;
    }

    return `true`;
  }
```

### src\components\codeGeneration\Jokers\conditions\ProbabilityIdentifierCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateProbabilityIdentifierConditionCode = (rules: Rule[]): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const mode = condition.params.mode || "vanilla";

  let specific_card: string;
  switch (mode) {
    case "custom":
      specific_card = (condition.params.card_key as string) || "j_joker";
      break;
    case "vanilla":
    default:
      specific_card = (condition.params.specific_card as string) || "8ball"
  }

  return `context.identifier == "${specific_card}"`;
};

```

### src\components\codeGeneration\Jokers\conditions\ProbabilityPartCompareCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateProbabilityPartCompareConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const part = condition.params.part || "numerator";
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value) || "0";

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `context.${part} ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\ProbabilitySucceededCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateProbabilitySucceededConditionCode = (
  rules: Rule[]
): string => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const status = (condition.params.status as string) || "succeeded";

  return `${status === "succeeded" ? "" : "not "}context.result`;
};

```

### src\components\codeGeneration\Jokers\conditions\RandomChanceCondition.ts

```
//! THIS FILE IS DEPRECIATED BUT IM KEEPING IT HERE BECAUSE IT MIGHT BE USEFUL LATER

import type { Rule } from "../../../ruleBuilder/types";

export const generateRandomChanceConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const numerator = condition.params.numerator as number;
  const denominator = (condition.params.denominator as number) || 4;

  return `pseudorandom('random_chance') < G.GAME.probabilities.normal * ${numerator} / ${denominator}`;
};

```

### src\components\codeGeneration\Jokers\conditions\RankCardCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";
import { parseRankVariable } from "../variableUtils";
import { getRankId, JokerData } from "../../../data/BalatroUtils";

export const generateRankCardConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_played";

  const rankType = (condition.params.rank_type as string) || "specific";
  const specificRank = condition.params.specific_rank;
  const rankGroup = (condition.params.rank_group as string) || null;
  const quantifier = (condition.params.quantifier as string) || "at_least_one";
  const count = generateGameVariableCode(condition.params.count);
  const scope = (condition.params.card_scope as string) || "scoring";

  const rankVarInfo = parseRankVariable(specificRank, joker);

  const getRanksCheckLogic = (
    ranks: string[],
    rankGroupType: string | null,
    useVariable = false,
    varCode?: string,
    cardRef = "c"
  ): string => {
    if (useVariable && varCode) {
      return `${cardRef}:get_id() == ${varCode}`;
    } else if (rankGroupType === "face") {
      return `${cardRef}:is_face()`;
    } else if (rankGroupType === "even") {
      return `(${cardRef}:get_id() == 2 or ${cardRef}:get_id() == 4 or ${cardRef}:get_id() == 6 or ${cardRef}:get_id() == 8 or ${cardRef}:get_id() == 10)`;
    } else if (rankGroupType === "odd") {
      return `(${cardRef}:get_id() == 14 or ${cardRef}:get_id() == 3 or ${cardRef}:get_id() == 5 or ${cardRef}:get_id() == 7 or ${cardRef}:get_id() == 9)`;
    } else if (ranks.length === 1) {
      const rankId = getRankId(ranks[0]);
      return `${cardRef}:get_id() == ${rankId}`;
    } else {
      return ranks
        .map((rank) => `${cardRef}:get_id() == ${getRankId(rank)}`)
        .join(" or ");
    }
  };

  let ranks: string[] = [];
  let rankGroupType: string | null = null;
  let useVariable = false;
  let variableCode = "";

  if (rankType === "specific") {
    if (rankVarInfo.isRankVariable) {
      useVariable = true;
      variableCode = `G.GAME.current_round.${rankVarInfo.variableName}_card.id`;
    } else if (typeof specificRank === "string") {
      ranks = [specificRank];
    }
  } else if (rankType === "group" && rankGroup) {
    rankGroupType = rankGroup;
  }

  if (triggerType === "card_destroyed") {
    const checkLogic = getRanksCheckLogic(
      ranks,
      rankGroupType,
      useVariable,
      variableCode,
      "removed_card"
    );
    return `(function()
    for k, removed_card in ipairs(context.removed) do
        if ${checkLogic} then
            return true
        end
    end
    return false
end)()`;
  }

  if (
    (triggerType === "card_scored" ||
      triggerType === "card_held_in_hand" ||
      triggerType === "card_held_in_hand_end_of_round") &&
    condition.type === "card_rank"
  ) {
    const checkLogic = getRanksCheckLogic(
      ranks,
      rankGroupType,
      useVariable,
      variableCode,
      "context.other_card"
    );
    return checkLogic;
  }

  const cardsToCheck =
    scope === "scoring" && !(triggerType === "card_discarded")
      ? "context.scoring_hand"
      : "context.full_hand";

  switch (quantifier) {
    case "all":
      return `(function()
    local allMatchRank = true
    for i, c in ipairs(${cardsToCheck}) do
        if not (${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )}) then
            allMatchRank = false
            break
        end
    end
    
    return allMatchRank and #${cardsToCheck} > 0
end)()`;

    case "none":
      return `(function()
    local rankFound = true
    for i, c in ipairs(${cardsToCheck}) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankFound = false
            break
        end
    end
    
    return rankFound
end)()`;

    case "exactly":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount == ${count}
end)()`;

    case "at_least":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount >= ${count}
end)()`;

    case "at_most":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount <= ${count} and rankCount > 0
end)()`;

    default:
      return `(function()
    local rankFound = false
    for i, c in ipairs(${cardsToCheck}) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankFound = true
            break
        end
    end
    
    return rankFound
end)()`;
  }
};

export const generateDiscardedRankConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_discarded";

  const rankType = (condition.params.rank_type as string) || "specific";
  const specificRank = condition.params.specific_rank;
  const rankGroup = (condition.params.rank_group as string) || null;
  const quantifier = (condition.params.quantifier as string) || "at_least_one";
  const count = generateGameVariableCode(condition.params.count);

  const rankVarInfo = parseRankVariable(specificRank, joker);

  const getRanksCheckLogic = (
    ranks: string[],
    rankGroupType: string | null,
    useVariable = false,
    varCode?: string,
    cardRef = "c"
  ): string => {
    if (useVariable && varCode) {
      return `${cardRef}:get_id() == ${varCode}`;
    } else if (rankGroupType === "face") {
      return `${cardRef}:is_face()`;
    } else if (rankGroupType === "even") {
      return `(${cardRef}:get_id() == 2 or ${cardRef}:get_id() == 4 or ${cardRef}:get_id() == 6 or ${cardRef}:get_id() == 8 or ${cardRef}:get_id() == 10)`;
    } else if (rankGroupType === "odd") {
      return `(${cardRef}:get_id() == 14 or ${cardRef}:get_id() == 3 or ${cardRef}:get_id() == 5 or ${cardRef}:get_id() == 7 or ${cardRef}:get_id() == 9)`;
    } else if (ranks.length === 1) {
      const rankId = getRankId(ranks[0]);
      return `${cardRef}:get_id() == ${rankId}`;
    } else {
      return ranks
        .map((rank) => `${cardRef}:get_id() == ${getRankId(rank)}`)
        .join(" or ");
    }
  };

  let ranks: string[] = [];
  let rankGroupType: string | null = null;
  let useVariable = false;
  let variableCode = "";

  if (rankType === "specific") {
    if (rankVarInfo.isRankVariable) {
      useVariable = true;
      variableCode = `G.GAME.current_round.${rankVarInfo.variableName}_card.id`;
    } else if (typeof specificRank === "string") {
      ranks = [specificRank];
    }
  } else if (rankType === "group" && rankGroup) {
    rankGroupType = rankGroup;
  }

  if (triggerType === "card_discarded") {
    const checkLogic = getRanksCheckLogic(
      ranks,
      rankGroupType,
      useVariable,
      variableCode,
      "context.other_card"
    );
    return checkLogic;
  }

  switch (quantifier) {
    case "at_least_one":
      return `(function()
    local rankFound = false
    for i, c in ipairs(context.full_hand) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankFound = true
            break
        end
    end
    
    return rankFound
end)()`;

    case "all":
      return `(function()
    local allMatchRank = true
    for i, c in ipairs(context.full_hand) do
        if not (${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )}) then
            allMatchRank = false
            break
        end
    end
    
    return allMatchRank and #context.full_hand > 0
end)()`;

    case "exactly":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount == ${count}
end)()`;

    case "at_least":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount >= ${count}
end)()`;

    case "at_most":
      return `(function()
    local rankCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankCount = rankCount + 1
        end
    end
    
    return rankCount <= ${count} and rankCount > 0
end)()`;

    default:
      return `(function()
    local rankFound = false
    for i, c in ipairs(context.full_hand) do
        if ${getRanksCheckLogic(
          ranks,
          rankGroupType,
          useVariable,
          variableCode
        )} then
            rankFound = true
            break
        end
    end
    
    return rankFound
end)()`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\RemainingDiscardsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateRemainingDiscardsConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.current_round.discards_left ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\RemainingHandsCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateRemainingHandsConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  return `G.GAME.current_round.hands_left ${comparison}`;
};

```

### src\components\codeGeneration\Jokers\conditions\SealCountCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import { generateGameVariableCode } from "../gameVariableUtils";

export const generateSealCountConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = generateGameVariableCode(condition.params.value);
  const scope = (condition.params.card_scope as string) || "scoring";

  let propertyCheck = "";
  const seal = condition.params.seal as string;
  if (seal === "any") {
  propertyCheck = "playing_card.seal ~= nil";
  } else if (seal === "none") {
  propertyCheck = "playing_card.seal == nil";
  } else {
  propertyCheck = `playing_card.seal == "${seal}"`;
  }
    
  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== ${value}`;
      break;
    case "not_equals":
      comparison = `~= ${value}`;
      break;
    case "greater_than":
      comparison = `> ${value}`;
      break;
    case "less_than":
      comparison = `< ${value}`;
      break;
    case "greater_equals":
      comparison = `>= ${value}`;
      break;
    case "less_equals":
      comparison = `<= ${value}`;
      break;
    default:
      comparison = `== ${value}`;
  }

  const cardsToCheck =
    scope === "scoring" ? "context.scoring_hand" : "context.full_hand";

  return `(function()
    local count = 0
    for _, playing_card in pairs(${cardsToCheck} or {}) do
        if ${propertyCheck} then
            count = count + 1
        end
    end
    return count ${comparison}
end)()`;
};

```

### src\components\codeGeneration\Jokers\conditions\SpecificJokerCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateSpecificJokerConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "has";
  const jokerKey = (condition.params.joker_key as string) || "j_joker";

  // Ensure the joker key has the j_ prefix if not provided
  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  if (operator === "has") {
    return `(function()
      for i = 1, #G.jokers.cards do
          if G.jokers.cards[i].config.center.key == "${normalizedJokerKey}" then
              return true
          end
      end
      return false
  end)()`;
  } else if (operator === "does_not_have") {
    return `(function()
      for i = 1, #G.jokers.cards do
          if G.jokers.cards[i].config.center.key == "${normalizedJokerKey}" then
              return false
          end
      end
      return true
  end)()`;
  }

  return null;
};

```

### src\components\codeGeneration\Jokers\conditions\SuitCardCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";
import type { JokerData } from "../../../data/BalatroUtils";
import { generateGameVariableCode } from "../gameVariableUtils";
import { parseSuitVariable } from "../variableUtils";

export const generateSuitCardConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_played";

  const suitType = (condition.params.suit_type as string) || "specific";
  const specificSuit = condition.params.specific_suit;
  const suitGroup = (condition.params.suit_group as string) || null;
  const quantifier = (condition.params.quantifier as string) || "at_least_one";
  const count = generateGameVariableCode(condition.params.count);
  const scope = (condition.params.card_scope as string) || "scoring";

  const suitVarInfo = parseSuitVariable(specificSuit, joker);

  const getSuitsCheckLogic = (
    suits: string[],
    useVariable = false,
    varCode?: string,
    cardRef = "c"
  ): string => {
    if (useVariable && varCode) {
      return `${cardRef}:is_suit(${varCode})`;
    } else if (suits.length === 1) {
      return `${cardRef}:is_suit("${suits[0]}")`;
    } else {
      return suits.map((suit) => `${cardRef}:is_suit("${suit}")`).join(" or ");
    }
  };

  let suits: string[] = [];
  let useVariable = false;
  let variableCode = "";

  if (suitType === "specific") {
    if (suitVarInfo.isSuitVariable) {
      useVariable = true;
      variableCode = suitVarInfo.code!;
    } else if (typeof specificSuit === "string") {
      suits = [specificSuit];
    }
  } else if (suitType === "group" && suitGroup) {
    if (suitGroup === "red") {
      suits = ["Hearts", "Diamonds"];
    } else if (suitGroup === "black") {
      suits = ["Spades", "Clubs"];
    }
  }

  if (triggerType === "card_destroyed") {
    const checkLogic = getSuitsCheckLogic(
      suits,
      useVariable,
      variableCode,
      "removed_card"
    );
    return `(function()
    for k, removed_card in ipairs(context.removed) do
        if ${checkLogic} then
            return true
        end
    end
    return false
end)()`;
  }

  if (
    (triggerType === "card_scored" ||
      triggerType === "card_held_in_hand" ||
      triggerType === "card_held_in_hand_end_of_round") &&
    condition.type === "card_suit"
  ) {
    const checkLogic = getSuitsCheckLogic(
      suits,
      useVariable,
      variableCode,
      "context.other_card"
    );
    return checkLogic;
  }

  const cardsToCheck =
    scope === "scoring" && !(triggerType === "card_discarded")
      ? "context.scoring_hand"
      : "context.full_hand";

  switch (quantifier) {
    case "at_least_one":
      return `(function()
    local suitFound = false
    for i, c in ipairs(${cardsToCheck}) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitFound = true
            break
        end
    end
    
    return suitFound
end)()`;

    case "all":
      return `(function()
    local allMatchSuit = true
    for i, c in ipairs(${cardsToCheck}) do
        if not (${getSuitsCheckLogic(suits, useVariable, variableCode)}) then
            allMatchSuit = false
            break
        end
    end
    
    return allMatchSuit and #${cardsToCheck} > 0
end)()`;

    case "exactly":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount == ${count}
end)()`;

    case "at_least":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount >= ${count}
end)()`;

    case "at_most":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(${cardsToCheck}) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount <= ${count} and suitCount > 0
end)()`;

    default:
      return `(function()
    local suitFound = false
    for i, c in ipairs(${cardsToCheck}) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitFound = true
            break
        end
    end
    
    return suitFound
end)()`;
  }
};

export const generateDiscardedSuitConditionCode = (
  rules: Rule[],
  joker?: JokerData
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const triggerType = rules[0].trigger || "hand_discarded";

  const suitType = (condition.params.suit_type as string) || "specific";
  const specificSuit = condition.params.specific_suit;
  const suitGroup = (condition.params.suit_group as string) || null;
  const quantifier = (condition.params.quantifier as string) || "at_least_one";
  const count = generateGameVariableCode(condition.params.count);

  const suitVarInfo = parseSuitVariable(specificSuit, joker);

  const getSuitsCheckLogic = (
    suits: string[],
    useVariable = false,
    varCode?: string,
    cardRef = "c"
  ): string => {
    if (useVariable && varCode) {
      return `${cardRef}:is_suit(${varCode})`;
    } else if (suits.length === 1) {
      return `${cardRef}:is_suit("${suits[0]}")`;
    } else {
      return suits.map((suit) => `${cardRef}:is_suit("${suit}")`).join(" or ");
    }
  };

  let suits: string[] = [];
  let useVariable = false;
  let variableCode = "";

  if (suitType === "specific") {
    if (suitVarInfo.isSuitVariable) {
      useVariable = true;
      variableCode = suitVarInfo.code!;
    } else if (typeof specificSuit === "string") {
      suits = [specificSuit];
    }
  } else if (suitType === "group" && suitGroup) {
    if (suitGroup === "red") {
      suits = ["Hearts", "Diamonds"];
    } else if (suitGroup === "black") {
      suits = ["Spades", "Clubs"];
    }
  }

  if (triggerType === "card_discarded") {
    const checkLogic = getSuitsCheckLogic(
      suits,
      useVariable,
      variableCode,
      "context.other_card"
    );
    return checkLogic;
  }

  switch (quantifier) {
    case "at_least_one":
      return `(function()
    local suitFound = false
    for i, c in ipairs(context.full_hand) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitFound = true
            break
        end
    end
    
    return suitFound
end)()`;

    case "all":
      return `(function()
    local allMatchSuit = true
    for i, c in ipairs(context.full_hand) do
        if not (${getSuitsCheckLogic(suits, useVariable, variableCode)}) then
            allMatchSuit = false
            break
        end
    end
    
    return allMatchSuit and #context.full_hand > 0
end)()`;

    case "exactly":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount == ${count}
end)()`;

    case "at_least":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount >= ${count}
end)()`;

    case "at_most":
      return `(function()
    local suitCount = 0
    for i, c in ipairs(context.full_hand) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitCount = suitCount + 1
        end
    end
    
    return suitCount <= ${count} and suitCount > 0
end)()`;

    default:
      return `(function()
    local suitFound = false
    for i, c in ipairs(context.full_hand) do
        if ${getSuitsCheckLogic(suits, useVariable, variableCode)} then
            suitFound = true
            break
        end
    end
    
    return suitFound
end)()`;
  }
};

```

### src\components\codeGeneration\Jokers\conditions\SystemCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateSystemConditionCode = (
  rules: Rule[],
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];

  return `love.system.getOS() == "${condition.params?.system || "Windows"}"`;
};

```

### src\components\codeGeneration\Jokers\conditions\TriggeredBossBlindCondition.ts

```
export const generateTriggeredBossBlindConditionCode = (): string | null => {
  return `G.GAME.blind.triggered`;
};

```

### src\components\codeGeneration\Jokers\conditions\VoucherRedeemedCondition.ts

```
import type { Rule } from "../../../ruleBuilder/types";

export const generateVoucherRedeemedConditionCode = (
  rules: Rule[]
): string => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const voucher = (condition.params.voucher as string) || "v_overstock_norm";

  return `G.GAME.used_vouchers["${voucher}"]`
};

```

### src\components\codeGeneration\Jokers\conditions\WhichTagCondition.ts

```
import { TAG_TYPES } from "../../../data/BalatroUtils";
import { Rule } from "../../../ruleBuilder/types";

export const generateWhichTagConditionCode = (
  rules: Rule[]
): string | null => {
  const condition = rules[0].conditionGroups[0].conditions[0];
  const operator = (condition.params.operator as string) || "equals";
  const value = condition.params?.value as string || "double";
  const tag = TAG_TYPES[value];

  let comparison = "";
  switch (operator) {
    case "equals":
      comparison = `== "${tag}"`;
      break;
    case "not_equals":
      comparison = `~= "${tag}"`;
      break;
    default:
      comparison = `== "${tag}"`;
  }

  return `context.tag_added.key ${comparison}`
}
```

### src\components\codeGeneration\Jokers\conditionUtils.ts

```
import type { Rule, Condition, ConditionGroup } from "../../ruleBuilder/types";
import type { JokerData } from "../../data/BalatroUtils";
import { generatePokerHandConditionCode } from "./conditions/PokerHandCondition";
import {
  generateSuitCardConditionCode,
  generateDiscardedSuitConditionCode,
} from "./conditions/SuitCardCondition";
import {
  generateRankCardConditionCode,
  generateDiscardedRankConditionCode,
} from "./conditions/RankCardCondition";
import {
  generateCountCardConditionCode,
  generateDiscardedCardCountConditionCode,
} from "./conditions/CountHandCondition";
import { generatePlayerMoneyConditionCode } from "./conditions/PlayerMoneyCondition";
import { generateRemainingHandsConditionCode } from "./conditions/RemainingHandsCondition";
import { generateRemainingDiscardsConditionCode } from "./conditions/RemainingDiscardsCondition";
import { generateJokerCountConditionCode } from "./conditions/JokerCountCondition";
import { generateBlindTypeConditionCode } from "./conditions/BlindTypeCondition";
import { generateCardEnhancementConditionCode } from "./conditions/CardEnhancementCondition";
import { generateEnhancementCountConditionCode } from "./conditions/EnhancementCountCondition";
import { generateCardSealConditionCode } from "./conditions/CardSealCondition";
import { generateSealCountConditionCode } from "./conditions/SealCountCondition";
import { generateInternalVariableConditionCode } from "./conditions/InternalVariableCondition";
import { generateFirstPlayedHandConditionCode } from "./conditions/FirstHandPlayedCondition";
import { generateFirstDiscardedHandConditionCode } from "./conditions/FirstDiscardedHandCondition";
import { generateAnteLevelConditionCode } from "./conditions/AnteLevelCondition";
import { generateHandSizeConditionCode } from "./conditions/HandSizeCondition";
import { generateDeckSizeConditionCode } from "./conditions/DeckSizeCondition";
import { generateDeckCountConditionCode } from "./conditions/DeckCountCondition";
import { generateCardEditionConditionCode } from "./conditions/CardEditionCondition";
import { generateEditionCountConditionCode } from "./conditions/EditionCountCondition";
import { generateSpecificJokerConditionCode } from "./conditions/SpecificJokerCondition";
import { generateGenericCompareConditionCode } from "./conditions/GenericCompareCondition";
import { generateConsumableCountConditionCode } from "./conditions/ConsumableCountCondition";
import { generateCheckBlindRequirementsConditionCode } from "./conditions/BlindRequirementsCondition";
import { generateGlassCardDestroyedConditionCode } from "./conditions/GlassCardDestroyedCondition";
import { generateConsumableTypeConditionCode } from "./conditions/ConsumableTypeCondition";
import { generatePokerHandBeenPlayedConditionCode } from "./conditions/PokerHandBeenPlayedCondition";
import { generateTriggeredBossBlindConditionCode } from "./conditions/TriggeredBossBlindCondition";
import { generateLuckyCardTriggeredConditionCode } from "./conditions/LuckyCardTriggeredCondition";
import { generateCardIndexConditionCode } from "./conditions/CardIndexCondition";
import { generateProbabilityIdentifierConditionCode } from "./conditions/ProbabilityIdentifierCondition";
import { generateProbabilityPartCompareConditionCode } from "./conditions/ProbabilityPartCompareCondition";
import { generateHandLevelConditionCode } from "./conditions/HandLevelCondition";
import { generateCumulativeChipsConditionCode } from "./conditions/CumulativeChipsCondition";
import { generateBlindNameConditionCode } from "./conditions/BlindNameCondition";
import { generateFirstLastScoredConditionCode } from "./conditions/FirstLastScoredCondition";
import { generateProbabilitySucceededConditionCode } from "./conditions/ProbabilitySucceededCondition";
import { generateVoucherRedeemedConditionCode } from "./conditions/VoucherRedeemedCondition";
import { generateJokerRarityConditionCode } from "./conditions/JokerRarityCondition";
import {
  generateJokerStickerConditionCode,
  generateThisJokerStickerConditionCode,
} from "./conditions/JokerStickerCondition";
import {
  generateJokerPositionConditionCode,
  generateThisJokerPositionConditionCode,
} from "./conditions/JokerPositionCondition";
import { generateJokerKeyConditionCode } from "./conditions/JokerKeyCondition";
import { generateCheckFlagConditionCode } from "./conditions/CheckFlagCondition";
import { generateBossBlindTypeConditionCode } from "./conditions/BossBlindTypeCondition";
import { generateJokerFlippedConditionCode, generateThisJokerFlippedConditionCode } from "./conditions/JokerFlippedCondition";
import { generateWhichTagConditionCode } from "./conditions/WhichTagCondition";
import { generateSystemConditionCode } from "./conditions/SystemCondition";

export const generateConditionChain = (
  rule: Rule,
  joker?: JokerData
): string => {
  if (!rule.conditionGroups || rule.conditionGroups.length === 0) {
    return "";
  }

  const groupConditions: string[] = [];

  rule.conditionGroups.forEach((group) => {
    const conditions = generateConditionGroupCode(group, rule, joker);
    if (conditions) {
      groupConditions.push(conditions);
    }
  });

  if (groupConditions.length === 0) {
    return "";
  }

  if (groupConditions.length === 1) {
    return groupConditions[0];
  }

  let result = groupConditions[0];
  for (let i = 1; i < groupConditions.length; i++) {
    const prevGroup = rule.conditionGroups[i - 1];
    const operator = prevGroup.operator === "or" ? " or " : " and ";
    result += operator + groupConditions[i];
  }

  return `(${result})`;
};

const generateConditionGroupCode = (
  group: ConditionGroup,
  rule: Rule,
  joker?: JokerData
): string => {
  if (!group.conditions || group.conditions.length === 0) {
    return "";
  }

  const conditionCodes: string[] = [];

  group.conditions.forEach((condition) => {
    const code = generateSingleConditionCode(condition, rule, joker);
    if (code) {
      let finalCode = code;

      if (condition.negate) {
        finalCode = `not (${code})`;
      }

      conditionCodes.push(finalCode);
    }
  });

  if (conditionCodes.length === 0) {
    return "";
  }

  if (conditionCodes.length === 1) {
    return conditionCodes[0];
  }

  let result = conditionCodes[0];
  for (let i = 1; i < conditionCodes.length; i++) {
    const prevCondition = group.conditions[i - 1];
    const operator = prevCondition.operator === "or" ? " or " : " and ";
    result += operator + conditionCodes[i];
  }

  return `(${result})`;
};

const generateSingleConditionCode = (
  condition: Condition,
  rule: Rule,
  joker?: JokerData
): string | null => {
  const singleConditionRule = {
    ...rule,
    conditionGroups: [
      {
        ...rule.conditionGroups[0],
        conditions: [condition],
      },
    ],
  };

  switch (condition.type) {
    case "hand_type":
      return generatePokerHandConditionCode([singleConditionRule], joker);

    case "suit_count":
    case "card_suit":
      return generateSuitCardConditionCode([singleConditionRule], joker);

    case "discarded_suit_count":
      return generateDiscardedSuitConditionCode([singleConditionRule], joker);

    case "rank_count":
    case "card_rank":
      return generateRankCardConditionCode([singleConditionRule], joker);

    case "discarded_rank_count":
      return generateDiscardedRankConditionCode([singleConditionRule], joker);

    case "card_count":
      return generateCountCardConditionCode([singleConditionRule]);

    case "discarded_card_count":
      return generateDiscardedCardCountConditionCode([singleConditionRule]);

    case "enhancement_count":
      return generateEnhancementCountConditionCode([singleConditionRule]);

    case "card_enhancement":
      return generateCardEnhancementConditionCode([singleConditionRule]);

    case "seal_count":
      return generateSealCountConditionCode([singleConditionRule]);

    case "card_seal":
      return generateCardSealConditionCode([singleConditionRule]);

    case "player_money":
      return generatePlayerMoneyConditionCode([singleConditionRule]);

    case "remaining_hands":
      return generateRemainingHandsConditionCode([singleConditionRule]);

    case "remaining_discards":
      return generateRemainingDiscardsConditionCode([singleConditionRule]);

    case "joker_count":
      return generateJokerCountConditionCode([singleConditionRule]);

    case "hand_level":
      return generateHandLevelConditionCode([singleConditionRule]);

    case "blind_type":
      return generateBlindTypeConditionCode([singleConditionRule]);

    case "internal_variable":
      return generateInternalVariableConditionCode([singleConditionRule]);

    case "check_flag":
      return generateCheckFlagConditionCode([singleConditionRule]);

    case "first_played_hand":
      return generateFirstPlayedHandConditionCode();

    case "first_discarded_hand":
      return generateFirstDiscardedHandConditionCode();

    case "ante_level":
      return generateAnteLevelConditionCode([singleConditionRule]);

    case "hand_size":
      return generateHandSizeConditionCode([singleConditionRule]);

    case "deck_size":
      return generateDeckSizeConditionCode([singleConditionRule]);

    case "deck_count":
      return generateDeckCountConditionCode([singleConditionRule]);

    case "card_edition":
      return generateCardEditionConditionCode([singleConditionRule]);

    case "edition_count":
      return generateEditionCountConditionCode([singleConditionRule]);

    case "specific_joker":
      return generateSpecificJokerConditionCode([singleConditionRule]);

    case "generic_compare":
      return generateGenericCompareConditionCode([singleConditionRule]);

    case "consumable_count":
      return generateConsumableCountConditionCode([singleConditionRule]);

    case "check_blind_requirements":
      return generateCheckBlindRequirementsConditionCode([singleConditionRule]);

    case "glass_card_destroyed":
      return generateGlassCardDestroyedConditionCode();

    case "consumable_type":
      return generateConsumableTypeConditionCode([singleConditionRule]);

    case "poker_hand_been_played":
      return generatePokerHandBeenPlayedConditionCode();

    case "cumulative_chips":
      return generateCumulativeChipsConditionCode([singleConditionRule]);

    case "triggered_boss_blind":
      return generateTriggeredBossBlindConditionCode();

    case "lucky_card_triggered":
      return generateLuckyCardTriggeredConditionCode();

    case "probability_identifier":
      return generateProbabilityIdentifierConditionCode([singleConditionRule]);

    case "probability_part_compare":
      return generateProbabilityPartCompareConditionCode([singleConditionRule]);

    case "card_index":
      return generateCardIndexConditionCode([singleConditionRule]);

    case "blind_name":
      return generateBlindNameConditionCode([singleConditionRule]);

    case "first_last_scored":
      return generateFirstLastScoredConditionCode([singleConditionRule], joker);

    case "probability_succeeded":
      return generateProbabilitySucceededConditionCode([singleConditionRule]);

    case "voucher_redeemed":
      return generateVoucherRedeemedConditionCode([singleConditionRule]);

    case "joker_specific":
      return generateJokerKeyConditionCode([singleConditionRule]);

    case "joker_rarity":
      return generateJokerRarityConditionCode([singleConditionRule]);

    case "joker_index":
      return generateJokerPositionConditionCode([singleConditionRule]);
    case "this_joker_index":
      return generateThisJokerPositionConditionCode([singleConditionRule]);

    case "joker_sticker":
      return generateJokerStickerConditionCode([singleConditionRule]);
    case "this_joker_sticker":
      return generateThisJokerStickerConditionCode([singleConditionRule]);
    
    case "joker_flipped":
      return generateJokerFlippedConditionCode();
    case "this_joker_flipped":
      return generateThisJokerFlippedConditionCode();

    case "boss_blind_type":
      return generateBossBlindTypeConditionCode([singleConditionRule]);

    case "which_tag":
      return generateWhichTagConditionCode([singleConditionRule]);
    
    case "system_condition":
      return generateSystemConditionCode([singleConditionRule]);

    default:
      return null;
  }
};

```

### src\components\codeGeneration\Jokers\effects\AddCardToDeckEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateAddCardToDeckReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const suit = (effect.params?.suit as string) || "random";
  const rank = (effect.params?.rank as string) || "random";
  const enhancement = (effect.params?.enhancement as string) || "none";
  const seal = (effect.params?.seal as string) || "none";
  const edition = (effect.params?.edition as string) || "none";

  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const heldInHandTriggers = ["card_held_in_hand"];

  const isScoring = scoringTriggers.includes(triggerType);
  const isHeldInHand = heldInHandTriggers.includes(triggerType);

  let cardSelectionCode = "";

  if (suit === "random" && rank === "random") {
    cardSelectionCode =
      "local card_front = pseudorandom_element(G.P_CARDS, pseudoseed('add_card'))";
  } else if (suit !== "random" && rank !== "random") {
    const cardRank = rank === "10" ? "T" : rank;
    const cardKey = `${suit.charAt(0)}_${cardRank}`;
    cardSelectionCode = `local card_front = G.P_CARDS.${cardKey}`;
  } else if (suit === "random" && rank !== "random") {
    const cardRank = rank === "10" ? "T" : rank;
    cardSelectionCode = `local card_front = pseudorandom_element({G.P_CARDS.S_${cardRank}, G.P_CARDS.H_${cardRank}, G.P_CARDS.D_${cardRank}, G.P_CARDS.C_${cardRank}}, pseudoseed('add_card_suit'))`;
  } else if (suit !== "random" && rank === "random") {
    const suitCode = suit.charAt(0);
    cardSelectionCode = `local card_front = pseudorandom_element({G.P_CARDS.${suitCode}_2, G.P_CARDS.${suitCode}_3, G.P_CARDS.${suitCode}_4, G.P_CARDS.${suitCode}_5, G.P_CARDS.${suitCode}_6, G.P_CARDS.${suitCode}_7, G.P_CARDS.${suitCode}_8, G.P_CARDS.${suitCode}_9, G.P_CARDS.${suitCode}_T, G.P_CARDS.${suitCode}_J, G.P_CARDS.${suitCode}_Q, G.P_CARDS.${suitCode}_K, G.P_CARDS.${suitCode}_A}, pseudoseed('add_card_rank'))`;
  }

  let centerParam = "";
  if (enhancement === "none") {
    centerParam = "G.P_CENTERS.c_base";
  } else if (enhancement === "random") {
    centerParam =
      "pseudorandom_element({G.P_CENTERS.m_gold, G.P_CENTERS.m_steel, G.P_CENTERS.m_glass, G.P_CENTERS.m_wild, G.P_CENTERS.m_mult, G.P_CENTERS.m_lucky, G.P_CENTERS.m_stone}, pseudoseed('add_card_enhancement'))";
  } else {
    centerParam = `G.P_CENTERS.${enhancement}`;
  }

  let sealCode = "";
  if (seal === "random") {
    sealCode = `\n            new_card:set_seal(pseudorandom_element({"Gold", "Red", "Blue", "Purple"}, pseudoseed('add_card_seal')), true)`;
  } else if (seal !== "none") {
    sealCode = `\n            new_card:set_seal("${seal}", true)`;
  }

  let editionCode = "";
  if (edition === "random") {
    editionCode = `\n            new_card:set_edition(pseudorandom_element({"e_foil", "e_holo", "e_polychrome", "e_negative"}, pseudoseed('add_card_edition')), true)`;
  } else if (edition !== "none") {
    editionCode = `\n            new_card:set_edition("${edition}", true)`;
  }

  if (isScoring || isHeldInHand) {
    return {
      statement: `__PRE_RETURN_CODE__
                ${cardSelectionCode}
                local base_card = create_playing_card({
                    front = card_front,
                    center = ${centerParam}
                }, G.discard, true, false, nil, true)${sealCode.replace(
                  /new_card/g,
                  "base_card"
                )}${editionCode.replace(/new_card/g, "base_card")}
                
                G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                local new_card = copy_card(base_card, nil, nil, G.playing_card)
                new_card:add_to_deck()
                G.deck.config.card_limit = G.deck.config.card_limit + 1
                G.deck:emplace(new_card)
                table.insert(G.playing_cards, new_card)
                
                base_card:remove()
                
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        new_card:start_materialize()
                        return true
                    end
                }))
                __PRE_RETURN_CODE_END__`,
      message: customMessage ? `"${customMessage}"` : '"Added Card!"',
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `__PRE_RETURN_CODE__
            ${cardSelectionCode}
            local new_card = create_playing_card({
                front = card_front,
                center = ${centerParam}
            }, G.discard, true, false, nil, true)${sealCode}${editionCode}
            
            G.E_MANAGER:add_event(Event({
                func = function()
                    new_card:start_materialize()
                    G.play:emplace(new_card)
                    return true
                end
            }))
            __PRE_RETURN_CODE_END__
            func = function()
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.deck.config.card_limit = G.deck.config.card_limit + 1
                        return true
                    end
                }))
                draw_card(G.play, G.deck, 90, 'up')
                SMODS.calculate_context({ playing_card_added = true, cards = { new_card } })
            end`,
      message: customMessage ? `"${customMessage}"` : '"Added Card!"',
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\AddCardToHandEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateAddCardToHandReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const suit = (effect.params?.suit as string) || "random";
  const rank = (effect.params?.rank as string) || "random";
  const enhancement = (effect.params?.enhancement as string) || "none";
  const seal = (effect.params?.seal as string) || "none";
  const edition = (effect.params?.edition as string) || "none";

  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const heldInHandTriggers = ["card_held_in_hand"];

  const isScoring = scoringTriggers.includes(triggerType);
  const isHeldInHand = heldInHandTriggers.includes(triggerType);

  let cardSelectionCode = "";

  if (suit === "random" && rank === "random") {
    cardSelectionCode =
      "local card_front = pseudorandom_element(G.P_CARDS, pseudoseed('add_card_hand'))";
  } else if (suit !== "random" && rank !== "random") {
    const cardRank = rank === "10" ? "T" : rank;
    const cardKey = `${suit.charAt(0)}_${cardRank}`;
    cardSelectionCode = `local card_front = G.P_CARDS.${cardKey}`;
  } else if (suit === "random" && rank !== "random") {
    const cardRank = rank === "10" ? "T" : rank;
    cardSelectionCode = `local card_front = pseudorandom_element({G.P_CARDS.S_${cardRank}, G.P_CARDS.H_${cardRank}, G.P_CARDS.D_${cardRank}, G.P_CARDS.C_${cardRank}}, pseudoseed('add_card_hand_suit'))`;
  } else if (suit !== "random" && rank === "random") {
    const suitCode = suit.charAt(0);
    cardSelectionCode = `local card_front = pseudorandom_element({G.P_CARDS.${suitCode}_2, G.P_CARDS.${suitCode}_3, G.P_CARDS.${suitCode}_4, G.P_CARDS.${suitCode}_5, G.P_CARDS.${suitCode}_6, G.P_CARDS.${suitCode}_7, G.P_CARDS.${suitCode}_8, G.P_CARDS.${suitCode}_9, G.P_CARDS.${suitCode}_T, G.P_CARDS.${suitCode}_J, G.P_CARDS.${suitCode}_Q, G.P_CARDS.${suitCode}_K, G.P_CARDS.${suitCode}_A}, pseudoseed('add_card_hand_rank'))`;
  }

  let centerParam = "";
  if (enhancement === "none") {
    centerParam = "G.P_CENTERS.c_base";
  } else if (enhancement === "random") {
    centerParam =
      "pseudorandom_element({G.P_CENTERS.m_gold, G.P_CENTERS.m_steel, G.P_CENTERS.m_glass, G.P_CENTERS.m_wild, G.P_CENTERS.m_mult, G.P_CENTERS.m_lucky, G.P_CENTERS.m_stone}, pseudoseed('add_card_hand_enhancement'))";
  } else {
    centerParam = `G.P_CENTERS.${enhancement}`;
  }

  let sealCode = "";
  if (seal === "random") {
    sealCode = `\n            new_card:set_seal(pseudorandom_element({"Gold", "Red", "Blue", "Purple"}, pseudoseed('add_card_hand_seal')), true)`;
  } else if (seal !== "none") {
    sealCode = `\n            new_card:set_seal("${seal}", true)`;
  }

  let editionCode = "";
  if (edition === "random") {
    editionCode = `\n            new_card:set_edition(pseudorandom_element({"e_foil", "e_holo", "e_polychrome", "e_negative"}, pseudoseed('add_card_hand_edition')), true)`;
  } else if (edition !== "none") {
    editionCode = `\n            new_card:set_edition("${edition}", true)`;
  }

  if (isScoring || isHeldInHand) {
    return {
      statement: `__PRE_RETURN_CODE__
                ${cardSelectionCode}
                local new_card = create_playing_card({
                    front = card_front,
                    center = ${centerParam}
                }, G.discard, true, false, nil, true)${sealCode.replace(
                  /new_card/g,
                  "new_card"
                )}${editionCode.replace(/new_card/g, "new_card")}
                
                G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                new_card.playing_card = G.playing_card
                table.insert(G.playing_cards, new_card)
                
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        G.hand:emplace(new_card)
                        new_card:start_materialize()
                        return true
                    end
                }))
                __PRE_RETURN_CODE_END__`,
      message: customMessage ? `"${customMessage}"` : '"Added Card to Hand!"',
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()
                ${cardSelectionCode}
                local new_card = create_playing_card({
                    front = card_front,
                    center = ${centerParam}
                }, G.discard, true, false, nil, true)${sealCode.replace(
                  /new_card/g,
                  "new_card"
                )}${editionCode.replace(/new_card/g, "new_card")}
                
                G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                new_card.playing_card = G.playing_card
                table.insert(G.playing_cards, new_card)
                
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.hand:emplace(new_card)
                        new_card:start_materialize()
                        SMODS.calculate_context({ playing_card_added = true, cards = { new_card } })
                        return true
                    end
                }))
            end`,
      message: customMessage ? `"${customMessage}"` : '"Added Card to Hand!"',
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\AddChipsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "chips" : `chips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `chips = ${valueCode}`,
    colour: "G.C.CHIPS",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\AddDollarsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn} from "../effectUtils";

export const generateAddDollarsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {

  const variableName =
    sameTypeCount === 0 ? "dollars" : `dollars${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `dollars = lenient_bignum(${valueCode})`,
    colour: "",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\AddMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateAddMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "mult" : `mult${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `mult = ${valueCode}`,
    colour: "",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\AddPlanetCardEffect.ts

```
//! DEPRECIATED FILE

import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { PLANET_CARDS } from "../../../data/BalatroUtils";

export const generateAddPlanetCardReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const planetCard = (effect.params?.planet_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let planetCreationCode = "";

  if (planetCard === "random") {
    if (isNegative) {
      planetCreationCode = `local created_planet = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local planet_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'joker_forge_planet')
                        planet_card:set_edition("e_negative", true)
                        planet_card:add_to_deck()
                        G.consumeables:emplace(planet_card)
                        return true
                    end
                }))`;
    } else {
      planetCreationCode = `local created_planet = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_planet = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local planet_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, nil, 'joker_forge_planet')
                            planet_card:add_to_deck()
                            G.consumeables:emplace(planet_card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  } else {
    // Check if the planetCard exists in PLANET_CARDS, otherwise fallback to c_pluto
    const planetCardData = PLANET_CARDS.find((card) => card.key === planetCard);
    const planetKey = planetCardData ? planetCard : "c_pluto";

    if (isNegative) {
      planetCreationCode = `local created_planet = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local planet_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, '${planetKey}')
                        planet_card:set_edition("e_negative", true)
                        planet_card:add_to_deck()
                        G.consumeables:emplace(planet_card)
                        return true
                    end
                }))`;
    } else {
      planetCreationCode = `local created_planet = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_planet = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local planet_card = create_card('Planet', G.consumeables, nil, nil, nil, nil, '${planetKey}')
                            planet_card:add_to_deck()
                            G.consumeables:emplace(planet_card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${planetCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_planet and localize('k_plus_planet') or nil`,
      colour: "G.C.SECONDARY_SET.Planet",
    };
  } else {
    return {
      statement: `func = function()${planetCreationCode}
                    if created_planet then
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                          customMessage
                            ? `"${customMessage}"`
                            : `localize('k_plus_planet')`
                        }, colour = G.C.SECONDARY_SET.Planet})
                    end
                    return true
                end`,
      colour: "G.C.SECONDARY_SET.Planet",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\AddSellValueEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables,
} from "../gameVariableUtils";

export const generateAddSellValueReturn = (
  effect: Effect,
  triggerType: string,
  sameTypeCount: number = 0
): EffectReturn => {
  const target = (effect.params?.target as string) || "specific";
  const specificTarget = (effect.params?.specific_target as string) || "self";

  const variableName =
    sameTypeCount === 0 ? "sell_value" : `sell_value${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let sellValueCode = "";
  let targetJokerLogic = ''

  if (target == "specific") {
    if (specificTarget == "left" || specificTarget == "right" || specificTarget == "self") {
      targetJokerLogic += `local my_pos = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                my_pos = i
                break
            end
        end
        local `}
    switch (specificTarget) {
      case "right":
        targetJokerLogic += `target_joker = (my_pos and my_pos < #G.jokers.cards) and G.jokers.cards[my_pos + 1] or nil`;
        break;
      case "left":
        targetJokerLogic += `target_joker = (my_pos and my_pos > 1) and G.jokers.cards[my_pos - 1] or nil`;
        break;
      case "self":
        targetJokerLogic += `target_joker = G.jokers.cards[my_post]`;
        break;
      case "first":
        targetJokerLogic += `target_joker = G.jokers.cards[1]`;
        break
      case "last":
        targetJokerLogic += `target_joker = G.jokers.cards[#G.jokers]`;
        break
      case "random":
        targetJokerLogic += `chosenTarget = pseudorandom(3456543, 1, #G.jokers.cards) or nil
        target_joker = G.jokers.cards[chosenTarget]
        end`;
        break;
    }
    sellValueCode += `${targetJokerLogic}
            target_joker.ability.extra_value = (card.ability.extra_value or 0) + ${valueCode}
            target_joker:set_cost()`;
  }
  else if (target === "all_jokers") {
    sellValueCode += `
            for i, other_card in ipairs(G.jokers.cards) do
                if other_card.set_cost then
                    other_card.ability.extra_value = (other_card.ability.extra_value) + ${valueCode}
                    other_card:set_cost()
                end
            end`;
  } else if (target === "all") {
    sellValueCode += `
            for _, area in ipairs({ G.jokers, G.consumeables }) do
                for i, other_card in ipairs(area.cards) do
                    if other_card.set_cost then
                        other_card.ability.extra_value = (other_card.ability.extra_value) + ${valueCode}
                        other_card:set_cost()
                    end
                end
            end`;
  }

  const result: EffectReturn = {
    statement: isScoring
      ? `__PRE_RETURN_CODE__${sellValueCode}
                __PRE_RETURN_CODE_END__`
      : `func = function()${sellValueCode}
                    return true
                end`,
    message: customMessage ? `"${customMessage}"` : `localize('k_val_up')`,
    colour: "G.C.MONEY",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\AddSpectralCardEffect.ts

```
//! DEPRECIATED FILE

import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { SPECTRAL_CARDS } from "../../../data/BalatroUtils";

export const generateAddSpectralCardReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const spectralCard = (effect.params?.spectral_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let spectralCreationCode = "";

  if (spectralCard === "random") {
    if (isNegative) {
      spectralCreationCode = `local created_spectral = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local spectral_card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'joker_forge_spectral')
                        spectral_card:set_edition("e_negative", true)
                        spectral_card:add_to_deck()
                        G.consumeables:emplace(spectral_card)
                        return true
                    end
                }))`;
    } else {
      spectralCreationCode = `local created_spectral = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_spectral = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local spectral_card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, nil, 'joker_forge_spectral')
                            spectral_card:add_to_deck()
                            G.consumeables:emplace(spectral_card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  } else {
    // Check if the spectralCard exists in SPECTRAL_CARDS, otherwise fallback to c_familiar
    const spectralCardData = SPECTRAL_CARDS.find(
      (card) => card.key === spectralCard
    );
    const spectralKey = spectralCardData ? spectralCard : "c_familiar";

    if (isNegative) {
      spectralCreationCode = `local created_spectral = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local spectral_card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, '${spectralKey}')
                        spectral_card:set_edition("e_negative", true)
                        spectral_card:add_to_deck()
                        G.consumeables:emplace(spectral_card)
                        return true
                    end
                }))`;
    } else {
      spectralCreationCode = `local created_spectral = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_spectral = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local spectral_card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, '${spectralKey}')
                            spectral_card:add_to_deck()
                            G.consumeables:emplace(spectral_card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${spectralCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_spectral and localize('k_plus_spectral') or nil`,
      colour: "G.C.SECONDARY_SET.Spectral",
    };
  } else {
    return {
      statement: `func = function()${spectralCreationCode}
                    if created_spectral then
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                          customMessage
                            ? `"${customMessage}"`
                            : `localize('k_plus_spectral')`
                        }, colour = G.C.SECONDARY_SET.Spectral})
                    end
                    return true
                end`,
      colour: "G.C.SECONDARY_SET.Spectral",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\AddTarotCardEffect.ts

```
//! DEPRECIATED FILE

import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { TAROT_CARDS } from "../../../data/BalatroUtils";

export const generateAddTarotCardReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const tarotCard = (effect.params?.tarot_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let tarotCreationCode = "";
  let tarotKey = "";

  if (tarotCard === "random") {
    tarotKey = "nil, nil, nil, nil, nil, 'joker_forge_tarot'";
  } else {
    // Check if the tarotCard exists in TAROT_CARDS, otherwise fallback to c_fool
    const tarotCardData = TAROT_CARDS.find((card) => card.key === tarotCard);
    const specificKey = tarotCardData ? tarotCard : "c_fool";
    tarotKey = `nil, nil, nil, nil, '${specificKey}'`;
  }

  if (isNegative) {
    tarotCreationCode = `local created_tarot = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local tarot_card = create_card('Tarot', G.consumeables, ${tarotKey})
                        tarot_card:set_edition("e_negative", true)
                        tarot_card:add_to_deck()
                        G.consumeables:emplace(tarot_card)
                        return true
                    end
                }))`;
  } else {
    tarotCreationCode = `local created_tarot = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_tarot = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local tarot_card = create_card('Tarot', G.consumeables, ${tarotKey})
                            tarot_card:add_to_deck()
                            G.consumeables:emplace(tarot_card)
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${tarotCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_tarot and localize('k_plus_tarot') or nil`,
      colour: "G.C.PURPLE",
    };
  } else {
    return {
      statement: `func = function()${tarotCreationCode}
                    if created_tarot then
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                          customMessage
                            ? `"${customMessage}"`
                            : `localize('k_plus_tarot')`
                        }, colour = G.C.PURPLE})
                    end
                    return true
                end`,
      colour: "G.C.PURPLE",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\AllowDebtEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generatePassiveAllowDebt = (
  effect: Effect
): PassiveEffectResult => {
  const variableName = "debt_amount";

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const addToDeck = `G.GAME.bankrupt_at = G.GAME.bankrupt_at - ${valueCode}`;
  const removeFromDeck = `G.GAME.bankrupt_at = G.GAME.bankrupt_at + ${valueCode}`;

  return {
    addToDeck,
    removeFromDeck,
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => cv.name + " = " + cv.value)
        : [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\ApplyExpChipsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateApplyExpChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "echips" : `echips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `e_chips = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ApplyExpMultEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateApplyExpMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "emult" : `emult${sameTypeCount + 1}`;

  const customMessage = effect.customMessage;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const result: EffectReturn = {
    statement: `e_mult = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ApplyHyperChipsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateApplyHyperChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableNameN =
    sameTypeCount === 0 ? "hyperchips_n" : `hyperchips_n${sameTypeCount + 1}`;
  
    const variableNameArrows =
    sameTypeCount === 0 ? "hyperchips_arrows" : `hyperchips_arrows${sameTypeCount + 1}`;

  const N = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableNameN
  )
  
  const Arrows = generateConfigVariables(
    effect.params?.arrows,
    effect.id,
    variableNameArrows
  )

  const customMessage = effect.customMessage;

  const configVariables = [...N.configVariables, ...Arrows.configVariables]

  const result: EffectReturn = {
    statement: `hyperchips = {
    ${Arrows.valueCode},
    ${N.valueCode}
}`,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ApplyHyperMultEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateApplyHyperMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableNameN =
    sameTypeCount === 0 ? "hypermult_n" : `hypermult_n${sameTypeCount + 1}`;
  
    const variableNameArrows =
    sameTypeCount === 0 ? "hypermult_arrows" : `hypermult_arrows${sameTypeCount + 1}`;

  const N = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableNameN
  )
  
  const Arrows = generateConfigVariables(
    effect.params?.arrows,
    effect.id,
    variableNameArrows
  )

  const customMessage = effect.customMessage;

  const configVariables = [...N.configVariables, ...Arrows.configVariables]

  const result: EffectReturn = {
    statement: `hypermult = {
    ${Arrows.valueCode},
    ${N.valueCode}
}`,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ApplyXChipsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateApplyXChipsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "xchips" : `xchips${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `x_chips = ${valueCode}`,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ApplyXMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateApplyXMultReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "Xmult" : `Xmult${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `Xmult = ${valueCode}`,
    colour: "",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\BalanceEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateBalanceReturn = (effect: Effect): EffectReturn => {
  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `balance = true`,
    colour: "G.C.PURPLE",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\BeatCurrentBlindEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateBeatCurrentBlindReturn = (
  effect: Effect,
): EffectReturn => {
  const customMessage = effect.customMessage;
  const beatCode = `
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                delay = 0.5,
                func = function()
                    G.GAME.chips = G.GAME.blind.chips
                    G.STATE = G.STATES.HAND_PLAYED
                        G.STATE_COMPLETE = true
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                            customMessage
                                ? `"${customMessage}"`
                                : `"Beaten"`
                            }, colour = G.C.RED})
                    return true
                end,
            }))
            `;
            
    return {
        statement: `func = function()${beatCode}
                    return true
                end`,
        colour: "G.C.GREEN",
    };
};
```

### src\components\codeGeneration\Jokers\effects\ChangePokerHandVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateChangePokerHandVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName =
    (effect.params.variable_name as string) || "pokerhandvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificPokerHand =
    (effect.params.specific_pokerhand as string) || "High Card";

  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hands = {}
                for handname, _ in pairs(G.GAME.hands) do
                    if G.GAME.hands[handname].visible then
                        ${variableName}_hands[#${variableName}_hands + 1] = handname
                    end
                end
                if ${variableName}_hands[1] then
                    G.GAME.current_round.${variableName}_hand = pseudorandom_element(${variableName}_hands, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                end
                __PRE_RETURN_CODE_END__`;
  } else if (changeType === "most_played") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hand, ${variableName}_tally = nil, 0
                for k, v in ipairs(G.handlist) do
                    if G.GAME.hands[v].visible and G.GAME.hands[v].played > ${variableName}_tally then
                        ${variableName}_hand = v
                        ${variableName}_tally = G.GAME.hands[v].played
                    end
                end
                if ${variableName}_hand then
                    G.GAME.current_round.${variableName}_hand = ${variableName}_hand
                end
                __PRE_RETURN_CODE_END__`;
  } else if (changeType === "least_played") {
    statement = `__PRE_RETURN_CODE__
                local ${variableName}_hand, ${variableName}_tally = nil, math.huge
                for k, v in ipairs(G.handlist) do
                    if G.GAME.hands[v].visible and G.GAME.hands[v].played < ${variableName}_tally then
                        ${variableName}_hand = v
                        ${variableName}_tally = G.GAME.hands[v].played
                    end
                end
                if ${variableName}_hand then
                    G.GAME.current_round.${variableName}_hand = ${variableName}_hand
                end
                __PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__
                G.GAME.current_round.${variableName}_hand = '${specificPokerHand}'
                __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ChangeRankVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { getRankId } from "../../../data/BalatroUtils";
import { EffectReturn } from "../effectUtils";

export const generateChangeRankVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName = (effect.params.variable_name as string) || "rankvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificRank = (effect.params.specific_rank as string) || "A";
  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                    if G.playing_cards then
                        local valid_${variableName}_cards = {}
                        for _, v in ipairs(G.playing_cards) do
                            if not SMODS.has_no_rank(v) then
                                valid_${variableName}_cards[#valid_${variableName}_cards + 1] = v
                            end
                        end
                        if valid_${variableName}_cards[1] then
                            local ${variableName}_card = pseudorandom_element(valid_${variableName}_cards, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                            G.GAME.current_round.${variableName}_card.rank = ${variableName}_card.base.value
                            G.GAME.current_round.${variableName}_card.id = ${variableName}_card.base.id
                        end
                    end
                    __PRE_RETURN_CODE_END__`;
  } else {
    const rankId = getRankId(specificRank);
    statement = `__PRE_RETURN_CODE__
                    G.GAME.current_round.${variableName}_card.rank = '${specificRank}'
                    G.GAME.current_round.${variableName}_card.id = ${rankId}
                    __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ChangeSuitVariableEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateChangeSuitVariableReturn = (
  effect: Effect
): EffectReturn => {
  const variableName = (effect.params.variable_name as string) || "suitvar";
  const changeType = (effect.params.change_type as string) || "random";
  const specificSuit = (effect.params.specific_suit as string) || "Spades";

  let statement = "";

  if (changeType === "random") {
    statement = `__PRE_RETURN_CODE__
                if G.playing_cards then
                    local valid_${variableName}_cards = {}
                    for _, v in ipairs(G.playing_cards) do
                        if not SMODS.has_no_suit(v) then
                            valid_${variableName}_cards[#valid_${variableName}_cards + 1] = v
                        end
                    end
                    if valid_${variableName}_cards[1] then
                        local ${variableName}_card = pseudorandom_element(valid_${variableName}_cards, pseudoseed('${variableName}' .. G.GAME.round_resets.ante))
                        G.GAME.current_round.${variableName}_card.suit = ${variableName}_card.base.suit
                    end
                end
                __PRE_RETURN_CODE_END__`;
  } else {
    statement = `__PRE_RETURN_CODE__
                G.GAME.current_round.${variableName}_card.suit = '${specificSuit}'
                __PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: "G.C.FILTER",
  };

  if (effect.customMessage) {
    result.message = effect.customMessage;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\CombineRanksEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import { getRankId } from "../../../data/BalatroUtils";

export const generatePassiveCombineRanks = (
  effect: Effect,
  jokerKey?: string
): PassiveEffectResult => {
  const sourceRankType =
    (effect.params?.source_rank_type as string) || "specific";
  const sourceRanksString = (effect.params?.source_ranks as string) || "J,Q,K";
  const targetRank = (effect.params?.target_rank as string) || "J";
  const sourceRanks =
    sourceRankType === "specific"
      ? sourceRanksString.split(",").map((rank) => rank.trim())
      : [];
  return {
    addToDeck: `-- Combine ranks effect enabled`,
    removeFromDeck: `-- Combine ranks effect disabled`,
    configVariables: [
      `source_rank_type = "${sourceRankType}"`,
      ...(sourceRankType === "specific"
        ? [
            `source_ranks = {${sourceRanks
              .map((rank) => `"${rank}"`)
              .join(", ")}}`,
          ]
        : []),
      `target_rank = "${targetRank}"`,
    ],
    locVars: [],
    needsHook: {
      hookType: "combine_ranks",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {
        sourceRankType,
        sourceRanks,
        targetRank,
      },
    },
  };
};

export const generateCombineRanksHook = (
  combineRanksJokers: Array<{
    jokerKey: string;
    params: {
      sourceRankType: string;
      sourceRanks: string[];
      targetRank: string;
    };
  }>,
  modPrefix: string
): string => {
  if (combineRanksJokers.length === 0) return "";

  let hookCode = "";

  // Check if any joker targets face_cards - if so, hook Card.is_face
  const faceCardJokers = combineRanksJokers.filter(
    ({ params }) => params.targetRank === "face_cards"
  );
  if (faceCardJokers.length > 0) {
    hookCode += `
local card_is_face_ref = Card.is_face
function Card:is_face(from_boss)
    local original_result = card_is_face_ref(self, from_boss)
    if original_result then return true end
    
    local card_id = self:get_id()
    if not card_id then return false end
`;
    faceCardJokers.forEach(({ jokerKey, params }) => {
      const fullJokerKey = `j_${modPrefix}_${jokerKey}`;
      hookCode += `
    if next(SMODS.find_card("${fullJokerKey}")) then`;
      if (params.sourceRankType === "all") {
        hookCode += `
        return true`;
      } else if (params.sourceRankType === "face_cards") {
        hookCode += `
        if card_id >= 11 and card_id <= 13 then return true end`;
      } else if (params.sourceRankType === "specific") {
        const sourceIds = params.sourceRanks.map((rank) => getRankId(rank));
        hookCode += `
        local source_ids = {${sourceIds.join(", ")}}
        for _, source_id in pairs(source_ids) do
            if card_id == source_id then return true end
        end`;
      }
      hookCode += `
    end`;
    });
    hookCode += `
    return false
end
`;
  }

  // For non-face_cards targets, hook Card:get_id
  const nonFaceCardJokers = combineRanksJokers.filter(
    ({ params }) => params.targetRank !== "face_cards"
  );
  if (nonFaceCardJokers.length > 0) {
    hookCode += `
local card_get_id_ref = Card.get_id
function Card:get_id()
    local original_id = card_get_id_ref(self)
    if not original_id then return original_id end
`;
    nonFaceCardJokers.forEach(({ jokerKey, params }) => {
      const fullJokerKey = `j_${modPrefix}_${jokerKey}`;
      const targetId = getRankId(params.targetRank);
      hookCode += `
    if next(SMODS.find_card("${fullJokerKey}")) then`;
      if (params.sourceRankType === "all") {
        hookCode += `
        return ${targetId}`;
      } else if (params.sourceRankType === "face_cards") {
        hookCode += `
        if original_id >= 11 and original_id <= 13 then return ${targetId} end`;
      } else if (params.sourceRankType === "specific") {
        const sourceIds = params.sourceRanks.map((rank) => getRankId(rank));
        hookCode += `
        local source_ids = {${sourceIds.join(", ")}}
        for _, source_id in pairs(source_ids) do
            if original_id == source_id then return ${targetId} end
        end`;
      }
      hookCode += `
    end`;
    });
    hookCode += `
    return original_id
end
`;
  }

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\CombineSuitsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";

export const generatePassiveCombineSuits = (
  effect: Effect,
  jokerKey?: string
): PassiveEffectResult => {
  const suit1 = (effect.params?.suit_1 as string) || "Spades";
  const suit2 = (effect.params?.suit_2 as string) || "Hearts";

  return {
    addToDeck: `-- Combine suits effect enabled`,
    removeFromDeck: `-- Combine suits effect disabled`,
    configVariables: [],
    locVars: [],
    needsHook: {
      hookType: "combine_suits",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {
        suit1,
        suit2,
      },
    },
  };
};

export const generateCombineSuitsHook = (
  combineSuitsJokers: Array<{
    jokerKey: string;
    params: {
      suit1: string;
      suit2: string;
    };
  }>,
  modPrefix: string
): string => {
  if (combineSuitsJokers.length === 0) return "";

  // Group effects by joker key
  const jokerGroups = new Map<
    string,
    Array<{ suit1: string; suit2: string }>
  >();

  combineSuitsJokers.forEach(({ jokerKey, params }) => {
    if (!jokerGroups.has(jokerKey)) {
      jokerGroups.set(jokerKey, []);
    }
    jokerGroups
      .get(jokerKey)!
      .push({ suit1: params.suit1, suit2: params.suit2 });
  });

  let hookCode = `
local card_is_suit_ref = Card.is_suit
function Card:is_suit(suit, bypass_debuff, flush_calc)
    local ret = card_is_suit_ref(self, suit, bypass_debuff, flush_calc)
    if not ret and not SMODS.has_no_suit(self) then`;

  jokerGroups.forEach((effects, jokerKey) => {
    const fullJokerKey = `j_${modPrefix}_${jokerKey}`;

    hookCode += `
        if next(SMODS.find_card("${fullJokerKey}")) then`;

    effects.forEach(({ suit1, suit2 }) => {
      hookCode += `
            -- If checking for ${suit1} and card is ${suit2}, return true
            if suit == "${suit1}" and self.base.suit == "${suit2}" then
                ret = true
            end
            -- If checking for ${suit2} and card is ${suit1}, return true
            if suit == "${suit2}" and self.base.suit == "${suit1}" then
                ret = true
            end`;
    });

    hookCode += `
        end`;
  });

  hookCode += `
    end
    return ret
end`;

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\ConsideredAsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";

export interface ConsideredAsResult {
  calculateFunction: string;
  configVariables: string[];
  locVars: string[];
}

export const generatePassiveConsideredAs = (
  effect: Effect
): ConsideredAsResult => {
  const sourceType = (effect.params?.source_type as string) || "enhancement";
  const sourceValue = (effect.params?.source_value as string) || "m_gold";
  const targetType = (effect.params?.target_type as string) || "enhancement";
  const targetValue = (effect.params?.target_value as string) || "m_steel";

  const generateSourceCheck = (): string => {
    switch (sourceType) {
      case "rank": {
        const rankId =
          sourceValue === "A"
            ? "14"
            : sourceValue === "K"
            ? "13"
            : sourceValue === "Q"
            ? "12"
            : sourceValue === "J"
            ? "11"
            : sourceValue;
        return `context.other_card:get_id() == ${rankId}`;
      }

      case "suit":
        if (sourceValue === "red") {
          return `(context.other_card:is_suit("Hearts") or context.other_card:is_suit("Diamonds"))`;
        } else if (sourceValue === "black") {
          return `(context.other_card:is_suit("Spades") or context.other_card:is_suit("Clubs"))`;
        } else {
          return `context.other_card:is_suit("${sourceValue}")`;
        }

      case "enhancement":
        return `context.other_card.config.center.key == "${sourceValue}"`;

      case "seal":
        if (sourceValue === "any") {
          return `context.other_card.seal ~= nil`;
        } else if (sourceValue === "none") {
          return `context.other_card.seal == nil`;
        } else {
          return `context.other_card.seal == "${sourceValue}"`;
        }

      case "edition":
        if (sourceValue === "any") {
          return `context.other_card.edition ~= nil`;
        } else if (sourceValue === "none") {
          return `context.other_card.edition == nil`;
        } else {
          return `context.other_card.edition and context.other_card.edition.key == "${sourceValue}"`;
        }

      default:
        return "false";
    }
  };

  // Generate the return value based on target type
  const generateTargetReturn = (): string => {
    switch (targetType) {
      case "enhancement":
        return `${targetValue} = true`;

      case "seal":
        // For seals  need to temporarily mark cards and handle in a different context
        // This is a simplified approach full implementation would be more complex
        return `-- Seal: ${targetValue} = true`;

      case "edition":
        // For editions, similar approach needed
        return `-- Edition: ${targetValue} = true`;

      default:
        return `${targetValue} = true`;
    }
  };

  const sourceCheck = generateSourceCheck();
  const targetReturn = generateTargetReturn();

  // Generate the calculate function
  // May need to be changed later because of the passive rework. (what i mean is removing the `calculate = function(self, card, context)`)
  const calculateFunction = `calculate = function(self, card, context)
        if context.check_enhancement then
            if ${sourceCheck} then
                return {
                    ${targetReturn}
                }
            end
        end
    end`;

  return {
    calculateFunction,
    configVariables: [
      `source_type = "${sourceType}"`,
      `source_value = "${sourceValue}"`,
      `target_type = "${targetType}"`,
      `target_value = "${targetValue}"`,
    ],
    locVars: [
      `card.ability.extra.source_type`,
      `card.ability.extra.source_value`,
      `card.ability.extra.target_type`,
      `card.ability.extra.target_value`,
    ],
  };
};

```

### src\components\codeGeneration\Jokers\effects\CopyCardToDeckEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { getRankId } from "../../../data/BalatroUtils";

export const generateCopyCardToDeckReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const customMessage = effect.customMessage;
  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  if (effect.type === "copy_triggered_card") {
    if (isScoring) {
      return {
        statement: `__PRE_RETURN_CODE__
                G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                local copied_card = copy_card(context.other_card, nil, nil, G.playing_card)
                copied_card:add_to_deck()
                G.deck.config.card_limit = G.deck.config.card_limit + 1
                G.deck:emplace(copied_card)
                table.insert(G.playing_cards, copied_card)
                playing_card_joker_effects({true})
                
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        copied_card:start_materialize()
                        return true
                    end
                }))
                __PRE_RETURN_CODE_END__`,
        message: customMessage ? `"${customMessage}"` : `"Copied Card!"`,
        colour: "G.C.GREEN",
      };
    } else {
      return {
        statement: `func = function()
                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                        local copied_card = copy_card(context.other_card, nil, nil, G.playing_card)
                        copied_card:add_to_deck()
                        G.deck.config.card_limit = G.deck.config.card_limit + 1
                        G.deck:emplace(copied_card)
                        table.insert(G.playing_cards, copied_card)
                        playing_card_joker_effects({true})
                        
                        G.E_MANAGER:add_event(Event({
                            func = function()
                                copied_card:start_materialize()
                                return true
                            end
                        }))
                    end`,
        message: customMessage ? `"${customMessage}"` : `"Copied Card!"`,
        colour: "G.C.GREEN",
      };
    }
  }

  if (effect.type === "copy_played_card") {
    const cardIndex = (effect.params?.card_index as string) || "any";
    const cardRank = (effect.params?.card_rank as string) || "any";
    const cardSuit = (effect.params?.card_suit as string) || "any";

    const cardSelectionCode = generateCardSelectionLogic(
      cardIndex,
      cardRank,
      cardSuit
    );

    if (isScoring) {
      return {
        statement: `__PRE_RETURN_CODE__
                ${cardSelectionCode}
                
                for i, source_card in ipairs(cards_to_copy) do
                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                    local copied_card = copy_card(source_card, nil, nil, G.playing_card)
                    copied_card:add_to_deck()
                    G.deck.config.card_limit = G.deck.config.card_limit + 1
                    G.deck:emplace(copied_card)
                    table.insert(G.playing_cards, copied_card)
                    playing_card_joker_effects({true})
                    
                    G.E_MANAGER:add_event(Event({
                        func = function() 
                            copied_card:start_materialize()
                            return true
                        end
                    }))
                end
                __PRE_RETURN_CODE_END__`,
        message: customMessage ? `"${customMessage}"` : `"Copied Cards!"`,
        colour: "G.C.GREEN",
      };
    } else {
      return {
        statement: `func = function()
                        ${cardSelectionCode}
                        
                        for i, source_card in ipairs(cards_to_copy) do
                            G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                            local copied_card = copy_card(source_card, nil, nil, G.playing_card)
                            copied_card:add_to_deck()
                            G.deck.config.card_limit = G.deck.config.card_limit + 1
                            G.deck:emplace(copied_card)
                            table.insert(G.playing_cards, copied_card)
                            playing_card_joker_effects({true})
                            
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    copied_card:start_materialize()
                                    return true
                                end
                            }))
                        end
                    end`,
        message: customMessage ? `"${customMessage}"` : `"Copied Cards!"`,
        colour: "G.C.GREEN",
      };
    }
  }

  return {
    statement: `message = "No Card to Copy"`,
    colour: "G.C.RED",
  };
};

const generateCardSelectionLogic = (
  cardIndex: string,
  cardRank: string,
  cardSuit: string
): string => {
  const conditions: string[] = [];

  if (cardRank !== "any") {
    conditions.push(`c:get_id() == ${getRankId(cardRank)}`);
  }

  if (cardSuit !== "any") {
    conditions.push(`c:is_suit("${cardSuit}")`);
  }

  if (cardIndex === "any") {
    if (conditions.length === 0) {
      return `
                local cards_to_copy = {}
                for i, c in ipairs(context.full_hand) do
                    table.insert(cards_to_copy, c)
                end`;
    } else {
      const filterCondition = conditions.join(" and ");
      return `
                local cards_to_copy = {}
                for i, c in ipairs(context.full_hand) do
                    if ${filterCondition} then
                        table.insert(cards_to_copy, c)
                    end
                end`;
    }
  } else {
    if (conditions.length === 0) {
      return `
                local cards_to_copy = {}
                local target_index = ${cardIndex}
                if context.full_hand[target_index] then
                    table.insert(cards_to_copy, context.full_hand[target_index])
                end`;
    } else {
      const filterCondition = conditions.join(" and ");
      return `
                local cards_to_copy = {}
                local target_index = ${cardIndex}
                if context.full_hand[target_index] then
                    local c = context.full_hand[target_index]
                    if ${filterCondition} then
                        table.insert(cards_to_copy, c)
                    end
                end`;
    }
  }
};

```

### src\components\codeGeneration\Jokers\effects\CopyCardToHandEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { getRankId } from "../../../data/BalatroUtils";

export const generateCopyCardToHandReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const customMessage = effect.customMessage;
  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  if (effect.type === "copy_triggered_card_to_hand") {
    if (isScoring) {
      return {
        statement: `__PRE_RETURN_CODE__
                G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                local copied_card = copy_card(context.other_card, nil, nil, G.playing_card)
                copied_card:add_to_deck()
                G.deck.config.card_limit = G.deck.config.card_limit + 1
                table.insert(G.playing_cards, copied_card)
                G.hand:emplace(copied_card)
                copied_card.states.visible = nil
                
                G.E_MANAGER:add_event(Event({
                    func = function() 
                        copied_card:start_materialize()
                        return true
                    end
                }))
                __PRE_RETURN_CODE_END__`,
        message: customMessage
          ? `"${customMessage}"`
          : `"Copied Card to Hand!"`,
        colour: "G.C.GREEN",
      };
    } else {
      return {
        statement: `func = function()
                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                        local copied_card = copy_card(context.other_card, nil, nil, G.playing_card)
                        copied_card:add_to_deck()
                        G.deck.config.card_limit = G.deck.config.card_limit + 1
                        table.insert(G.playing_cards, copied_card)
                        G.hand:emplace(copied_card)
                        copied_card.states.visible = nil
                        
                        G.E_MANAGER:add_event(Event({
                            func = function()
                                copied_card:start_materialize()
                                return true
                            end
                        }))
                        
                        G.E_MANAGER:add_event(Event({
                            func = function()
                                SMODS.calculate_context({ playing_card_added = true, cards = { copied_card } })
                                return true
                            end
                        }))
                    end`,
        message: customMessage
          ? `"${customMessage}"`
          : `"Copied Card to Hand!"`,
        colour: "G.C.GREEN",
      };
    }
  }

  if (effect.type === "copy_played_card_to_hand") {
    const cardIndex = (effect.params?.card_index as string) || "any";
    const cardRank = (effect.params?.card_rank as string) || "any";
    const cardSuit = (effect.params?.card_suit as string) || "any";

    const cardSelectionCode = generateCardSelectionLogic(
      cardIndex,
      cardRank,
      cardSuit
    );

    if (isScoring) {
      return {
        statement: `__PRE_RETURN_CODE__
                ${cardSelectionCode}
                
                for i, source_card in ipairs(cards_to_copy) do
                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                    local copied_card = copy_card(source_card, nil, nil, G.playing_card)
                    copied_card:add_to_deck()
                    G.deck.config.card_limit = G.deck.config.card_limit + 1
                    table.insert(G.playing_cards, copied_card)
                    G.hand:emplace(copied_card)
                    copied_card.states.visible = nil
                    
                    G.E_MANAGER:add_event(Event({
                        func = function() 
                            copied_card:start_materialize()
                            return true
                        end
                    }))
                end
                __PRE_RETURN_CODE_END__`,
        message: customMessage
          ? `"${customMessage}"`
          : `"Copied Cards to Hand!"`,
        colour: "G.C.GREEN",
      };
    } else {
      return {
        statement: `func = function()
                        ${cardSelectionCode}
                        
                        for i, source_card in ipairs(cards_to_copy) do
                            G.playing_card = (G.playing_card and G.playing_card + 1) or 1
                            local copied_card = copy_card(source_card, nil, nil, G.playing_card)
                            copied_card:add_to_deck()
                            G.deck.config.card_limit = G.deck.config.card_limit + 1
                            table.insert(G.playing_cards, copied_card)
                            G.hand:emplace(copied_card)
                            copied_card.states.visible = nil
                            
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    copied_card:start_materialize()
                                    return true
                                end
                            }))
                            
                            G.E_MANAGER:add_event(Event({
                                func = function()
                                    SMODS.calculate_context({ playing_card_added = true, cards = { copied_card } })
                                    return true
                                end
                            }))
                        end
                    end`,
        message: customMessage
          ? `"${customMessage}"`
          : `"Copied Cards to Hand!"`,
        colour: "G.C.GREEN",
      };
    }
  }

  return {
    statement: `message = "No Card to Copy"`,
    colour: "G.C.RED",
  };
};

const generateCardSelectionLogic = (
  cardIndex: string,
  cardRank: string,
  cardSuit: string
): string => {
  const conditions: string[] = [];

  if (cardRank !== "any") {
    conditions.push(`c:get_id() == ${getRankId(cardRank)}`);
  }

  if (cardSuit !== "any") {
    conditions.push(`c:is_suit("${cardSuit}")`);
  }

  if (cardIndex === "any") {
    if (conditions.length === 0) {
      return `
                local cards_to_copy = {}
                for i, c in ipairs(context.full_hand) do
                    table.insert(cards_to_copy, c)
                end`;
    } else {
      const filterCondition = conditions.join(" and ");
      return `
                local cards_to_copy = {}
                for i, c in ipairs(context.full_hand) do
                    if ${filterCondition} then
                        table.insert(cards_to_copy, c)
                    end
                end`;
    }
  } else {
    if (conditions.length === 0) {
      return `
                local cards_to_copy = {}
                local target_index = ${cardIndex}
                if context.full_hand[target_index] then
                    table.insert(cards_to_copy, context.full_hand[target_index])
                end`;
    } else {
      const filterCondition = conditions.join(" and ");
      return `
                local cards_to_copy = {}
                local target_index = ${cardIndex}
                if context.full_hand[target_index] then
                    local c = context.full_hand[target_index]
                    if ${filterCondition} then
                        table.insert(cards_to_copy, c)
                    end
                end`;
    }
  }
};

```

### src\components\codeGeneration\Jokers\effects\CopyConsumableEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

const TAROT_CARD_KEYS: Record<string, string> = {
  the_fool: "c_fool",
  the_magician: "c_magician",
  the_high_priestess: "c_high_priestess",
  the_empress: "c_empress",
  the_emperor: "c_emperor",
  the_hierophant: "c_hierophant",
  the_lovers: "c_lovers",
  the_chariot: "c_chariot",
  justice: "c_justice",
  the_hermit: "c_hermit",
  the_wheel_of_fortune: "c_wheel_of_fortune",
  strength: "c_strength",
  the_hanged_man: "c_hanged_man",
  death: "c_death",
  temperance: "c_temperance",
  the_devil: "c_devil",
  the_tower: "c_tower",
  the_star: "c_star",
  the_moon: "c_moon",
  the_sun: "c_sun",
  judgement: "c_judgement",
  the_world: "c_world",
};

const PLANET_CARD_KEYS: Record<string, string> = {
  pluto: "c_pluto",
  mercury: "c_mercury",
  uranus: "c_uranus",
  venus: "c_venus",
  saturn: "c_saturn",
  jupiter: "c_jupiter",
  earth: "c_earth",
  mars: "c_mars",
  neptune: "c_neptune",
  planet_x: "c_planet_x",
  ceres: "c_ceres",
  eris: "c_eris",
};

const SPECTRAL_CARD_KEYS: Record<string, string> = {
  familiar: "c_familiar",
  grim: "c_grim",
  incantation: "c_incantation",
  talisman: "c_talisman",
  aura: "c_aura",
  wraith: "c_wraith",
  sigil: "c_sigil",
  ouija: "c_ouija",
  ectoplasm: "c_ectoplasm",
  immolate: "c_immolate",
  ankh: "c_ankh",
  deja_vu: "c_deja_vu",
  hex: "c_hex",
  trance: "c_trance",
  medium: "c_medium",
  cryptid: "c_cryptid",
  the_soul: "c_soul",
  black_hole: "c_black_hole",
};

export const generateCopyConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const consumableType = (effect.params?.consumable_type as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) === "negative";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let copyCode = "";

  if (consumableType === "random") {
    const slotCheck = isNegative
      ? ""
      : "and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit";
    const bufferCode = isNegative
      ? ""
      : "G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1";
    const bufferReset = isNegative ? "" : "G.GAME.consumeable_buffer = 0";
    const negativeSetCode = isNegative
      ? `
                        copied_card:set_edition("e_negative", true)`
      : "";
    const messageText = customMessage
      ? `"${customMessage}"`
      : `"Copied Consumable!"`;

    copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                table.insert(target_cards, consumable)
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
  } else {
    let cardKeys: string[] = [];
    let setName = "";

    if (consumableType === "tarot") {
      setName = "Tarot";
      if (specificCard === "random") {
        cardKeys = Object.values(TAROT_CARD_KEYS);
      } else {
        cardKeys = [TAROT_CARD_KEYS[specificCard] || "c_fool"];
      }
    } else if (consumableType === "planet") {
      setName = "Planet";
      if (specificCard === "random") {
        cardKeys = Object.values(PLANET_CARD_KEYS);
      } else {
        cardKeys = [PLANET_CARD_KEYS[specificCard] || "c_pluto"];
      }
    } else if (consumableType === "spectral") {
      setName = "Spectral";
      if (specificCard === "random") {
        cardKeys = Object.values(SPECTRAL_CARD_KEYS);
      } else {
        cardKeys = [SPECTRAL_CARD_KEYS[specificCard] || "c_familiar"];
      }
    }

    const slotCheck = isNegative
      ? ""
      : "and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit";
    const bufferCode = isNegative
      ? ""
      : "G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1";
    const bufferReset = isNegative ? "" : "G.GAME.consumeable_buffer = 0";
    const negativeSetCode = isNegative
      ? `
                        copied_card:set_edition("e_negative", true)`
      : "";
    const messageText = customMessage
      ? `"${customMessage}"`
      : `"Copied Consumable!"`;

    if (specificCard === "random") {
      copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${setName}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
    } else {
      const targetKey = cardKeys[0];
      copyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${setName}" and consumable.config.center.key == "${targetKey}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 ${slotCheck} then
                local card_to_copy = pseudorandom_element(target_cards, pseudoseed('copy_consumable'))
                ${bufferCode}
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local copied_card = copy_card(card_to_copy)${negativeSetCode}
                        copied_card:add_to_deck()
                        G.consumeables:emplace(copied_card)
                        ${bufferReset}
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.GREEN})
            end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${copyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()${copyCode}
                    return true
                end`,
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\CopyJokerAbilityEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";

export const generatePassiveCopyJokerAbility = (
  effect: Effect
): PassiveEffectResult => {
  const selectionMethod =
    (effect.params?.selection_method as string) || "right";
  const specificIndex = (effect.params?.specific_index as number) || 1;

  let targetJokerLogic = "";

  switch (selectionMethod) {
    case "right":
      targetJokerLogic = `local my_pos = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                my_pos = i
                break
            end
        end
        target_joker = (my_pos and my_pos < #G.jokers.cards) and G.jokers.cards[my_pos + 1] or nil`;
      break;

    case "left":
      targetJokerLogic = `local my_pos = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                my_pos = i
                break
            end
        end
        target_joker = (my_pos and my_pos > 1) and G.jokers.cards[my_pos - 1] or nil`;
      break;

    case "specific":
      targetJokerLogic = `target_joker = G.jokers.cards[${specificIndex}]
        if target_joker == card then
            target_joker = nil
        end`;
      break;
  }

  const calculateFunction = `
        local target_joker = nil
        
        ${targetJokerLogic}
        
        local ret = SMODS.blueprint_effect(card, target_joker, context)
        if ret then
            SMODS.calculate_effect(ret, card)
        end`;

  return {
    calculateFunction,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\CopyJokerEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateCopyJokerReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const selectionMethod =
    (effect.params?.selection_method as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const position = (effect.params?.position as string) || "first";
  const specificIndex = effect.params?.specific_index as number;
  const edition = (effect.params?.edition as string) || "none";
  const customMessage = effect.customMessage;
  const ignoreSlotsParam = (effect.params?.ignore_slots as string) || "respect"
  const sticker = (effect.params?.sticker as string) || "none"

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  const isNegative = edition === "e_negative";
  const hasEdition = edition !== "none";
  const ignoreSlots = ignoreSlotsParam === "ignore"
  const hasSticker = sticker !== "none";

  let jokerSelectionCode = "";
  let spaceCheckCode = "";
  let copyCode = "";

  const normalizedJokerKey = jokerKey.startsWith("j_") 
  ? jokerKey 
  : `j_${jokerKey}`

  // Generate joker selection logic
  if (selectionMethod === "specific" && normalizedJokerKey) {
    jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if joker.config.center.key == "${normalizedJokerKey}" then
                        target_joker = joker
                        break
                    end
                end`;
  } else if (selectionMethod === "position") {
    if (position === "first") {
      jokerSelectionCode = `
                local target_joker = G.jokers.cards[1] or nil`;
    } else if (position === "last") {
      jokerSelectionCode = `
                local target_joker = G.jokers.cards[#G.jokers.cards] or nil`;
    } else if (position === "left") {
      jokerSelectionCode = `
                local my_pos = nil
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] == card then
                        my_pos = i
                        break
                    end
                end
                local target_joker = (my_pos and my_pos > 1) and G.jokers.cards[my_pos - 1] or nil`;
    } else if (position === "right") {
      jokerSelectionCode = `
                local my_pos = nil
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] == card then
                        my_pos = i
                        break
                    end
                end
                local target_joker = (my_pos and my_pos < #G.jokers.cards) and G.jokers.cards[my_pos + 1] or nil`;
    } else if (position === "specific") {
      jokerSelectionCode = `
                local target_joker = G.jokers.cards[${specificIndex}] or nil`;
    }
  } else {
    jokerSelectionCode = `
                local available_jokers = {}
                for i, joker in ipairs(G.jokers.cards) do
                    table.insert(available_jokers, joker)
                end
                local target_joker = #available_jokers > 0 and pseudorandom_element(available_jokers, pseudoseed('copy_joker')) or nil`;
  }

  // Generate space check logic
  if (isNegative || ignoreSlots) {
    spaceCheckCode = `if target_joker then`;
  } else {
    spaceCheckCode = `if target_joker and #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then`;
  }

  // Generate copy logic
  const editionCode = hasEdition
    ? `
                        copied_joker:set_edition("${edition}", true)`
    : "";
  const stickerCode = hasSticker
    ? `copied_joker:add_sticker('${sticker}', true)`
    : "";
  const bufferCode = isNegative
    ? ""
    : `
                        G.GAME.joker_buffer = G.GAME.joker_buffer + 1`;
  const bufferReset = isNegative
    ? ""
    : `
                        G.GAME.joker_buffer = 0`;

  copyCode = `${jokerSelectionCode}
                
                ${spaceCheckCode}${bufferCode}
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local copied_joker = copy_card(target_joker, nil, nil, nil, target_joker.edition and target_joker.edition.negative)${editionCode}
                            ${stickerCode}
                            copied_joker:add_to_deck()
                            G.jokers:emplace(copied_joker)${bufferReset}
                            return true
                        end
                    }))
                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                      customMessage
                        ? `"${customMessage}"`
                        : `localize('k_duplicated_ex')`
                    }, colour = G.C.GREEN})
                end`;

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${copyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()${copyCode}
                    return true
                end`,
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\CreateConsumableEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateCreateConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const set = (effect.params?.set as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const isNegative = (effect.params?.is_negative as string) == 'y';
  const customMessage = effect.customMessage;
  const soulable = effect.params?.soulable;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let consumableCreationCode = "";
  let consumableKey = "";
  let setName = "";
  let colour = "G.C.PURPLE";
  let localizeKey = "";

  // Determine the set and card to create
  if (set === "random") {
    if (isNegative) {
      consumableCreationCode = `local created_consumable = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        local random_sets = {'Tarot', 'Planet', 'Spectral'}
                        local random_set = random_sets[math.random(1, #random_sets)]
                        SMODS.add_card{set=random_set, edition = 'e_negative', soulable = ${soulable}, key_append='joker_forge_' .. random_set:lower()}
                        return true
                    end
                }))`;
    } else {
      consumableCreationCode = `local created_consumable = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_consumable = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            local random_sets = {'Tarot', 'Planet', 'Spectral'}
                            local random_set = random_sets[math.random(1, #random_sets)]
                            SMODS.add_card{set=random_set, soulable = ${soulable}, key_append='joker_forge_' .. random_set:lower()}
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
    localizeKey = "k_plus_consumable";
  } else {
    // Determine color and localize key based on set
    if (set === "Tarot") {
      colour = "G.C.PURPLE";
      localizeKey = "k_plus_tarot";
      setName = "'Tarot'";
    } else if (set === "Planet") {
      colour = "G.C.SECONDARY_SET.Planet";
      localizeKey = "k_plus_planet";
      setName = "'Planet'";
    } else if (set === "Spectral") {
      colour = "G.C.SECONDARY_SET.Spectral";
      localizeKey = "k_plus_spectral";
      setName = "'Spectral'";
    } else {
      // Custom set
      colour = "G.C.PURPLE";
      localizeKey = "k_plus_consumable";
      setName = `'${set}'`;
    }

    if (specificCard === "random") {
      consumableKey = `nil`;
    } else {
      consumableKey = `'${specificCard}'`;
    }

    if (isNegative) {
      consumableCreationCode = `local created_consumable = true
                G.E_MANAGER:add_event(Event({
                    func = function()
                        SMODS.add_card{set = ${setName}, key = ${consumableKey}, edition = 'e_negative', soulable = ${soulable}, key_append = 'joker_forge_${set.toLowerCase()}'}
                        return true
                    end
                }))`;
    } else {
      consumableCreationCode = `local created_consumable = false
                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then
                    created_consumable = true
                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            SMODS.add_card{set = ${setName}, soulable = ${soulable}, key = ${consumableKey}, key_append = 'joker_forge_${set.toLowerCase()}'}
                            G.GAME.consumeable_buffer = 0
                            return true
                        end
                    }))
                end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${consumableCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_consumable and localize('${localizeKey}') or nil`,
      colour: colour,
    };
  } else {
    return {
      statement: `func = function()${consumableCreationCode}
                    if created_consumable then
                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                          customMessage
                            ? `"${customMessage}"`
                            : `localize('${localizeKey}')`
                        }, colour = ${colour}})
                    end
                    return true
                end`,
      colour: colour,
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\CreateJokerEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateCreateJokerReturn = (
  effect: Effect,
  triggerType: string,
  modprefix: string
): EffectReturn => {
  const jokerType = (effect.params?.joker_type as string) || "random";
  const rarity = (effect.params?.rarity as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const pool = (effect.params?.pool as string) || "";
  const edition = (effect.params?.edition as string) || "none";
  const customMessage = effect.customMessage;
  const sticker = (effect.params?.sticker as string) || "none";
  const ignoreSlotsParam = (effect.params?.ignore_slots as string) || "respect";

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);
  const isNegative = edition === "e_negative";
  const hasSticker = sticker !== "none";
  const ignoreSlots = ignoreSlotsParam === "ignore";

  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  const cardParams = [];

  if (pool && pool.trim()) {
    const finalPool = modprefix ? `${modprefix}_${pool.trim()}` : pool.trim();
    cardParams.push(`set = '${finalPool}'`);
  } else {
    cardParams.push(`set = 'Joker'`);
  }

  if (jokerType === "specific" && normalizedJokerKey) {
    cardParams.push(`key = '${normalizedJokerKey}'`);
  } else if (rarity !== "random" && (!pool || !pool.trim())) {
    const rarityMap: Record<string, string> = {
      common: "Common",
      uncommon: "Uncommon",
      rare: "Rare",
      legendary: "Legendary",
    };
    const isVanillaRarity = Object.keys(rarityMap).includes(
      rarity.toLowerCase()
    );
    const finalRarity = isVanillaRarity
      ? rarityMap[rarity.toLowerCase()]
      : modprefix
      ? `${modprefix}_${rarity}`
      : rarity;
    cardParams.push(`rarity = '${finalRarity}'`);
  }
  let slotLimitCode: string;
  if (isNegative || ignoreSlots) {
    slotLimitCode = "local created_joker = true";
  } else {
    slotLimitCode = `local created_joker = false
    if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then
        created_joker = true
        G.GAME.joker_buffer = G.GAME.joker_buffer + 1`;
  }

  const cardCreationCode = `local joker_card = SMODS.add_card({ ${cardParams.join(
    ", "
  )} })`;
  const editionCode =
    edition !== "none" ? `joker_card:set_edition("${edition}", true)` : ``;

  const stickerCode = hasSticker
    ? `joker_card:add_sticker('${sticker}', true)`
    : "";

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__
                  ${slotLimitCode}
                  G.E_MANAGER:add_event(Event({
                      func = function()
                          ${cardCreationCode}
                          if joker_card then
                              ${editionCode}
                              ${stickerCode}
                          end
                          ${
                            !(isNegative || ignoreSlots)
                              ? "G.GAME.joker_buffer = 0"
                              : ""
                          }
                          return true
                      end
                  }))
                  ${!(isNegative || ignoreSlots) ? "end" : ""}
                __PRE_RETURN_CODE_END__`,
      message: customMessage
        ? `"${customMessage}"`
        : `created_joker and localize('k_plus_joker') or nil`,
      colour: "G.C.BLUE",
    };
  } else {
    return {
      statement: `func = function()
            ${slotLimitCode}
            G.E_MANAGER:add_event(Event({
                func = function()
                    ${cardCreationCode}
                    if joker_card then
                        ${editionCode}
                        ${stickerCode}
                    end
                    ${
                      !(isNegative || ignoreSlots)
                        ? "G.GAME.joker_buffer = 0"
                        : ""
                    }
                    return true
                end
            }))
            ${!(isNegative || ignoreSlots) ? "end" : ""}
            if created_joker then
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                  customMessage
                    ? `"${customMessage}"`
                    : `localize('k_plus_joker')`
                }, colour = G.C.BLUE})
            end
            return true
        end`,
      colour: "G.C.BLUE",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\CreateTagEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import { TAG_TYPES } from "../../../data/BalatroUtils";

export const generateCreateTagReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const tagType = (effect.params?.tag_type as string) || "random";
  const specificTag = (effect.params?.specific_tag as string) || "double";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let tagCreationCode = "";

  if (tagType === "random") {
    tagCreationCode = `
            G.E_MANAGER:add_event(Event({
                func = function()
                    local selected_tag = pseudorandom_element(G.P_TAGS, pseudoseed("create_tag")).key
                    local tag = Tag(selected_tag)
                    if tag.name == "Orbital Tag" then
                        local _poker_hands = {}
                        for k, v in pairs(G.GAME.hands) do
                            if v.visible then
                                _poker_hands[#_poker_hands + 1] = k
                            end
                        end
                        tag.ability.orbital_hand = pseudorandom_element(_poker_hands, "jokerforge_orbital")
                    end
                    tag:set_ability()
                    add_tag(tag)
                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)
                    return true
                end
            }))`;
  } else {
    const tagKey = TAG_TYPES[specificTag] || "tag_double";
    tagCreationCode = `
            G.E_MANAGER:add_event(Event({
                func = function()
                    local tag = Tag("${tagKey}")
                    if tag.name == "Orbital Tag" then
                        local _poker_hands = {}
                        for k, v in pairs(G.GAME.hands) do
                            if v.visible then
                                _poker_hands[#_poker_hands + 1] = k
                            end
                        end
                        tag.ability.orbital_hand = pseudorandom_element(_poker_hands, "jokerforge_orbital")
                    end
                    tag:set_ability()
                    add_tag(tag)
                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)
                    return true
                end
            }))`;
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${tagCreationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage ? `"${customMessage}"` : `"Created Tag!"`,
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()${tagCreationCode}
                    return true
                end`,
      message: customMessage ? `"${customMessage}"` : `"Created Tag!"`,
      colour: "G.C.GREEN",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\DeleteCardEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

interface ExtendedEffect extends Effect {
  _isInRandomGroup?: boolean;
  _ruleContext?: string;
  _effectIndex?: number;
}

export const generateDeleteCardReturn = (
  effect?: ExtendedEffect,
  triggerType?: string
): EffectReturn => {
  const customMessage = effect?.customMessage;
  const isInRandomGroup = effect?._isInRandomGroup;

  if (triggerType === "card_discarded") {
    return {
      statement: `remove = true,
                  message = ${
                    customMessage ? `"${customMessage}"` : `"Destroyed!"`
                  }`,
      message: "",
      colour: "",
    };
  }

  // If this delete effect is inside a random group, only return the message
  // The destroy flag will be handled by the random group logic
  if (isInRandomGroup) {
    return {
      statement: "",
      message: customMessage ? `"${customMessage}"` : `"Destroyed!"`,
      colour: "G.C.RED",
    };
  }

  return {
    statement: "",
    message: customMessage ? `"${customMessage}"` : `"Destroyed!"`,
    colour: "G.C.RED",
  };
};

```

### src\components\codeGeneration\Jokers\effects\DestroyConsumableEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

const TAROT_CARD_KEYS: Record<string, string> = {
  the_fool: "c_fool",
  the_magician: "c_magician",
  the_high_priestess: "c_high_priestess",
  the_empress: "c_empress",
  the_emperor: "c_emperor",
  the_hierophant: "c_hierophant",
  the_lovers: "c_lovers",
  the_chariot: "c_chariot",
  justice: "c_justice",
  the_hermit: "c_hermit",
  the_wheel_of_fortune: "c_wheel_of_fortune",
  strength: "c_strength",
  the_hanged_man: "c_hanged_man",
  death: "c_death",
  temperance: "c_temperance",
  the_devil: "c_devil",
  the_tower: "c_tower",
  the_star: "c_star",
  the_moon: "c_moon",
  the_sun: "c_sun",
  judgement: "c_judgement",
  the_world: "c_world",
};

const PLANET_CARD_KEYS: Record<string, string> = {
  pluto: "c_pluto",
  mercury: "c_mercury",
  uranus: "c_uranus",
  venus: "c_venus",
  saturn: "c_saturn",
  jupiter: "c_jupiter",
  earth: "c_earth",
  mars: "c_mars",
  neptune: "c_neptune",
  planet_x: "c_planet_x",
  ceres: "c_ceres",
  eris: "c_eris",
};

const SPECTRAL_CARD_KEYS: Record<string, string> = {
  familiar: "c_familiar",
  grim: "c_grim",
  incantation: "c_incantation",
  talisman: "c_talisman",
  aura: "c_aura",
  wraith: "c_wraith",
  sigil: "c_sigil",
  ouija: "c_ouija",
  ectoplasm: "c_ectoplasm",
  immolate: "c_immolate",
  ankh: "c_ankh",
  deja_vu: "c_deja_vu",
  hex: "c_hex",
  trance: "c_trance",
  medium: "c_medium",
  cryptid: "c_cryptid",
  the_soul: "c_soul",
  black_hole: "c_black_hole",
};

export const generateDestroyConsumableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const consumableType = (effect.params?.consumable_type as string) || "random";
  const specificCard = (effect.params?.specific_card as string) || "random";
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let destroyCode = "";

  if (consumableType === "random") {
    const messageText = customMessage
      ? `"${customMessage}"`
      : `"Destroyed Consumable!"`;
    destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                table.insert(target_cards, consumable)
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
  } else {
    let cardKeys: string[] = [];
    let setName = "";

    if (consumableType === "tarot") {
      setName = "Tarot";
      if (specificCard === "random") {
        cardKeys = Object.values(TAROT_CARD_KEYS);
      } else {
        cardKeys = [TAROT_CARD_KEYS[specificCard] || "c_fool"];
      }
    } else if (consumableType === "planet") {
      setName = "Planet";
      if (specificCard === "random") {
        cardKeys = Object.values(PLANET_CARD_KEYS);
      } else {
        cardKeys = [PLANET_CARD_KEYS[specificCard] || "c_pluto"];
      }
    } else if (consumableType === "spectral") {
      setName = "Spectral";
      if (specificCard === "random") {
        cardKeys = Object.values(SPECTRAL_CARD_KEYS);
      } else {
        cardKeys = [SPECTRAL_CARD_KEYS[specificCard] || "c_familiar"];
      }
    }

    const messageText = customMessage
      ? `"${customMessage}"`
      : `"Destroyed Consumable!"`;

    if (specificCard === "random") {
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${setName}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    } else {
      const targetKey = cardKeys[0];
      destroyCode = `
            local target_cards = {}
            for i, consumable in ipairs(G.consumeables.cards) do
                if consumable.ability.set == "${setName}" and consumable.config.center.key == "${targetKey}" then
                    table.insert(target_cards, consumable)
                end
            end
            if #target_cards > 0 then
                local card_to_destroy = pseudorandom_element(target_cards, pseudoseed('destroy_consumable'))
                G.E_MANAGER:add_event(Event({
                    func = function()
                        card_to_destroy:start_dissolve()
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${messageText}, colour = G.C.RED})
            end`;
    }
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${destroyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.RED",
    };
  } else {
    return {
      statement: `func = function()${destroyCode}
                    return true
                end`,
      colour: "G.C.RED",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\DestroyJokerEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateDestroyJokerReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const selectionMethod =
    (effect.params?.selection_method as string) || "random";
  const jokerKey = (effect.params?.joker_key as string) || "";
  const position = (effect.params?.position as string) || "first";
  const specificIndex = effect.params?.specific_index as number;
  const customMessage = effect.customMessage;
  const sellValueMultiplier =
    (effect.params?.sell_value_multiplier as number) || 0;
  const variableName = (effect.params?.variable_name as string) || "";
  const bypassEternal = (effect.params?.bypass_eternal as string) === "yes";

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  const normalizedJokerKey = jokerKey.startsWith("j_")
    ? jokerKey
    : `j_${jokerKey}`;

  const eternalCheck = bypassEternal ? "" : " and not joker.ability.eternal";

  let jokerSelectionCode = "";
  let destroyCode = "";

  if (selectionMethod === "specific" && normalizedJokerKey) {
    jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if joker.config.center.key == "${normalizedJokerKey}"${eternalCheck} and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
  } else if (selectionMethod === "position") {
    if (position === "first") {
      jokerSelectionCode = `
                local target_joker = nil
                for i, joker in ipairs(G.jokers.cards) do
                    if joker ~= card${eternalCheck} and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
    } else if (position === "last") {
      jokerSelectionCode = `
                local target_joker = nil
                for i = #G.jokers.cards, 1, -1 do
                    local joker = G.jokers.cards[i]
                    if joker ~= card${eternalCheck} and not joker.getting_sliced then
                        target_joker = joker
                        break
                    end
                end`;
    } else if (position === "left") {
      jokerSelectionCode = `
                local my_pos = nil
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] == card then
                        my_pos = i
                        break
                    end
                end
                local target_joker = nil
                if my_pos and my_pos > 1 then
                    local joker = G.jokers.cards[my_pos - 1]
                    if ${
                      bypassEternal ? "true" : "not joker.ability.eternal"
                    } and not joker.getting_sliced then
                        target_joker = joker
                    end
                end`;
    } else if (position === "right") {
      jokerSelectionCode = `
                local my_pos = nil
                for i = 1, #G.jokers.cards do
                    if G.jokers.cards[i] == card then
                        my_pos = i
                        break
                    end
                end
                local target_joker = nil
                if my_pos and my_pos < #G.jokers.cards then
                    local joker = G.jokers.cards[my_pos + 1]
                    if ${
                      bypassEternal ? "true" : "not joker.ability.eternal"
                    } and not joker.getting_sliced then
                        target_joker = joker
                    end
                end`;
    } else if (position === "specific") {
      jokerSelectionCode = `
                local target_joker = nil
                if G.jokers.cards[${specificIndex}] then
                    local joker = G.jokers.cards[${specificIndex}]
                    if joker ~= card${eternalCheck} and not joker.getting_sliced then
                        target_joker = joker
                    end
                end`;
    }
  } else {
    jokerSelectionCode = `
                local destructable_jokers = {}
                for i, joker in ipairs(G.jokers.cards) do
                    if joker ~= card${eternalCheck} and not joker.getting_sliced then
                        table.insert(destructable_jokers, joker)
                    end
                end
                local target_joker = #destructable_jokers > 0 and pseudorandom_element(destructable_jokers, pseudoseed('destroy_joker')) or nil`;
  }

  let sellValueCode = "";
  if (sellValueMultiplier > 0 && variableName) {
    sellValueCode = `
                    local joker_sell_value = target_joker.sell_cost or 0
                    local sell_value_gain = joker_sell_value * ${sellValueMultiplier}
                    card.ability.extra.${variableName} = card.ability.extra.${variableName} + sell_value_gain`;
  }

  let bypassEternalCode = "";
  if (bypassEternal) {
    bypassEternalCode = `
                    if target_joker.ability.eternal then
                        target_joker.ability.eternal = nil
                    end`;
  }

  destroyCode = `${jokerSelectionCode}
                
                if target_joker then${bypassEternalCode}${sellValueCode}
                    target_joker.getting_sliced = true
                    G.E_MANAGER:add_event(Event({
                        func = function()
                            target_joker:start_dissolve({G.C.RED}, nil, 1.6)
                            return true
                        end
                    }))
                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                      customMessage ? `"${customMessage}"` : `"Destroyed!"`
                    }, colour = G.C.RED})
                end`;

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${destroyCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.RED",
    };
  } else {
    return {
      statement: `func = function()${destroyCode}
                    return true
                end`,
      colour: "G.C.RED",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\DestroySelfEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateDestroySelfReturn = (effect?: Effect): EffectReturn => {
  const thing = effect?.params.animation+'()'
  const isMessage = effect?.params.display_message
  const customMessage = effect?.customMessage;
  const statement = `func = function()
                card:${thing}
                return true
            end`;
  if (isMessage == 'y'){
  return {
    statement: statement,
    message: customMessage ? `"${customMessage}"` : `"Destroyed!"`,
    colour: "G.C.RED",
  }}
  else{
    return {
      statement:statement,
      colour:"G.C.RED"
  }}
};

```

### src\components\codeGeneration\Jokers\effects\DisableBossBlindEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";

export const generateDisableBossBlindReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  const disableCode = `
            if G.GAME.blind and G.GAME.blind.boss and not G.GAME.blind.disabled then
                G.E_MANAGER:add_event(Event({
                    func = function()
                        G.GAME.blind:disable()
                        play_sound('timpani')
                        return true
                    end
                }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
                  customMessage
                    ? `"${customMessage}"`
                    : `localize('ph_boss_disabled')`
                }, colour = G.C.GREEN})
            end`;

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${disableCode}
                __PRE_RETURN_CODE_END__`,
      colour: "G.C.GREEN",
    };
  } else {
    return {
      statement: `func = function()${disableCode}
                    return true
                end`,
      colour: "G.C.GREEN",
    };
  }
};

export const generatePassiveDisableBossBlind = (
  effect: Effect
): PassiveEffectResult => {
  const customMessage = effect.customMessage;

  const addToDeck = `
  if G.GAME.blind and G.GAME.blind.boss and not G.GAME.blind.disabled then
      G.GAME.blind:disable()
      play_sound('timpani')
      SMODS.calculate_effect({ message = ${
        customMessage ? `"${customMessage}"` : `localize('ph_boss_disabled')`
      } }, card)
  end
  `; 
  const calculateFunction = `
    if G.GAME.blind and G.GAME.blind.boss and not G.GAME.blind.disabled then
        G.GAME.blind:disable()
        play_sound('timpani')
        SMODS.calculate_effect({ message = ${
          customMessage ? `"${customMessage}"` : `localize('ph_boss_disabled')`
        } }, card)
    end`;

  return {
    addToDeck,
    calculateFunction,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\DiscountItemsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import { generateConfigVariables } from "../gameVariableUtils";

export const generateFreeRerollsReturn = (
  effect: Effect
): PassiveEffectResult => {
  const variableName = "reroll_amount";

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  );

  return {
    addToDeck: `SMODS.change_free_rerolls(${valueCode})`,
    removeFromDeck: `SMODS.change_free_rerolls(-(${valueCode}))`,
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => cv.name + " = " + cv.value)
        : [],
    locVars: [],
  };
};

export const generateDiscountItemsReturn = (
  effect: Effect,
  jokerKey?: string
): PassiveEffectResult => {
  const discountType = (effect.params?.discount_type as string) || "planet";
  const discountMethod =
    (effect.params?.discount_method as string) || "make_free";

  const variableName = "discount_amount";

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.discount_amount,
    effect.id,
    variableName,
    "hook"
  );

  return {
    addToDeck: `G.E_MANAGER:add_event(Event({
    func = function()
        for k, v in pairs(G.I.CARD) do
            if v.set_cost then v:set_cost() end
        end
        return true
    end
}))`,
    removeFromDeck: `G.E_MANAGER:add_event(Event({
    func = function()
        for k, v in pairs(G.I.CARD) do
            if v.set_cost then v:set_cost() end
        end
        return true
    end
}))`,
    configVariables:
      configVariables.length > 0
        ? configVariables.map((cv) => cv.name + " = " + cv.value)
        : [],
    locVars: [],
    needsHook: {
      hookType: "discount_items",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {
        discountType,
        discountMethod,
        discountAmount: valueCode,
      },
    },
  };
};

export const generateDiscountItemsHook = (
  discountJokers: Array<{
    jokerKey: string;
    params: {
      discountType: string;
      discountMethod: string;
      discountAmount: string;
    };
  }>,
  modPrefix: string
): string => {
  if (discountJokers.length === 0) return "";

  let hookCode = `
local card_set_cost_ref = Card.set_cost
function Card:set_cost()
    card_set_cost_ref(self)`;

  discountJokers.forEach(({ jokerKey, params }) => {
    let costCondition = "";
    let costLogic = "";

    switch (params.discountType) {
      case "planet":
        costCondition =
          "(self.ability.set == 'Planet' or (self.ability.set == 'Booster' and self.config.center.kind == 'Celestial'))";
        break;
      case "tarot":
        costCondition =
          "(self.ability.set == 'Tarot' or (self.ability.set == 'Booster' and self.config.center.kind == 'Arcana'))";
        break;
      case "spectral":
        costCondition =
          "(self.ability.set == 'Spectral' or (self.ability.set == 'Booster' and self.config.center.kind == 'Spectral'))";
        break;
      case "standard":
        costCondition =
          "(self.ability.set == 'Enhanced' or (self.ability.set == 'Booster' and self.config.center.kind == 'Standard'))";
        break;
      case "jokers":
        costCondition = "self.ability.set == 'Joker'";
        break;
      case "vouchers":
        costCondition = "self.ability.set == 'Voucher'";
        break;
      case "all_consumables":
        costCondition =
          "(self.ability.set == 'Tarot' or self.ability.set == 'Planet' or self.ability.set == 'Spectral')";
        break;
      case "all_cards":
        costCondition =
          "(self.ability.set == 'Joker' or self.ability.set == 'Tarot' or self.ability.set == 'Planet' or self.ability.set == 'Spectral' or self.ability.set == 'Enhanced' or self.ability.set == 'Booster')";
        break;
      case "all_shop_items":
        costCondition =
          "(self.ability.set == 'Joker' or self.ability.set == 'Tarot' or self.ability.set == 'Planet' or self.ability.set == 'Spectral' or self.ability.set == 'Enhanced' or self.ability.set == 'Booster' or self.ability.set == 'Voucher')";
        break;
    }

    const fullJokerKey = `j_${modPrefix}_${jokerKey}`;
    const discountAmountCode = params.discountAmount;

    switch (params.discountMethod) {
      case "make_free":
        costLogic = "self.cost = 0";
        break;
      case "flat_reduction":
        costLogic = `self.cost = math.max(0, self.cost - (${discountAmountCode}))`;
        break;
      case "percentage_reduction":
        costLogic = `self.cost = math.max(0, math.floor(self.cost * (1 - (${discountAmountCode}) / 100)))`;
        break;
    }

    hookCode += `
    
    if next(SMODS.find_card("${fullJokerKey}")) then
        if ${costCondition} then
            ${costLogic}
        end
    end`;
  });

  hookCode += `
    
    self.sell_cost = math.max(1, math.floor(self.cost / 2)) + (self.ability.extra_value or 0)
    self.sell_cost_label = self.facing == 'back' and '?' or self.sell_cost
end`;

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\DrawCardsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateDrawCardsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const variableName =
    sameTypeCount === 0 ? "card_draw" : `card_draw${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  const statement = `__PRE_RETURN_CODE__
  if G.GAME.blind.in_blind then
    SMODS.draw_cards(${valueCode})
  end__PRE_RETURN_CODE_END__
  `;
 
  return {
    statement: statement,
    message: customMessage ? `"${customMessage}"` : `"+"..tostring(${valueCode}).." Cards Drawn"`,
    colour: "G.C.BLUE",
    configVariables: configVariables,
  }
}
```

### src\components\codeGeneration\Jokers\effects\EditBoosterSlotsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditBoosterSlotsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "booster_slots" : `booster_slots${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Booster Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                SMODS.change_booster_limit(${valueCode})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Booster Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                SMODS.change_booster_limit(-${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Booster Slots set to "..tostring(${valueCode})`;
      statement = `func = function()
                local current_booster_slots = G.GAME.modifiers.extra_boosters
                local target_booster_slots = ${valueCode}
                local difference = target_booster_slots - current_booster_slots
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                SMODS.change_booster_limit(difference)
                return true
            end`;
      break;
    }
    default: {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Booster Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                SMODS.change_booster_limit(${valueCode})
                return true
            end`;
      break;
    }
  }

  return {
    statement,
    colour: "G.C.ORANGE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveBoosterSlots = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `boosterslots_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `SMODS.change_booster_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_booster_limit(-${valueCode})`;
      break;
    case "subtract":
      addToDeck = `SMODS.change_booster_limit(-${valueCode})`;
      removeFromDeck = `SMODS.change_booster_limit(${valueCode})`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_slot_size = G.GAME.modifiers.extra_boosters or 0
        local difference = ${valueCode} - G.GAME.modifiers.extra_boosters
        SMODS.change_discard_limit(difference)`;
      removeFromDeck = `if card.ability.extra.original_slot_size then
            local difference = card.ability.extra.original_slot_size - G.GAME.modifiers.extra_boosters
            SMODS.change_discard_limit(difference)
        end`;
      break;
    default:
      addToDeck = `SMODS.change_booster_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_booster_limit(-${valueCode})`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditCardEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateEditCardReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const newRank = (effect.params?.new_rank as string) || "none";
  const newSuit = (effect.params?.new_suit as string) || "none";
  const newEnhancement = (effect.params?.new_enhancement as string) || "none";
  const newSeal = (effect.params?.new_seal as string) || "none";
  const newEdition = (effect.params?.new_edition as string) || "none";
  const customMessage = effect.customMessage;

  let modificationCode = "";

  if (newRank !== "none" || newSuit !== "none") {
    let suitParam = "nil";
    let rankParam = "nil";

    if (newSuit === "random") {
      suitParam = "pseudorandom_element(SMODS.Suits, 'edit_card_suit').key";
    } else if (newSuit !== "none") {
      suitParam = `"${newSuit}"`;
    }

    if (newRank === "random") {
      rankParam = "pseudorandom_element(SMODS.Ranks, 'edit_card_rank').key";
    } else if (newRank !== "none") {
      rankParam = `"${newRank}"`;
    }

    modificationCode += `
                assert(SMODS.change_base(context.other_card, ${suitParam}, ${rankParam}))`;
  }

  if (newEnhancement === "remove") {
    modificationCode += `
                context.other_card:set_ability(G.P_CENTERS.c_base)`;
  } else if (newEnhancement === "random") {
    modificationCode += `
                local enhancement_pool = {}
                for _, enhancement in pairs(G.P_CENTER_POOLS.Enhanced) do
                    if enhancement.key ~= 'm_stone' then
                        enhancement_pool[#enhancement_pool + 1] = enhancement
                    end
                end
                local random_enhancement = pseudorandom_element(enhancement_pool, 'edit_card_enhancement')
                context.other_card:set_ability(random_enhancement)`;
  } else if (newEnhancement !== "none") {
    modificationCode += `
                context.other_card:set_ability(G.P_CENTERS.${newEnhancement})`;
  }

  if (newSeal === "remove") {
    modificationCode += `
                context.other_card:set_seal(nil)`;
  } else if (newSeal === "random") {
    modificationCode += `
                local random_seal = SMODS.poll_seal({mod = 10, guaranteed = true})
                if random_seal then
                    context.other_card:set_seal(random_seal, true)
                end`;
  } else if (newSeal !== "none") {
    modificationCode += `
                context.other_card:set_seal("${newSeal}", true)`;
  }

  if (newEdition === "remove") {
    modificationCode += `
                context.other_card:set_edition(nil)`;
  } else if (newEdition === "random") {
    modificationCode += `
                local random_edition = poll_edition('edit_card_edition', nil, true, true)
                if random_edition then
                    context.other_card:set_edition(random_edition, true)
                end`;
  } else if (newEdition !== "none") {
    modificationCode += `
                context.other_card:set_edition("${newEdition}", true)`;
  }

  const scoringTriggers = ["card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__${modificationCode}
                __PRE_RETURN_CODE_END__`,
      message: customMessage ? `"${customMessage}"` : `"Card Modified!"`,
      colour: "G.C.BLUE",
    };
  } else {
    return {
      statement: `func = function()${modificationCode}
                    end`,
      message: customMessage ? `"${customMessage}"` : `"Card Modified!"`,
      colour: "G.C.BLUE",
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\EditConsumableSlotsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateEditConsumableSlotsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const variableName =
    sameTypeCount === 0
      ? "consumable_slots"
      : `consumable_slots${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Consumable Slot"`;
      statement = `func = function()
                G.E_MANAGER:add_event(Event({func = function()
                    G.consumeables.config.card_limit = G.consumeables.config.card_limit + ${valueCode}
                    return true
                end }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.GREEN})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Consumable Slot"`;
      statement = `func = function()
                G.E_MANAGER:add_event(Event({func = function()
                    G.consumeables.config.card_limit = math.max(0, G.consumeables.config.card_limit - ${valueCode})
                    return true
                end }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Consumable Slots"`;
      statement = `func = function()
                G.E_MANAGER:add_event(Event({func = function()
                    G.consumeables.config.card_limit = ${valueCode}
                    return true
                end }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                return true
            end`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Consumable Slot"`;
      statement = `func = function()
                G.E_MANAGER:add_event(Event({func = function()
                    G.consumeables.config.card_limit = G.consumeables.config.card_limit + ${valueCode}
                    return true
                end }))
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.GREEN})
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.GREEN",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveConsumableSlots = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";

  const { valueCode, configVariables, isXVariable } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    "slot_change"
  )

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + ${valueCode}
            return true
        end }))`;
      removeFromDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = G.consumeables.config.card_limit - ${valueCode}
            return true
        end }))`;
      break;
    case "subtract":
      addToDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = math.max(0, G.consumeables.config.card_limit - ${valueCode})
            return true
        end }))`;
      removeFromDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + ${valueCode}
            return true
        end }))`;
      break;
    case "set":
      addToDeck = `original_slots = G.consumeables.config.card_limit
        G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = ${valueCode}
            return true
        end }))`;
      removeFromDeck = `if original_slots then
            G.E_MANAGER:add_event(Event({func = function()
                G.consumeables.config.card_limit = original_slots
                return true
            end }))
        end`;
      break;
    default:
      addToDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + ${valueCode}
            return true
        end }))`;
      removeFromDeck = `G.E_MANAGER:add_event(Event({func = function()
            G.consumeables.config.card_limit = G.consumeables.config.card_limit - ${valueCode}
            return true
        end }))`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: 
      configVariables.length > 0 ?
      configVariables.map((cv)=> `${cv.name} = ${cv.value}`)
      : [],
    locVars:
      isXVariable.isGameVariable || isXVariable.isRangeVariable ? [] : [valueCode],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditDiscardEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateEditDiscardReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const duration = effect.params?.duration || "permanent";

  const variableName =
    sameTypeCount === 0 ? "discards" : `discards${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  let editDiscardCode = "";

  switch (operation) {
    case "add": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = G.GAME.round_resets.discards + ${valueCode}
        ease_discard(${valueCode})
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = G.GAME.current_round.discards_left + ${valueCode}`;
      }
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Discard"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.ORANGE})
                ${editDiscardCode}
                return true
            end`;
      break;
    }
    case "subtract": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = G.GAME.round_resets.discards - ${valueCode}
        ease_discard(-${valueCode})
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = G.GAME.current_round.discards_left - ${valueCode}`;
      }
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Discard"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                ${editDiscardCode}
                return true
            end`;
      break;
    }
    case "set": {
      if (duration === "permanent") {
        editDiscardCode = `
        G.GAME.round_resets.discards = ${valueCode}
        ease_discard(${valueCode} - G.GAME.current_round.discards_left)
        `;
      } else if (duration === "round") {
        editDiscardCode = `G.GAME.current_round.discards_left = ${valueCode}`;
      }
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Discards"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                ${editDiscardCode}
                G.GAME.round_resets.hands = ${
                  duration === "permanent"
                    ? valueCode
                    : "G.GAME.round_resets.hands"
                }
                return true
            end`;
      break;
    }
  }

  return {
    statement,
    colour: "G.C.ORANGE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveDiscard = (effect: Effect): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  
  const variableName = "discard_change";
  
  const { valueCode, configVariables, isXVariable } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `G.GAME.round_resets.discards = G.GAME.round_resets.discards + ${valueCode}`;
      removeFromDeck = `G.GAME.round_resets.discards = G.GAME.round_resets.discards - ${valueCode}`;
      break;
    case "subtract":
      addToDeck = `G.GAME.round_resets.discards = math.max(0, G.GAME.round_resets.discards - ${valueCode})`;
      removeFromDeck = `G.GAME.round_resets.discards = G.GAME.round_resets.discards + ${valueCode}`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_discards = G.GAME.round_resets.discards
        G.GAME.round_resets.discards = ${valueCode}`;
      removeFromDeck = `if card.ability.extra.original_discards then
            G.GAME.round_resets.discards = card.ability.extra.original_discards
        end`;
      break;
    default:
      addToDeck = `G.GAME.round_resets.discards = G.GAME.round_resets.discards + ${valueCode}`;
      removeFromDeck = `G.GAME.round_resets.discards = G.GAME.round_resets.discards - ${valueCode}`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: 
      configVariables.length > 0 ?
      configVariables.map((cv)=> `${cv.name} = ${cv.value}`)
      : [],
    locVars:
      isXVariable.isGameVariable || isXVariable.isRangeVariable ? [] : [valueCode],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditDiscardSizeEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditDiscardSizeReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "play_size" : `play_size${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                SMODS.change_discard_limit(${valueCode})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                SMODS.change_discard_limit(-${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Play Size set to "..tostring(${valueCode})`;
      statement = `func = function()
                local current_play_size = G.GAME.starting_params.discard_limit
                local target_play_size = ${valueCode}
                local difference = target_play_size - current_play_size
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                SMODS.change_discard_limit(difference)
                return true
            end`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                SMODS.change_discard_limit(${valueCode})
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.BLUE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveDiscardSize = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `handsize_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `SMODS.change_discard_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_discard_limit(-${valueCode})`;
      break;
    case "subtract":
      addToDeck = `SMODS.change_discard_limit(-${valueCode})`;
      removeFromDeck = `SMODS.change_discard_limit(${valueCode})`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_play_size = G.GAME.starting_params.discard_limit
        local difference = ${valueCode} - G.GAME.starting_params.discard_limit
        SMODS.change_discard_limit(difference)`;
      removeFromDeck = `if card.ability.extra.original_play_size then
            local difference = card.ability.extra.original_play_size - G.GAME.starting_params.discard_limit
            SMODS.change_discard_limit(difference)
        end`;
      break;
    default:
      addToDeck = `SMODS.change_discard_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_discard_limit(-${valueCode})`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditHandEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateEditHandReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";
  const duration = effect.params?.duration || "permanent";

  const variableName =
    sameTypeCount === 0 ? "hands" : `hands${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  let editHandCode = "";

  switch (operation) {
    case "add": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = G.GAME.round_resets.hands + ${valueCode}
        ease_hands_played(${valueCode})
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = G.GAME.current_round.hands_left + ${valueCode}`;
      }
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.GREEN})
                ${editHandCode}
                return true
            end`;
      break;
    }
    case "subtract": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = G.GAME.round_resets.hands - ${valueCode}
        ease_hands_played(-${valueCode})
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = G.GAME.current_round.hands_left - ${valueCode}`;
      }
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                ${editHandCode}
                return true
            end`;
      break;
    }
    case "set": {
      if (duration === "permanent") {
        editHandCode = `
        G.GAME.round_resets.hands = ${valueCode}
        ease_hands_played(${valueCode} - G.GAME.current_round.hands_left)
        `;
      } else if (duration === "round") {
        editHandCode = `G.GAME.current_round.hands_left = ${valueCode}`;
      }
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Hands"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                ${editHandCode}
                return true
            end`;
      break;
    }
  }

  return {
    statement,
    colour: "G.C.GREEN",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveHand = (effect: Effect): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";

  const variableName = "hand_change";
  
  const { valueCode, configVariables, isXVariable } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `G.GAME.round_resets.hands = G.GAME.round_resets.hands + ${valueCode}`;
      removeFromDeck = `G.GAME.round_resets.hands = G.GAME.round_resets.hands - ${valueCode}`;
      break;
    case "subtract":
      addToDeck = `G.GAME.round_resets.hands = math.max(1, G.GAME.round_resets.hands - ${valueCode})`;
      removeFromDeck = `G.GAME.round_resets.hands = G.GAME.round_resets.hands + ${valueCode}`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_hands = G.GAME.round_resets.hands
        G.GAME.round_resets.hands = ${valueCode}`;
      removeFromDeck = `if card.ability.extra.original_hands then
            G.GAME.round_resets.hands = card.ability.extra.original_hands
        end`;
      break;
    default:
      addToDeck = `G.GAME.round_resets.hands = G.GAME.round_resets.hands + ${valueCode}`;
      removeFromDeck = `G.GAME.round_resets.hands = G.GAME.round_resets.hands - ${valueCode}`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: 
      configVariables.length > 0 ?
      configVariables.map((cv)=> `${cv.name} = ${cv.value}`)
      : [],
    locVars:
      isXVariable.isGameVariable || isXVariable.isRangeVariable ? [] : [valueCode],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditHandSizeEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditHandSizeReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "hand_size" : `hand_size${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                G.hand:change_size(${valueCode})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Hand Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                G.hand:change_size(-${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Hand Size set to "..tostring(${valueCode})`;
      statement = `func = function()
                local current_hand_size = G.hand.config.card_limit
                local target_hand_size = ${valueCode}
                local difference = target_hand_size - current_hand_size
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                G.hand:change_size(difference)
                return true
            end`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Hand Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                G.hand:change_size(${valueCode})
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.BLUE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveHandSize = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `handsize_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `G.hand:change_size(${valueCode})`;
      removeFromDeck = `G.hand:change_size(-${valueCode})`;
      break;
    case "subtract":
      addToDeck = `G.hand:change_size(-${valueCode})`;
      removeFromDeck = `G.hand:change_size(${valueCode})`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_hand_size = G.hand.config.card_limit
        local difference = ${valueCode} - G.hand.config.card_limit
        G.hand:change_size(difference)`;
      removeFromDeck = `if card.ability.extra.original_hand_size then
            local difference = card.ability.extra.original_hand_size - G.hand.config.card_limit
            G.hand:change_size(difference)
        end`;
      break;
    default:
      addToDeck = `G.hand:change_size(${valueCode})`;
      removeFromDeck = `G.hand:change_size(-${valueCode})`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditJokerSlotsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditJokerSlotsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "joker_slots" : `joker_slots${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Joker Slot"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Joker Slot"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                G.jokers.config.card_limit = math.max(1, G.jokers.config.card_limit - ${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Joker Slots set to "..tostring(${valueCode})`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                G.jokers.config.card_limit = ${valueCode}
                return true
            end`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Joker Slot"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.DARK_EDITION})
                G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.DARK_EDITION",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveJokerSlots = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `jokerslots_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}`;
      removeFromDeck = `G.jokers.config.card_limit = G.jokers.config.card_limit - ${valueCode}`;
      break;
    case "subtract":
      addToDeck = `G.jokers.config.card_limit = math.max(1, G.jokers.config.card_limit - ${valueCode})`;
      removeFromDeck = `G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_joker_slots = G.jokers.config.card_limit
        G.jokers.config.card_limit = ${valueCode}`;
      removeFromDeck = `if card.ability.extra.original_joker_slots then
            G.jokers.config.card_limit = card.ability.extra.original_joker_slots
        end`;
      break;
    default:
      addToDeck = `G.jokers.config.card_limit = G.jokers.config.card_limit + ${valueCode}`;
      removeFromDeck = `G.jokers.config.card_limit = G.jokers.config.card_limit - ${valueCode}`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditPlaySizeEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditPlaySizeReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "play_size" : `play_size${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.BLUE})
                SMODS.change_play_limit(${valueCode})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                SMODS.change_play_limit(-${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Play Size set to "..tostring(${valueCode})`;
      statement = `func = function()
                local current_play_size = G.GAME.starting_params.play_limit
                local target_play_size = ${valueCode}
                local difference = target_play_size - current_play_size
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                SMODS.change_play_limit(difference)
                return true
            end`;
      break;
    }
    default: {
      const defaultMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Play Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${defaultMessage}, colour = G.C.BLUE})
                SMODS.change_play_limit(${valueCode})
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.BLUE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassivePlaySize = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `handsize_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `SMODS.change_play_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_play_limit(-${valueCode})`;
      break;
    case "subtract":
      addToDeck = `SMODS.change_play_limit(-${valueCode})`;
      removeFromDeck = `SMODS.change_play_limit(${valueCode})`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_play_size = G.GAME.starting_params.play_limit
        local difference = ${valueCode} - G.GAME.starting_params.play_limit
        SMODS.change_play_limit(difference)`;
      removeFromDeck = `if card.ability.extra.original_play_size then
            local difference = card.ability.extra.original_play_size - G.GAME.starting_params.play_limit
            SMODS.change_play_limit(difference)
        end`;
      break;
    default:
      addToDeck = `SMODS.change_play_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_play_limit(-${valueCode})`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EditVoucherSlotsEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";
import {
  generateConfigVariables,
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateEditVoucherSlotsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "add";

  const variableName =
    sameTypeCount === 0 ? "voucher_slots" : `voucher_slots${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Voucher Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                SMODS.change_voucher_limit(${valueCode})
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Voucher Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.RED})
                SMODS.change_voucher_limit(-${valueCode})
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Voucher Slots set to "..tostring(${valueCode})`;
      statement = `func = function()
                local current_voucher_slots = G.GAME.modifiers.extra_vouchers or 0
                local target_voucher_slots = ${valueCode}
                local difference = target_voucher_slots - current_voucher_slots
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.BLUE})
                SMODS.change_voucher_limit(difference)
                return true
            end`;
      break;
    }
    default: {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Voucher Slots"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.DARK_EDITION})
                SMODS.change_voucher_limit(${valueCode})
                return true
            end`;
      break;
    }
  }

  return {
    statement,
    colour: "G.C.ORANGE",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

export const generatePassiveVoucherSlots = (
  effect: Effect
): PassiveEffectResult => {
  const operation = effect.params?.operation || "add";
  const effectValue = effect.params.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue as string);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `voucherslots_passive`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = (effectValue as number | boolean).toString();
  }

  let addToDeck = "";
  let removeFromDeck = "";

  switch (operation) {
    case "add":
      addToDeck = `SMODS.change_voucher_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_voucher_limit(-${valueCode})`;
      break;
    case "subtract":
      addToDeck = `SMODS.change_voucher_limit(-${valueCode})`;
      removeFromDeck = `SMODS.change_voucher_limit(${valueCode})`;
      break;
    case "set":
      addToDeck = `card.ability.extra.original_slot_size = G.GAME.modifiers.extra_vouchers or 0
        local difference = ${valueCode} - G.GAME.modifiers.extra_vouchers
        SMODS.change_discard_limit(difference)`;
      removeFromDeck = `if card.ability.extra.original_slot_size then
            local difference = card.ability.extra.original_slot_size - G.GAME.modifiers.extra_vouchers
            SMODS.change_discard_limit(difference)
        end`;
      break;
    default:
      addToDeck = `SMODS.change_voucher_limit(${valueCode})`;
      removeFromDeck = `SMODS.change_voucher_limit(-${valueCode})`;
  }

  return {
    addToDeck,
    removeFromDeck,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\EmitFlagEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateEmitFlagReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const flagName = (effect.params?.flag_name as string) || "custom_flag";
  const change = (effect.params?.change as string) || "true";
  const customMessage = effect.customMessage;
  const isMessage = effect?.params.display_message

  const safeFlagName = flagName.trim().replace(/[^a-zA-Z0-9_]/g, '_'); // replace non-alphanumeric charactes with underscore
  const changeCode = change === "invert" ? `not (G.GAME.pool_flags.${modprefix}_${safeFlagName} or false)` : change
  const statement = `
                __PRE_RETURN_CODE__
                G.GAME.pool_flags.${modprefix}_${safeFlagName} = ${changeCode}
                __PRE_RETURN_CODE_END__`
  if (isMessage=='y'){
  return {
    statement: statement,
    message: customMessage ? `"${customMessage}"` : `"${safeFlagName}"`,
    colour: "G.C.BLUE"
  }}
  else{
  return {
    statement: statement,
    colour: "G.C.BLUE"
  }};
}

```

### src\components\codeGeneration\Jokers\effects\FixProbabilityEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateFixProbabilityReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const part = effect.params?.part || "numerator";

  const variableName =
    sameTypeCount === 0 ? "set_probability" : `set_probability${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  let statement = `
  __PRE_RETURN_CODE__
  `;

  switch (part) {
    case "numerator": {
      statement += `
        numerator = ${valueCode}`;
      break;
    }
    case "denominator": {
      statement += `
        denominator = ${valueCode}`;
      break;
    }
    case "both": {
      statement += `
        numerator = ${valueCode}
        denominator = ${valueCode}`;
      break;
    }
    default: {
      statement += `
        numerator = ${valueCode}`;
    }
  }

  statement += `
  __PRE_RETURN_CODE_END__`
  return {
    statement,
    colour: "G.C.GREEN",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};
```

### src\components\codeGeneration\Jokers\effects\FlipJokerEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateFlipJokerReturn = (
  effect: Effect,
): EffectReturn => {
  const selectionMethod = effect.params?.selection_method as string || "random";
  const position = (effect.params?.position as string) || "first";
  const specificIndex = effect.params?.specific_index as number;
  const customMessage = effect.customMessage;

  let jokerFlipCode = "";
 if (selectionMethod === "all") {
    jokerFlipCode += `if #G.jokers.cards > 0 then
      for _, joker in ipairs(G.jokers.cards) do
        joker:flip()
      end
    end`;
 } else if (selectionMethod === "self") {
    jokerFlipCode += `if #G.jokers.cards > 0 then
    for _, joker in ipairs(G.jokers.cards) do
      if joker == card then
        joker:flip()
        break
      end
    end
    end`;
  } else if (selectionMethod === "random") {
    jokerFlipCode += `if #G.jokers.cards > 0 then
    local available_jokers = {}
      for i, joker in ipairs(G.jokers.cards) do
        table.insert(available_jokers, joker)
      end
      pseudorandom_element(available_jokers, pseudoseed('flip_joker')):flip()
    end`;
  } else if (selectionMethod === "position") {
    switch (position) {
      case "first":
        jokerFlipCode += `if G.jokers.cards[1] then
        G.jokers.cards[1]:flip()
        end`;
        break
      case "last":
        jokerFlipCode += `if G.jokers.cards[#G.jokers.cards] then
        G.jokers.cards[#G.jokers.cards]:flip()
        end`;
        break
      case "left":
        jokerFlipCode += `local self_index = 1
        if #G.jokers.cards > 0 then
          for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
              self_index = i
              break
            end
          end
          if self_index > 1 then
            G.jokers.cards[self_index - 1]:flip()
          end
        end`;
        break
      case "right":
        jokerFlipCode += `local self_index = 1
        if #G.jokers.cards > 0 then
          for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
              self_index = i
              break
            end
          end
          if self_index < #G.jokers.cards then
            G.jokers.cards[self_index + 1]:flip()
          end
        end`;
        break
      case "specific":
        jokerFlipCode += `if #G.jokers.cards > 0 then
          if G.jokers.cards[${specificIndex}] then
            G.jokers.cards[${specificIndex}]:flip()
          end
        end`;
        break
    }
  }

  return {
    statement: `__PRE_RETURN_CODE__${jokerFlipCode}__PRE_RETURN_CODE_END__`,
    message: customMessage ?? `"Flip!"`,
    colour: "G.C.ORANGE"
  }
};

```

### src\components\codeGeneration\Jokers\effects\ForceGameOverEffect.ts

```
import { Effect } from "../../../ruleBuilder";
import { EffectReturn } from "../effectUtils";

export const generateForceGameOverReturn = (effect: Effect): EffectReturn => {
  const customMessage = effect.customMessage;
  const message = customMessage? `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = "${customMessage}", colour = G.C.RED})`: ``;

  const statement = `func = function()
                ${message}
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    delay = 0.5,
                    func = function()
                        if G.STAGE == G.STAGES.RUN then 
                          G.STATE = G.STATES.GAME_OVER
                          G.STATE_COMPLETE = false
                        end
                    end
                }))
                
                return true
            end`;

  return {
    statement,
    colour: "G.C.GREEN",
  };
};
```

### src\components\codeGeneration\Jokers\effects\JuiceUpEffect.ts

```
import type { EffectReturn, ConfigExtraVariable } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateJuiceUpReturn = (
  effect: Effect,
  sameTypeCount: number = 0,
  effectType: string,
): EffectReturn => {
  const mode = effect.params?.mode || "onetime";

  const configVariables: ConfigExtraVariable[] = [];

  const scaleVariableName =
    sameTypeCount === 0 ? "scale" : `scale${sameTypeCount + 1}`;
  const scaleRet = generateConfigVariables(
    effect.params.scale,
    effect.id,
    scaleVariableName
  )

  scaleRet.configVariables.forEach((cv) => {
    configVariables.push(cv)
  })
  const scaleValueCode = scaleRet.valueCode

  const rotationVariableName =
    sameTypeCount === 0 ? "rotation" : `rotation${sameTypeCount + 1}`;
  const rotationRet = generateConfigVariables(
    effect.params.rotation,
    effect.id,
    rotationVariableName
  )

  rotationRet.configVariables.forEach((cv) => {
    configVariables.push(cv)
  })
  const rotationValueCode = rotationRet.valueCode

  let cardType: string;
  if (effectType == "card") {
    cardType = "target_card"
  } else {
    cardType = "card"
  }

  let statement = `__PRE_RETURN_CODE__
      local target_card = context.other_card`;

  if (mode === "constant") {
      statement += `
      local function juice_card_until_(card, eval_func, first, delay) -- balatro function doesn't allow for custom scale and rotation
          G.E_MANAGER:add_event(Event({
              trigger = 'after',delay = delay or 0.1, blocking = false, blockable = false, timer = 'REAL',
              func = (function() if eval_func(card) then if not first or first then ${cardType}:juice_up(${scaleValueCode}, ${rotationValueCode}) end;juice_card_until_(card, eval_func, nil, 0.8) end return true end)
          }))
      end`
  }
  
  statement += `
  __PRE_RETURN_CODE_END__`

  switch (mode) {
    case "constant":
      statement += `func = function()
                        local eval = function() return not G.RESET_JIGGLES end
                        juice_card_until_(card, eval, true)
                        return true
                    end`;
      break;
    case "onetime":
      statement += `func = function()
                      ${cardType}:juice_up(${scaleValueCode}, ${rotationValueCode})
                      return true
                    end`;
      break;
  }

  return {
    statement,
    colour: "G.C.WHITE",
    configVariables
  }
}

```

### src\components\codeGeneration\Jokers\effects\LevelUpHandEffect.ts

```
import type { EffectReturn, ConfigExtraVariable } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateLevelUpHandReturn = (
  triggerType: string = "hand_played",
  effect?: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const customMessage = effect?.customMessage;
  let valueCode: string;
  let configVariables: ConfigExtraVariable[] = [];

  if (effect) {
    const variableName =
      sameTypeCount === 0 ? "levels" : `levels${sameTypeCount + 1}`;

    const ret = generateConfigVariables(
      effect.params?.value,
      effect.id,
      variableName
    )

    valueCode = ret.valueCode
    configVariables = ret.configVariables
  } else {
    valueCode = "card.ability.extra.levels";
  }

  const targetHandVar = sameTypeCount === 0 ? `target_hand` : `target_hand${sameTypeCount + 1}`

  const handSelection = (effect?.params?.hand_selection as string) || "current";
  const specificHand = (effect?.params?.specific_hand as string) || "High Card";
  
  let handDeterminationCode = "";
  switch (handSelection) {
    case ("specific"):
      handDeterminationCode = `local ${targetHandVar} = "${specificHand}"`;
      break
    case ("random"):
      handDeterminationCode = `
        local available_hands = {}
        for hand, value in pairs(G.GAME.hands) do
          if value.visible and value.level >= to_big(1) then
            table.insert(available_hands, hand)
          end
        end
        local ${targetHandVar} = #available_hands > 0 and pseudorandom_element(available_hands, pseudoseed('level_up_hand')) or "High Card"
        `;
      break
    case ("most"):
      handDeterminationCode = `
        local temp_played = 0
        local temp_order = math.huge
        local ${targetHandVar}
        for hand, value in pairs(G.GAME.hands) do 
          if value.played > temp_played and value.visible then
            temp_played = value.played
            temp_order = value.order
            ${targetHandVar} = hand
          elseif value.played == temp_played and value.visible then
            if value.order < temp_order then
              temp_order = value.order
              ${targetHandVar} = hand
            end
          end
        end
      `;
      break
    case ("least"):
      handDeterminationCode = `
        local temp_played = math.huge
        local temp_order = math.huge
        local ${targetHandVar}
        for hand, value in pairs(G.GAME.hands) do 
          if value.played < temp_played and value.visible then
            temp_played = value.played
            temp_order = value.order
            ${targetHandVar} = hand
          elseif value.played == temp_played and value.visible then
            if value.order < temp_order then
              temp_order = value.order
              ${targetHandVar} = hand
            end
          end
        end
      `;
      break
    case ("current"):
      if (triggerType === "hand_discarded") {
        handDeterminationCode = `
          local text, poker_hands, text_disp, loc_disp_text = G.FUNCS.get_poker_hand_info(G.hand.highlighted)
          local ${targetHandVar} = text
        `;
      } else {
        handDeterminationCode = `local ${targetHandVar} = (context.scoring_name or "High Card")`;
      }
      break
  }
  
  return {
    statement: `
      __PRE_RETURN_CODE__
      ${handDeterminationCode}
      __PRE_RETURN_CODE_END__
      level_up = ${valueCode},
      level_up_hand = ${targetHandVar}`,
    message: customMessage ? `"${customMessage}"` : `localize('k_level_up_ex')`,
    colour: "G.C.RED",
    configVariables: configVariables.length > 0 ? configVariables : undefined
  }
}

```

### src\components\codeGeneration\Jokers\effects\ModifyBlindRequirementEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateModifyBlindRequirementReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = effect.params?.operation || "multiply";
  const variableName =
    sameTypeCount === 0 ? "blind_size" : `blind_size${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let statement = "";

  switch (operation) {
    case "add": {
      const addMessage = customMessage
        ? `"${customMessage}"`
        : `"+"..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${addMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = G.GAME.blind.chips + ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
      break;
    }
    case "subtract": {
      const subtractMessage = customMessage
        ? `"${customMessage}"`
        : `"-"..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${subtractMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = G.GAME.blind.chips - ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
      break;
    }
    case "multiply": {
      const multiplyMessage = customMessage
        ? `"${customMessage}"`
        : `"X"..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${multiplyMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = G.GAME.blind.chips * ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
      break;
    }
    case "divide": {
      const divideMessage = customMessage
        ? `"${customMessage}"`
        : `"/"..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${divideMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = G.GAME.blind.chips / ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
      break;
    }
    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to "..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
        break
    }
    default: {
      const multiplyMessage = customMessage
        ? `"${customMessage}"`
        : `"X"..tostring(${valueCode}).." Blind Size"`;
      statement = `func = function()
                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${multiplyMessage}, colour = G.C.GREEN})
                G.GAME.blind.chips = G.GAME.blind.chips * ${valueCode}
                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)
                G.HUD_blind:recalculate()
                return true
            end`;
    }
  }

  return {
    statement,
    colour: "G.C.GREEN",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};
```

### src\components\codeGeneration\Jokers\effects\ModifyInternalVariableEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateGameVariableCode,
  parseGameVariable,
  parseRangeVariable,
} from "../gameVariableUtils";

export const generateModifyInternalVariableReturn = (
  effect: Effect,
  triggerType: string
): EffectReturn => {
  const variableName = (effect.params?.variable_name as string) || "var1";
  const operation = (effect.params?.operation as string) || "increment";
  const effectValue = effect.params?.value;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let valueCode: string;

  if (parsed.isGameVariable) { /// change to generateConfigVariables maybe, i dunno, i dont see it necessary
    valueCode = generateGameVariableCode(effectValue);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `${variableName}_${effect.id.substring(0, 8)}`;
    valueCode = `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
  } else if (typeof effectValue === "string") {
    valueCode = `card.ability.extra.${effectValue}`;
  } else {
    valueCode = effectValue?.toString() || "1";
  }

  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let operationCode = "";
  let messageText = "";
  let messageColor = "G.C.WHITE";

  switch (operation) {
    case "set":
      operationCode = `card.ability.extra.${variableName} = ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.BLUE";
      break;
    case "increment":
      operationCode = `card.ability.extra.${variableName} = (card.ability.extra.${variableName}) + ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.GREEN";
      break;
    case "decrement":
      operationCode = `card.ability.extra.${variableName} = math.max(0, (card.ability.extra.${variableName}) - ${valueCode})`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.RED";
      break;
    case "multiply":
      operationCode = `card.ability.extra.${variableName} = (card.ability.extra.${variableName}) * ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.MULT";
      break;
    case "divide":
      operationCode = `card.ability.extra.${variableName} = (card.ability.extra.${variableName}) / ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.MULT";
      break;
    default:
      operationCode = `card.ability.extra.${variableName} = (card.ability.extra.${variableName}) + ${valueCode}`;
      messageText = customMessage ? `"${customMessage}"` : "";
      messageColor = "G.C.GREEN";
  }

  if (isScoring) {
    return {
      statement: `__PRE_RETURN_CODE__
                ${operationCode}
                __PRE_RETURN_CODE_END__`,
      message: messageText || undefined,
      colour: messageColor,
    };
  } else {
    return {
      statement: `func = function()
                    ${operationCode}
                    return true
                end`,
      message: messageText || undefined,
      colour: messageColor,
    };
  }
};

```

### src\components\codeGeneration\Jokers\effects\ModProbabilityEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateModProbabilityReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const chance_part = effect.params?.part || "numerator";
  const operation = effect.params?.operation || "multiply";
  const variableName =
    sameTypeCount === 0 ? "mod_probability" : `mod_probability${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  let statement = `
  __PRE_RETURN_CODE__
  `;
  
  switch (operation) {
    case "increment": {
      statement += `${chance_part} = ${chance_part} + ${valueCode}`;
      break;
    }
    case "decrement": {
      statement += `${chance_part} = ${chance_part} - ${valueCode}`;
      break;
    }
    case "multiply": {
      statement += `${chance_part} = ${chance_part} * ${valueCode}`;
      break;
    }
    case "divide": {
      statement += `${chance_part} = ${chance_part} / ${valueCode}`;
      break;
    }
  }

  statement += `
  __PRE_RETURN_CODE_END__`
  return {
    statement,
    colour: "G.C.GREEN",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};
```

### src\components\codeGeneration\Jokers\effects\PermaBonusEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generatePermaBonusReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const bonusType = effect.params.bonus_type as string;

  const uniqueId = effect.id.substring(0, 8);
  const variableName = `pb_${bonusType.replace("perma_", "")}_${uniqueId}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const preReturnCode = `context.other_card.ability.${bonusType} = context.other_card.ability.${bonusType} or 0
                context.other_card.ability.${bonusType} = context.other_card.ability.${bonusType} + ${valueCode}`;

  let color = "G.C.CHIPS";
  if (bonusType.includes("mult")) {
    color = "G.C.MULT";
  } else if (bonusType.includes("dollars")) {
    color = "G.C.MONEY";
  }

  let statement = "";

  if (sameTypeCount === 0) {
    const messageText = customMessage
      ? `"${customMessage}"`
      : "localize('k_upgrade_ex')";
    statement = `__PRE_RETURN_CODE__${preReturnCode}__PRE_RETURN_CODE_END__extra = { message = ${messageText}, colour = ${color} }, card = card`;
  } else {
    statement = `__PRE_RETURN_CODE__${preReturnCode}__PRE_RETURN_CODE_END__`;
  }

  const result: EffectReturn = {
    statement,
    colour: color,
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\PlaySoundEffect.ts

```
import { Effect } from "../../../ruleBuilder";
import { EffectReturn } from "../effectUtils";

export const generatePlaySoundReturn = (
  effect: Effect,
  modprefix: string
): EffectReturn => {
  const key = effect.params.sound_key as string || "";

  const normalizedKey = key.startsWith(modprefix+"_")
    ? key
    : `${modprefix}_${key}`

  const customMessage = effect.customMessage

  return {
    colour: "G.C.BLUE",
    statement: `__PRE_RETURN_CODE__play_sound("${normalizedKey}")
    ${customMessage ? `SMODS.calculate_effect({message = "${customMessage}"}, card)` : ""}
    __PRE_RETURN_CODE_END__`
  }
}
```

### src\components\codeGeneration\Jokers\effects\RedeemVoucherEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateRedeemVoucherReturn = (
  effect: Effect
): EffectReturn => {
  const voucherType = (effect.params?.voucher_type as string) || "random";
  const voucherKey = (effect.params?.specific_voucher as string) || "v_overstock_norm";
  const customMessage = effect.customMessage;

  let voucherCode: string;

  if (voucherType === "random") {
    voucherCode = `local voucher_key = pseudorandom_element(G.P_CENTER_POOLS.Voucher, "${effect.id.substring(0,8)}").key`;
  } else {
    voucherCode = `local voucher_key = "${voucherKey}"`;
  }

  voucherCode += `
    local voucher_card = SMODS.create_card{area = G.play, key = voucher_key}
    voucher_card:start_materialize()
    voucher_card.cost = 0
    G.play:emplace(voucher_card)
    delay(0.8)
    voucher_card:redeem()

    G.E_MANAGER:add_event(Event({
        trigger = 'after',
        delay = 0.5,
        func = function()
            voucher_card:start_dissolve()                
            return true
        end
    }))`;

  return {
    statement: `__PRE_RETURN_CODE__${voucherCode}
              __PRE_RETURN_CODE_END__`,
    message: customMessage
      ? `"${customMessage}"`
      : `nil`,
    colour: "G.C.RED",
  };
};

```

### src\components\codeGeneration\Jokers\effects\ReduceFlushStraightRequirementsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { PassiveEffectResult } from "../effectUtils";

export const generateReduceFlushStraightRequirementsReturn = (
  effect: Effect,
  jokerKey?: string
): PassiveEffectResult => {
  const reductionValue = (effect.params?.reduction_value as number) || 1;

  return {
    addToDeck: `-- Flush/Straight requirements reduced by ${reductionValue}`,
    removeFromDeck: `-- Flush/Straight requirements restored`,
    configVariables: [`reduction_value = ${reductionValue}`],
    locVars: [`card.ability.extra.reduction_value`],
    needsHook: {
      hookType: "reduce_flush_straight_requirements",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {
        reductionValue,
      },
    },
  };
};

export const generateReduceFlushStraightRequirementsHook = (
  reductionJokers: Array<{
    jokerKey: string;
    params: {
      reductionValue: number;
    };
  }>,
  modPrefix: string
): string => {
  if (reductionJokers.length === 0) return "";

  let hookCode = `
local smods_four_fingers_ref = SMODS.four_fingers
function SMODS.four_fingers()`;

  reductionJokers.forEach(({ jokerKey, params }) => {
    const fullJokerKey = `j_${modPrefix}_${jokerKey}`;
    const targetValue = 5 - params.reductionValue;

    hookCode += `
    if next(SMODS.find_card("${fullJokerKey}")) then
        return ${targetValue}
    end`;
  });

  hookCode += `
    return smods_four_fingers_ref()
end`;

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\RetriggerEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateRetriggerReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {

  const variableName =
    sameTypeCount === 0 ? "repetitions" : `repetitions${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params.repetitions,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  const messageCode = customMessage
    ? `"${customMessage}"`
    : "localize('k_again_ex')";

  return {
    statement: `repetitions = ${valueCode}`,
    message: messageCode,
    colour: "G.C.RED",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };
};

```

### src\components\codeGeneration\Jokers\effects\SavedEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import { EffectReturn } from "../effectUtils";

export const generateSavedReturn = (effect: Effect): EffectReturn => {
  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `saved = true`,
    colour: "G.C.RED",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  } else {
    result.message = `localize('k_saved_ex')`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\SetAnteEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateSetAnteReturn = (
  effect: Effect,
  triggerType: string,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = (effect.params?.operation as string) || "set";

  const variableName =
    sameTypeCount === 0 ? "ante_value" : `ante_value${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;
  let anteCode = "";
  let messageText = "";

  switch (operation) {
    case "set":
      anteCode = `local mod = ${valueCode} - G.GAME.round_resets.ante
		ease_ante(mod)
		G.E_MANAGER:add_event(Event({
			func = function()
				G.GAME.round_resets.blind_ante = ${valueCode}
				return true
			end,
		}))`;
      messageText = customMessage || `"Ante set to " .. ${valueCode} .. "!"`;
      break;
    case "add":
      anteCode = `local mod = ${valueCode}
		ease_ante(mod)
		G.E_MANAGER:add_event(Event({
			func = function()
				G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante + mod
				return true
			end,
		}))`;
      messageText = customMessage || `"Ante +" .. ${valueCode}`;
      break;
    case "subtract":
      anteCode = `local mod = -${valueCode}
		ease_ante(mod)
		G.E_MANAGER:add_event(Event({
			func = function()
				G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante + mod
				return true
			end,
		}))`;
      messageText = customMessage || `"Ante -" .. ${valueCode}`;
      break;
    default:
      anteCode = `local mod = ${valueCode} - G.GAME.round_resets.ante
		ease_ante(mod)
		G.E_MANAGER:add_event(Event({
			func = function()
				G.GAME.round_resets.blind_ante = ${valueCode}
				return true
			end,
		}))`;
      messageText = customMessage || `"Ante set to " .. ${valueCode} .. "!"`;
  }

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  const result: EffectReturn = {
    statement: isScoring
      ? `__PRE_RETURN_CODE__${anteCode}
                __PRE_RETURN_CODE_END__`
      : `func = function()
                    ${anteCode}
                    return true
                end`,
    message: customMessage ? `"${customMessage}"` : messageText,
    colour: "G.C.FILTER",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\SetDollarsEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";
import type { EffectReturn } from "../effectUtils";

export const generateSetDollarsReturn = (
  effect: Effect,
  sameTypeCount: number = 0
): EffectReturn => {
  const operation = (effect.params?.operation as string) || "add";

  const variableName =
    sameTypeCount === 0 ? "dollars" : `dollars${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  let result: EffectReturn;

  switch (operation) {
    case "add": {
      result = {
        statement: `dollars = ${valueCode}`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0 ? configVariables : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
      break;
    }

    case "subtract": {
      result = {
        statement: `dollars = -${valueCode}`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0 ? configVariables : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
      break;
    }

    case "set": {
      const setMessage = customMessage
        ? `"${customMessage}"`
        : `"Set to $"..tostring(${valueCode})`;

      result = {
        statement: `func = function()
                    local target_amount = ${valueCode}
                    local current_amount = G.GAME.dollars
                    local difference = target_amount - current_amount
                    ease_dollars(difference)
                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${setMessage}, colour = G.C.MONEY})
                    return true
                end`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0 ? configVariables : undefined,
      };
      break;
    }

    default: {
      result = {
        statement: `dollars = ${valueCode}`,
        colour: "G.C.MONEY",
        configVariables:
          configVariables.length > 0 ? configVariables : undefined,
      };

      if (customMessage) {
        result.message = `"${customMessage}"`;
      }
    }
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\SetSellValueEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";
import {
  generateConfigVariables
} from "../gameVariableUtils";

export const generateSetSellValueReturn = (
  effect: Effect,
  triggerType: string,
  sameTypeCount: number = 0
): EffectReturn => {
  const target = (effect.params?.target as string) || "specific";
  const operation: string = (effect.params?.operation as string) || "add";
  const specificTarget = (effect.params?.specific_target as string) || "self";

  const variableName =
    sameTypeCount === 0 ? "sell_value" : `sell_value${sameTypeCount + 1}`;

  const { valueCode, configVariables } = generateConfigVariables(
    effect.params?.value,
    effect.id,
    variableName
  )

  const customMessage = effect.customMessage;

  const scoringTriggers = ["hand_played", "card_scored"];
  const isScoring = scoringTriggers.includes(triggerType);

  let sellValueCode = "";
  let messageText = "";
  let targetJokerLogic = ''

  if (target == "specific") {
    if (specificTarget == "left" || specificTarget == "right" || specificTarget == "self") {
      targetJokerLogic += `local my_pos = nil
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i] == card then
                my_pos = i
                break
            end
        end
        local `}
    switch (specificTarget) {
      case "right":
        targetJokerLogic += `target_card = (my_pos and my_pos < #G.jokers.cards) and G.jokers.cards[my_pos + 1] or nil`;
        break;
      case "left":
        targetJokerLogic += `target_card = (my_pos and my_pos > 1) and G.jokers.cards[my_pos - 1] or nil`;
        break;
      case "self":
        targetJokerLogic += `target_card = G.jokers.cards[my_post]`;
        break;
      case "first":
        targetJokerLogic += `target_card = G.jokers.cards[1]`;
        break
      case "last":
        targetJokerLogic += `target_card = G.jokers.cards[#G.jokers]`;
        break
      case "random":
        targetJokerLogic += `chosenTarget = pseudorandom(3456543, 1, #G.jokers.cards) or nil
        target_card = G.jokers.cards[chosenTarget]
        end`;
        break;
    }
    sellValueCode += `${targetJokerLogic}`
  }
  if (target === "all_jokers" || target === "all") {
    sellValueCode += ``
    if (target === "all") {
      sellValueCode += `for _, area in ipairs({ G.jokers, G.consumeables }) do
       `}
    sellValueCode += `for i, target_card in ipairs(`
    if (target === "all_jokers") {
      sellValueCode += `G.jokers.cards`
    }
    else {
      sellValueCode += `area.cards`
    }
    sellValueCode += `) do
                if target_card.set_cost then`
    switch (operation) {
      case "add":
        sellValueCode += `
            target_joker.ability.extra_value = (card.ability.extra_value or 0) + ${valueCode}
            target_joker:set_cost()`;
        break;
      case "subtract":
        sellValueCode += `
            target_joker.ability.extra_value = math.max(0, (card.ability.extra_value or 0) - ${valueCode})
            target_joker:set_cost()`;
        break;
      case "set":
        sellValueCode += `
            target_joker.ability.extra_value = ${valueCode}
            target_joker:set_cost()`;
    }
    if (target === "all_jokers" || target === "all") {
      sellValueCode += `
            end
        end`
      if (target === "all") {
        sellValueCode += `
    end`
      }
    }
  }

  let messageType, messageOperation
  const typeKey: Array<Array<string>> = [["specific", ''], ["all_jokers", 'All Jokers '], ["all", 'All cards ']];
  const operationKey: Array<Array<string>> = [
    ["add", `+"..tostring(${valueCode}).." Sell Value"`],
    ["subtract", `-"..tostring(${valueCode}).." Sell Value"`],
    ["set", `Sell Value: $"..tostring(${valueCode})`]];
  operationKey.forEach(entry => {
    if (entry[0] == operation) { messageOperation = entry[1] }
  })
  typeKey.forEach(entry => {
    if (entry[0] == target) { messageType = entry[1] }
  })

  messageText = customMessage
    ? `"${customMessage}"`
    : `"${messageType}${messageOperation}`

  const result: EffectReturn = {
    statement: isScoring
      ? `__PRE_RETURN_CODE__${sellValueCode}
                __PRE_RETURN_CODE_END__`
      : `func = function()${sellValueCode}
                    return true
                end`,
    message: messageText,
    colour: "G.C.MONEY",
    configVariables: configVariables.length > 0 ? configVariables : undefined,
  };

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\ShortcutEffect.ts

```
import type { PassiveEffectResult } from "../effectUtils";

export const generateShortcutReturn = (
  jokerKey?: string
): PassiveEffectResult => {
  return {
    addToDeck: `-- Shortcut straights enabled`,
    removeFromDeck: `-- Shortcut straights disabled`,
    configVariables: [],
    locVars: [],
    needsHook: {
      hookType: "shortcut",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {},
    },
  };
};

export const generateShortcutHook = (
  shortcutJokers: Array<{
    jokerKey: string;
    params: Record<string, unknown>;
  }>,
  modPrefix: string
): string => {
  if (shortcutJokers.length === 0) return "";

  let hookCode = `
local smods_shortcut_ref = SMODS.shortcut
function SMODS.shortcut()`;

  shortcutJokers.forEach(({ jokerKey }) => {
    const fullJokerKey = `j_${modPrefix}_${jokerKey}`;

    hookCode += `
    if next(SMODS.find_card("${fullJokerKey}")) then
        return true
    end`;
  });

  hookCode += `
    return smods_shortcut_ref()
end`;

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\ShowmanEffect.ts

```
import type { PassiveEffectResult } from "../effectUtils";

export const generateShowmanReturn = (
  jokerKey?: string
): PassiveEffectResult => {
  return {
    addToDeck: `-- Showman effect enabled (allow duplicate cards)`,
    removeFromDeck: `-- Showman effect disabled`,
    configVariables: [],
    locVars: [],
    needsHook: {
      hookType: "showman",
      jokerKey: jokerKey || "PLACEHOLDER",
      effectParams: {},
    },
  };
};

export const generateShowmanHook = (
  showmanJokers: Array<{
    jokerKey: string;
    params: Record<string, unknown>;
  }>,
  modPrefix: string
): string => {
  if (showmanJokers.length === 0) return "";

  let hookCode = `
local smods_showman_ref = SMODS.showman
function SMODS.showman(card_key)`;

  showmanJokers.forEach(({ jokerKey }) => {
    const fullJokerKey = `j_${modPrefix}_${jokerKey}`;

    hookCode += `
    if next(SMODS.find_card("${fullJokerKey}")) then
        return true
    end`;
  });

  hookCode += `
    return smods_showman_ref(card_key)
end`;

  return hookCode;
};

```

### src\components\codeGeneration\Jokers\effects\ShowMessageEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateShowMessageReturn = (effect: Effect): EffectReturn => {
  const colour = (effect.params?.colour as string) || "G.C.WHITE";
  const customMessage = effect.customMessage;

  const messageCode = customMessage ? `"${customMessage}"` : '"Message!"';

  return {
    statement: "",
    message: messageCode,
    colour: colour,
  };
};

```

### src\components\codeGeneration\Jokers\effects\ShuffleJokersEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateShuffleJokerReturn = (
  effect: Effect,
): EffectReturn => {
  const customMessage = effect.customMessage;

  const jokerShuffleCode = `if #G.jokers.cards > 1 then
  G.jokers:unhighlight_all()
  G.E_MANAGER:add_event(Event({
      trigger = 'before',
      func = function()
          G.E_MANAGER:add_event(Event({
              func = function()
                  G.jokers:shuffle('aajk')
                  play_sound('cardSlide1', 0.85)
                  return true
              end,
          }))
          delay(0.15)
          G.E_MANAGER:add_event(Event({
              func = function()
                  G.jokers:shuffle('aajk')
                  play_sound('cardSlide1', 1.15)
                  return true
              end
          }))
          delay(0.15)
          G.E_MANAGER:add_event(Event({
              func = function()
                  G.jokers:shuffle('aajk')
                  play_sound('cardSlide1', 1)
                  return true
              end
          }))
        delay(0.5)
        return true
      end
    }))
  end`;

  return {
    statement: `__PRE_RETURN_CODE__${jokerShuffleCode}__PRE_RETURN_CODE_END__`,
    message: customMessage ?? `"Shuffle!"`,
    colour: "G.C.ORANGE"
  }
};

```

### src\components\codeGeneration\Jokers\effects\SplashEffect.ts

```
import type { PassiveEffectResult } from "../effectUtils";

export const generatePassiveSplashEffect = (): PassiveEffectResult => {
  const calculateFunction = `
        if context.modify_scoring_hand and not context.blueprint then
            return {
                add_to_hand = true
            }
        end`;

  return {
    calculateFunction,
    configVariables: [],
    locVars: [],
  };
};

```

### src\components\codeGeneration\Jokers\effects\SwapChipsMultEffect.ts

```
import type { Effect } from "../../../ruleBuilder/types";
import type { EffectReturn } from "../effectUtils";

export const generateSwapChipsMultReturn = (
  effect: Effect,
): EffectReturn => {

  const customMessage = effect.customMessage;

  const result: EffectReturn = {
    statement: `swap = true`,
    colour: "G.C.CHIPS",
  };

  if (customMessage) {
    result.message = `"${customMessage}"`;
  }

  return result;
};

```

### src\components\codeGeneration\Jokers\effects\UnlockJokerEffect.ts

```
import type { EffectReturn } from "../effectUtils";
import type { Effect } from "../../../ruleBuilder/types";

export const generateUnlockJokerReturn = (
  effect: Effect
): EffectReturn => {
  const jokerKey = (effect.params?.joker_key as string) || "";
  const discover = (effect.params?.discover as string) === "true" ? true : false
  const customMessage = effect.customMessage;

  const normalizedJokerKey = jokerKey.startsWith("j_") 
  ? jokerKey 
  : `j_${jokerKey}`

  return {
    statement: `func = function()
      local target_joker = G.P_CENTERS["${normalizedJokerKey}"]
      if target_joker then
        unlock_card(target_joker)
        ${discover ? "discover_card(target_joker)" : ""}
        ${customMessage ? `SMODS.calculate_effect({message = "${customMessage}"}, card)` : ""}
      else
        error("JOKERFORGE: Invalid joker key in Unlock Joker Effect. Did you forget the modprefix or misspelled the key?")
      end
      return true
    end`,
    colour: "G.C.BLUE"
  }
};

```

### src\components\codeGeneration\Jokers\effectUtils.ts

```
import type { Effect, LoopGroup, RandomGroup } from "../../ruleBuilder/types";
import type { JokerData } from "../../data/BalatroUtils";
import { coordinateVariableConflicts } from "./variableUtils";
import { generateAddMultReturn } from "./effects/AddMultEffect";
import { generateApplyXMultReturn } from "./effects/ApplyXMultEffect";
import { generateRetriggerReturn } from "./effects/RetriggerEffect";
import { generateDestroySelfReturn } from "./effects/DestroySelfEffect";
import { generateEditHandReturn } from "./effects/EditHandEffect";
import { generateEditDiscardReturn } from "./effects/EditDiscardEffect";
import { generateEditHandSizeReturn } from "./effects/EditHandSizeEffect";
import { generateLevelUpHandReturn } from "./effects/LevelUpHandEffect";
import { generateAddCardToDeckReturn } from "./effects/AddCardToDeckEffect";
import { generateCopyCardToDeckReturn } from "./effects/CopyCardToDeckEffect";
import { generateDeleteCardReturn } from "./effects/DeleteCardEffect";
import { generateEditCardReturn } from "./effects/EditCardEffect";
import { generateModifyInternalVariableReturn } from "./effects/ModifyInternalVariableEffect";
import { generateDestroyConsumableReturn } from "./effects/DestroyConsumableEffect";
import { generateCopyConsumableReturn } from "./effects/CopyConsumableEffect";
import { generateCreateJokerReturn } from "./effects/CreateJokerEffect";
import { generateCopyJokerReturn } from "./effects/CopyJokerEffect";
import { generateDestroyJokerReturn } from "./effects/DestroyJokerEffect";
import { generatePassiveHandSize } from "./effects/EditHandSizeEffect";
import { generatePassiveHand } from "./effects/EditHandEffect";
import { generatePassiveDiscard } from "./effects/EditDiscardEffect";
import { generatePassiveCombineRanks } from "./effects/CombineRanksEffect";
import { generateApplyXChipsReturn } from "./effects/ApplyXChipsEffect";
import { generateCreateTagReturn } from "./effects/CreateTagEffect";
import { generateApplyExpMultReturn } from "./effects/ApplyExpMultEffect";
import { generateApplyExpChipsReturn } from "./effects/ApplyExpChipsEffect";
import { generateShowMessageReturn } from "./effects/ShowMessageEffect";
import { generateSetDollarsReturn } from "./effects/SetDollarsEffect";
import {
  generateDisableBossBlindReturn,
  generatePassiveDisableBossBlind,
} from "./effects/DisableBossBlindEffect";
import { generateSavedReturn } from "./effects/SavedEffect";
import { generateSetSellValueReturn } from "./effects/SetSellValueEffect";
import { generateBalanceReturn } from "./effects/BalanceEffect";
import { generateChangeSuitVariableReturn } from "./effects/ChangeSuitVariableEffect";
import { generateChangeRankVariableReturn } from "./effects/ChangeRankVariableEffect";
import {
  generateFreeRerollsReturn,
  generateDiscountItemsReturn,
} from "./effects/DiscountItemsEffect";
import { generateChangePokerHandVariableReturn } from "./effects/ChangePokerHandVariableEffect";
import { generatePassiveCopyJokerAbility } from "./effects/CopyJokerAbilityEffect";
import { generatePermaBonusReturn } from "./effects/PermaBonusEffect";
import { generateSetAnteReturn } from "./effects/SetAnteEffect";
import { generateAddCardToHandReturn } from "./effects/AddCardToHandEffect";
import { generateCopyCardToHandReturn } from "./effects/CopyCardToHandEffect";
import { generatePassiveSplashEffect } from "./effects/SplashEffect";
import { generatePassiveAllowDebt } from "./effects/AllowDebtEffect";
import { generateReduceFlushStraightRequirementsReturn } from "./effects/ReduceFlushStraightRequirementsEffect";
import { generateShortcutReturn } from "./effects/ShortcutEffect";
import { generateShowmanReturn } from "./effects/ShowmanEffect";
import { generatePassiveCombineSuits } from "./effects/CombineSuitsEffect";
import {
  generateEditConsumableSlotsReturn,
  generatePassiveConsumableSlots,
} from "./effects/EditConsumableSlotsEffect";
import {
  generateEditJokerSlotsReturn,
  generatePassiveJokerSlots,
} from "./effects/EditJokerSlotsEffect";
import { generateAddChipsReturn } from "./effects/AddChipsEffect";
import { generateCreateConsumableReturn } from "./effects/CreateConsumableEffect";
import { generateModifyBlindRequirementReturn } from "./effects/ModifyBlindRequirementEffect";
import { generateBeatCurrentBlindReturn } from "./effects/BeatCurrentBlindEffect";
import { generateFixProbabilityReturn } from "./effects/FixProbabilityEffect";
import { generateModProbabilityReturn } from "./effects/ModProbabilityEffect";
import { generateForceGameOverReturn } from "./effects/ForceGameOverEffect";
import { generateJuiceUpReturn } from "./effects/JuiceUpEffect";
import { generateDrawCardsReturn } from "./effects/DrawCardsEffect";
import {
  generateEditVoucherSlotsReturn,
  generatePassiveVoucherSlots,
} from "./effects/EditVoucherSlotsEffect";
import {
  generateEditBoosterSlotsReturn,
  generatePassiveBoosterSlots,
} from "./effects/EditBoosterSlotsEffect";
import {
  generateEditPlaySizeReturn,
  generatePassivePlaySize,
} from "./effects/EditPlaySizeEffect";
import {
  generateEditDiscardSizeReturn,
  generatePassiveDiscardSize,
} from "./effects/EditDiscardSizeEffect";
import { generateEmitFlagReturn } from "./effects/EmitFlagEffect";
import { generateUnlockJokerReturn } from "./effects/UnlockJokerEffect";
import { generateRedeemVoucherReturn } from "./effects/RedeemVoucherEffect";
import { generateFlipJokerReturn } from "./effects/FlipJokerEffect";
import { generateShuffleJokerReturn } from "./effects/ShuffleJokersEffect";
import { generatePlaySoundReturn } from "./effects/PlaySoundEffect";
import { generateApplyHyperChipsReturn } from "./effects/ApplyHyperChipsEffect";
import { generateApplyHyperMultReturn } from "./effects/ApplyHyperMultEffect";
import { generateSwapChipsMultReturn } from "./effects/SwapChipsMultEffect";


interface ExtendedEffect extends Effect {
  _isInRandomGroup?: boolean;
  _ruleContext?: string;
  _effectIndex?: number;
}

export interface PassiveEffectResult {
  addToDeck?: string;
  removeFromDeck?: string;
  configVariables?: string[];
  locVars?: string[];
  calculateFunction?: string;
  needsHook?: {
    hookType: string;
    jokerKey: string;
    effectParams: unknown;
  };
}

export interface ConfigExtraVariable {
  name: string;
  value: number | string;
  description?: string;
}

export interface EffectReturn {
  statement: string;
  message?: string;
  colour: string;
  configVariables?: ConfigExtraVariable[];
  effectType?: string;
}

export interface ReturnStatementResult {
  statement: string;
  colour: string;
  preReturnCode?: string;
  isRandomChance?: boolean;
  configVariables?: ConfigExtraVariable[];
}

export interface CalculateFunctionResult {
  code: string;
  configVariables: ConfigExtraVariable[];
}

export function generateEffectReturnStatement(
  regularEffects: Effect[] = [],
  randomGroups: RandomGroup[] = [],
  loopGroups: LoopGroup[] = [],
  triggerType: string = "hand_played",
  modprefix: string,
  jokerKey?: string,
  ruleId?: string,
  globalEffectCounts?: Map<string, number>
): ReturnStatementResult {
  if (regularEffects.length === 0 && randomGroups.length === 0 && loopGroups.length === 0) {
    return {
      statement: "",
      colour: "G.C.WHITE",
      configVariables: [],
    };
  }

  let combinedPreReturnCode = "";
  let mainReturnStatement = "";
  let primaryColour = "G.C.WHITE";
  const allConfigVariables: ConfigExtraVariable[] = [];

  if (regularEffects.length > 0) {
    const { preReturnCode: regularPreCode, modifiedEffects } =
      coordinateVariableConflicts(regularEffects);

    const effectReturns: EffectReturn[] = modifiedEffects
      .map((effect) => {
        const effectWithContext: ExtendedEffect = {
          ...effect,
          _ruleContext: ruleId,
        };

        const currentCount = globalEffectCounts?.get(effect.type) || 0;
        if (globalEffectCounts) {
          globalEffectCounts.set(effect.type, currentCount + 1);
        }

        const result = generateSingleEffect(
          effectWithContext,
          triggerType,
          currentCount,
          modprefix
        );
        return {
          ...result,
          effectType: effect.type,
        };
      })
      .filter((ret) => ret.statement || ret.message);

    if (regularPreCode) {
      combinedPreReturnCode += regularPreCode;
    }

    effectReturns.forEach((effectReturn) => {
      if (effectReturn.configVariables) {
        allConfigVariables.push(...effectReturn.configVariables);
      }
    });

    const processedEffects: EffectReturn[] = [];
    effectReturns.forEach((effect) => {
      const { cleanedStatement, preReturnCode } = extractPreReturnCode(
        effect.statement
      );

      if (preReturnCode) {
        combinedPreReturnCode +=
          (combinedPreReturnCode ? "\n                " : "") + preReturnCode;
      }

      processedEffects.push({
        ...effect,
        statement: cleanedStatement,
      });
    });

    if (processedEffects.length > 0) {
      mainReturnStatement = buildReturnStatement(processedEffects);
      primaryColour = processedEffects[0]?.colour ?? "G.C.WHITE";
    }
  }

  if (randomGroups.length > 0) {
    const randomGroupStatements: string[] = [];

    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator as number)),
    ];
    const denominatorToOddsVar: Record<number, string> = {};

    if (denominators.length === 1) {
      denominatorToOddsVar[denominators[0]] = "card.ability.extra.odds";
      allConfigVariables.push({
        name: "odds",
        value: denominators[0],
        description: "Probability denominator",
      });
    } else {
      denominators.forEach((denom, index) => {
        if (index === 0) {
          denominatorToOddsVar[denom] = "card.ability.extra.odds";
          allConfigVariables.push({
            name: "odds",
            value: denom,
            description: "First probability denominator",
          });
        } else {
          denominatorToOddsVar[denom] = `card.ability.extra.odds${index + 1}`;
          allConfigVariables.push({
            name: `odds${index + 1}`,
            value: denom,
            description: `${index + 1}${getOrdinalSuffix(
              index + 1
            )} probability denominator`,
          });
        }
      });
    }

    randomGroups.forEach((group, groupIndex) => {
      const { preReturnCode: groupPreCode, modifiedEffects } =
        coordinateVariableConflicts(group.effects);

      const effectReturns: EffectReturn[] = modifiedEffects
        .map((effect) => {
          const effectWithContext: ExtendedEffect = {
            ...effect,
            _ruleContext: ruleId,
            _isInRandomGroup: true,
          };

          const currentCount = globalEffectCounts?.get(effect.type) || 0;
          if (globalEffectCounts) {
            globalEffectCounts.set(effect.type, currentCount + 1);
          }

          const result = generateSingleEffect(
            effectWithContext,
            triggerType,
            currentCount,
            modprefix
          );
          return {
            ...result,
            effectType: effect.type,
          };
        })
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          allConfigVariables.push(...effectReturn.configVariables);
        }
      });

      if (effectReturns.length === 0) return;

      let groupPreReturnCode = groupPreCode || "";
      const processedEffects: EffectReturn[] = [];

      effectReturns.forEach((effect) => {
        const { cleanedStatement, preReturnCode } = extractPreReturnCode(
          effect.statement
        );

        if (preReturnCode) {
          groupPreReturnCode +=
            (groupPreReturnCode ? "\n                        " : "") +
            preReturnCode;
        }

        processedEffects.push({
          ...effect,
          statement: cleanedStatement,
        });
      });

      const oddsVar = denominatorToOddsVar[group.chance_denominator as number];
      const probabilityIdentifier = `group_${groupIndex}_${group.id.substring(
        0,
        8
      )}`;

      let groupContent = "";

      const hasDeleteInGroup = group.effects.some(
        (effect) => effect.type === "delete_triggered_card"
      );

      if (
        hasDeleteInGroup &&
        (triggerType === "card_scored" ||
          triggerType === "card_held_in_hand" ||
          triggerType === "card_held_in_hand_end_of_round")
      ) {
        groupContent += `context.other_card.should_destroy = true
                        `;
      }

      if (groupPreReturnCode && groupPreReturnCode.trim()) {
        groupContent += `${groupPreReturnCode}
                        `;
      }

      const isRetriggerEffect = (effect: EffectReturn): boolean => {
        return (
          effect.effectType === "retrigger_cards" ||
          (effect.statement
            ? effect.statement.includes("repetitions") ||
              effect.statement.includes("repetition")
            : false)
        );
      };

      const retriggerEffects = processedEffects.filter(isRetriggerEffect);
      const nonRetriggerEffects = processedEffects.filter(
        (effect) => !isRetriggerEffect(effect)
      );
      const hasFixProbablityEffects = processedEffects.some(
        (effect) => effect.effectType === "fix_probability"
      );
      const hasModProbablityEffects = processedEffects.some(
        (effect) => effect.effectType === "mod_probability"
      );

      if (retriggerEffects.length > 0) {
        const retriggerStatements = retriggerEffects
          .filter((effect) => effect.statement && effect.statement.trim())
          .map((effect) => effect.statement);

        if (retriggerStatements.length > 0) {
          const returnObj = `{${retriggerStatements.join(", ")}}`;
          groupContent += `return ${returnObj}
                        `;
        }
      }

      const effectCalls: string[] = [];
      nonRetriggerEffects.forEach((effect) => {
        if (effect.statement && effect.statement.trim()) {
          const effectObj = `{${effect.statement}}`;
          effectCalls.push(`SMODS.calculate_effect(${effectObj}, card)`);
        }
        if (effect.message) {
          effectCalls.push(
            `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
              effect.message
            }, colour = ${effect.colour || "G.C.WHITE"}})`
          );
        }
      });

      if (effectCalls.length > 0) {
        groupContent += effectCalls.join("\n                        ");
      }

      const no_modParam = (
        hasFixProbablityEffects || hasModProbablityEffects // prevents stack overflow
      ) || group.respect_probability_effects === false;
      
      const probabilityStatement =  `SMODS.pseudorandom_probability(card, '${probabilityIdentifier}', ${group.chance_numerator}, ${oddsVar}, '${group.custom_key || `j_${modprefix}_${jokerKey}`}', ${no_modParam})`;
      
      const groupStatement = `if ${probabilityStatement} then
              ${groupContent}
          end`;

      randomGroupStatements.push(groupStatement);
    });

    if (mainReturnStatement && randomGroupStatements.length > 0) {
      const randomGroupCode = randomGroupStatements.join(
        "\n                    "
      );
      const funcStatement = `func = function()
                        ${randomGroupCode}
                        return true
                    end`;

      if (
        mainReturnStatement.includes("return {") &&
        mainReturnStatement.includes("}")
      ) {
        const insertIndex = mainReturnStatement.lastIndexOf("}");
        mainReturnStatement =
          mainReturnStatement.slice(0, insertIndex) +
          `,
                    ${funcStatement}
                ${mainReturnStatement.slice(insertIndex)}`;
      }
    } else if (!mainReturnStatement && randomGroupStatements.length > 0) {
      mainReturnStatement = randomGroupStatements.join("\n                ");
      if (randomGroups.length > 0 && randomGroups[0].effects.length > 0) {
        const firstEffect = randomGroups[0].effects[0];
        const firstEffectResult = generateSingleEffect(
          firstEffect,
          triggerType,
          0,
          modprefix
        );
        primaryColour = firstEffectResult.colour || "G.C.WHITE";
      }
    }
  }
  
  if (loopGroups.length > 0) {
    const loopGroupStatements: string[] = [];

    const repetitions = [
      ...new Set(loopGroups.map((group) => group.repetitions as number)),
    ];
    const repetitionsToVar: Record<number, string> = {};

    if (repetitions.length === 1) {
      repetitionsToVar[repetitions[0]] = "card.ability.extra.repetitions";
      if (!(typeof repetitions[0] === "string")) {
        allConfigVariables.push({
          name: "repetitions",
          value: repetitions[0],
          description: "Loop repetitions",
        });
      }
    } else {
      repetitions.forEach((denom, index) => {
        if (index === 0) {
          repetitionsToVar[denom] = "card.ability.extra.repetitions";
          if (!(typeof denom === "string")) {
            allConfigVariables.push({
              name: "repetitions",
              value: denom,
              description: "First loop repetitions",
            });
          }
        } else {
          repetitionsToVar[denom] = `card.ability.extra.repetitions${index + 1}`;
          if (!(typeof denom === "string")) {
            allConfigVariables.push({
              name: `repetitions${index + 1}`,
              value: denom,
              description: `${index + 1}${getOrdinalSuffix(
                index + 1
              )} loop repetitions`,
            });
          }
        }
      });
    }

    loopGroups.forEach((group) => {
      const { preReturnCode: groupPreCode, modifiedEffects } =
        coordinateVariableConflicts(group.effects);

      const effectReturns: EffectReturn[] = modifiedEffects
        .map((effect) => {
          const effectWithContext: ExtendedEffect = {
            ...effect,
            _ruleContext: ruleId,
            _isInRandomGroup: true,
          };

          const currentCount = globalEffectCounts?.get(effect.type) || 0;
          if (globalEffectCounts) {
            globalEffectCounts.set(effect.type, currentCount + 1);
          }

          const result = generateSingleEffect(
            effectWithContext,
            triggerType,
            currentCount,
            modprefix
          );
          return {
            ...result,
            effectType: effect.type,
          };
        })
        .filter((ret) => ret.statement || ret.message);

      effectReturns.forEach((effectReturn) => {
        if (effectReturn.configVariables) {
          allConfigVariables.push(...effectReturn.configVariables);
        }
      });

      if (effectReturns.length === 0) return;

      let groupPreReturnCode = groupPreCode || "";
      const processedEffects: EffectReturn[] = [];

      effectReturns.forEach((effect) => {
        const { cleanedStatement, preReturnCode } = extractPreReturnCode(
          effect.statement
        );

        if (preReturnCode) {
          groupPreReturnCode +=
            (groupPreReturnCode ? "\n                        " : "") +
            preReturnCode;
        }

        processedEffects.push({
          ...effect,
          statement: cleanedStatement,
        });
      });

      const repetitionsVar = typeof group.repetitions === "string" ? group.repetitions : repetitionsToVar[group.repetitions as number];

      let groupContent = "";

      const hasDeleteInGroup = group.effects.some(
        (effect) => effect.type === "delete_triggered_card"
      );

      if (
        hasDeleteInGroup &&
        (triggerType === "card_scored" ||
          triggerType === "card_held_in_hand" ||
          triggerType === "card_held_in_hand_end_of_round")
      ) {
        groupContent += `context.other_card.should_destroy = true
                        `;
      }

      if (groupPreReturnCode && groupPreReturnCode.trim()) {
        groupContent += `${groupPreReturnCode}
                        `;
      }

      const isRetriggerEffect = (effect: EffectReturn): boolean => {
        return (
          effect.effectType === "retrigger_cards" ||
          (effect.statement
            ? effect.statement.includes("repetitions") ||
              effect.statement.includes("repetition")
            : false)
        );
      };

      const retriggerEffects = processedEffects.filter(isRetriggerEffect);
      const nonRetriggerEffects = processedEffects.filter(
        (effect) => !isRetriggerEffect(effect)
      );

      if (retriggerEffects.length > 0) {
        const retriggerStatements = retriggerEffects
          .filter((effect) => effect.statement && effect.statement.trim())
          .map((effect) => effect.statement);

        if (retriggerStatements.length > 0) {
          const returnObj = `{${retriggerStatements.join(", ")}}`;
          groupContent += `return ${returnObj}
                        `;
        }
      }

      const effectCalls: string[] = [];
      nonRetriggerEffects.forEach((effect) => {
        if (effect.statement && effect.statement.trim()) {
          const effectObj = `{${effect.statement}}`;
          effectCalls.push(`SMODS.calculate_effect(${effectObj}, card)`);
        }
        if (effect.message) {
          effectCalls.push(
            `card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = ${
              effect.message
            }, colour = ${effect.colour || "G.C.WHITE"}})`
          );
        }
      });

      if (effectCalls.length > 0) {
        groupContent += effectCalls.join("\n                        ");
      }

      
      const loopStatement =  `for i = 1, ${repetitionsVar} do`;
      
      const groupStatement = `${loopStatement}
              ${groupContent}
          end`;

      loopGroupStatements.push(groupStatement);
    });

    if (mainReturnStatement && loopGroupStatements.length > 0) {
      const loopGroupCode = loopGroupStatements.join(
        "\n                    "
      );
      const funcStatement = `func = function()
                        ${loopGroupCode}
                        return true
                    end`;

      if (
        mainReturnStatement.includes("return {") &&
        mainReturnStatement.includes("}")
      ) {
        const insertIndex = mainReturnStatement.lastIndexOf("}");
        mainReturnStatement =
          mainReturnStatement.slice(0, insertIndex) +
          `,
                    ${funcStatement}
                ${mainReturnStatement.slice(insertIndex)}`;
      }
    } else if (!mainReturnStatement && loopGroupStatements.length > 0) {
      mainReturnStatement = loopGroupStatements.join("\n                ");
      if (loopGroups.length > 0 && loopGroups[0].effects.length > 0) {
        const firstEffect = loopGroups[0].effects[0];
        const firstEffectResult = generateSingleEffect(
          firstEffect,
          triggerType,
          0,
          modprefix
        );
        primaryColour = firstEffectResult.colour || "G.C.WHITE";
      }
    }
  }
  return {
    statement: mainReturnStatement,
    colour: primaryColour,
    preReturnCode: combinedPreReturnCode || undefined,
    isRandomChance: randomGroups.length > 0,
    configVariables: allConfigVariables,
  };
}

const generateSingleEffect = (
  effect: ExtendedEffect,
  triggerType: string,
  sameTypeCount: number = 0,
  modprefix: string
): EffectReturn => {
  switch (effect.type) {
    case "add_chips":
      return generateAddChipsReturn(effect, sameTypeCount);
    case "add_mult":
      return generateAddMultReturn(effect, sameTypeCount);
    case "apply_x_mult":
      return generateApplyXMultReturn(effect, sameTypeCount);
    case "retrigger_cards":
      return generateRetriggerReturn(effect, sameTypeCount);
    case "destroy_self":
      return generateDestroySelfReturn(effect);
    case "edit_hand":
      return generateEditHandReturn(effect, sameTypeCount);
    case "edit_discard":
      return generateEditDiscardReturn(effect, sameTypeCount);
    case "edit_hand_size":
      return generateEditHandSizeReturn(effect, sameTypeCount);
    case "draw_cards":
      return generateDrawCardsReturn(effect, sameTypeCount);
    case "level_up_hand":
      return generateLevelUpHandReturn(triggerType, effect, sameTypeCount);
    case "add_card_to_deck":
      return generateAddCardToDeckReturn(effect, triggerType);
    case "copy_triggered_card":
      return generateCopyCardToDeckReturn(effect, triggerType);
    case "copy_played_card":
      return generateCopyCardToDeckReturn(effect, triggerType);
    case "delete_triggered_card":
      return generateDeleteCardReturn(effect, triggerType);
    case "edit_triggered_card":
      return generateEditCardReturn(effect, triggerType);
    case "modify_internal_variable":
      return generateModifyInternalVariableReturn(effect, triggerType);
    case "destroy_consumable":
      return generateDestroyConsumableReturn(effect, triggerType);
    case "copy_consumable":
      return generateCopyConsumableReturn(effect, triggerType);
    case "create_joker":
      return generateCreateJokerReturn(effect, triggerType, modprefix);
    case "copy_joker":
      return generateCopyJokerReturn(effect, triggerType);
    case "destroy_joker":
      return generateDestroyJokerReturn(effect, triggerType);
    case "apply_x_chips":
      return generateApplyXChipsReturn(effect, sameTypeCount);
    case "create_tag":
      return generateCreateTagReturn(effect, triggerType);
    case "apply_exp_mult":
      return generateApplyExpMultReturn(effect, sameTypeCount);
    case "apply_exp_chips":
      return generateApplyExpChipsReturn(effect, sameTypeCount);
    case "apply_hyper_mult":
      return generateApplyHyperMultReturn(effect, sameTypeCount);
    case "apply_hyper_chips":
      return generateApplyHyperChipsReturn(effect, sameTypeCount);
    case "show_message":
      return generateShowMessageReturn(effect);
    case "set_dollars":
      return generateSetDollarsReturn(effect, sameTypeCount);
    case "disable_boss_blind":
      return generateDisableBossBlindReturn(effect, triggerType);
    case "prevent_game_over":
      return generateSavedReturn(effect);
    case "set_sell_value":
      return generateSetSellValueReturn(effect, triggerType, sameTypeCount);
    case "balance":
      return generateBalanceReturn(effect);
    case "swap_chips_mult":
      return generateSwapChipsMultReturn(effect);
    case "change_suit_variable":
      return generateChangeSuitVariableReturn(effect);
    case "change_rank_variable":
      return generateChangeRankVariableReturn(effect);
    case "change_pokerhand_variable":
      return generateChangePokerHandVariableReturn(effect);
    case "permanent_bonus":
      return generatePermaBonusReturn(effect, sameTypeCount);
    case "set_ante":
      return generateSetAnteReturn(effect, triggerType, sameTypeCount);
    case "add_card_to_hand":
      return generateAddCardToHandReturn(effect, triggerType);
    case "copy_triggered_card_to_hand":
      return generateCopyCardToHandReturn(effect, triggerType);
    case "copy_played_card_to_hand":
      return generateCopyCardToHandReturn(effect, triggerType);
    case "edit_consumable_slots":
      return generateEditConsumableSlotsReturn(effect, sameTypeCount);
    case "edit_joker_slots":
      return generateEditJokerSlotsReturn(effect, sameTypeCount);
    case "edit_voucher_slots":
      return generateEditVoucherSlotsReturn(effect, sameTypeCount);
    case "edit_booster_slots":
      return generateEditBoosterSlotsReturn(effect, sameTypeCount);
    case "create_consumable":
      return generateCreateConsumableReturn(effect, triggerType);
    case "modify_blind_requirement":
      return generateModifyBlindRequirementReturn(effect, sameTypeCount);
    case "beat_current_blind":
      return generateBeatCurrentBlindReturn(effect);
    case "fix_probability":
      return generateFixProbabilityReturn(effect, sameTypeCount);
    case "mod_probability":
      return generateModProbabilityReturn(effect, sameTypeCount);
    case "force_game_over":
      return generateForceGameOverReturn(effect);
    case "juice_up_joker":
      return generateJuiceUpReturn(effect, sameTypeCount, "joker");
    case "emit_flag":
      return generateEmitFlagReturn(effect, modprefix);
    case "play_sound":
      return generatePlaySoundReturn(effect, modprefix);
    case "juice_up_card":
      return generateJuiceUpReturn(effect, sameTypeCount, "card");
    case "edit_play_size":
      return generateEditPlaySizeReturn(effect, sameTypeCount);
    case "edit_discard_size":
      return generateEditDiscardSizeReturn(effect, sameTypeCount);
    case "unlock_joker":
      return generateUnlockJokerReturn(effect);
    case "redeem_voucher":
      return generateRedeemVoucherReturn(effect);
    case "flip_joker":
      return generateFlipJokerReturn(effect);
    case "shuffle_jokers":
      return generateShuffleJokerReturn(effect);

    default:
      return {
        statement: "",
        colour: "G.C.WHITE",
      };
  }
};

const buildReturnStatement = (effects: EffectReturn[]): string => {
  if (effects.length === 0) return "";

  let firstContentEffectIndex = -1;
  for (let i = 0; i < effects.length; i++) {
    const effect = effects[i];
    if (effect.statement.trim().length > 0 || effect.message) {
      firstContentEffectIndex = i;
      break;
    }
  }

  if (firstContentEffectIndex === -1) {
    return "";
  }

  const firstContentEffect = effects[firstContentEffectIndex];
  const hasFirstStatement = firstContentEffect.statement.trim().length > 0;

  let returnStatement = "";

  if (hasFirstStatement) {
    returnStatement = `return {
                    ${firstContentEffect.statement}`;

    if (firstContentEffect.message) {
      returnStatement += `,
                    message = ${firstContentEffect.message}`;
    }
  } else if (firstContentEffect.message) {
    returnStatement = `return {
                    message = ${firstContentEffect.message}`;
  }

  const remainingEffects = effects.slice(firstContentEffectIndex + 1);
  if (remainingEffects.length > 0) {
    let extraChain = "";
    let extraCount = 0;

    for (let i = 0; i < remainingEffects.length; i++) {
      const effect = remainingEffects[i];
      const hasStatement = effect.statement.trim().length > 0;

      let extraContent = "";
      if (hasStatement) {
        extraContent = effect.statement;
        if (effect.message) {
          extraContent += `,
                            message = ${effect.message}`;
        }
      } else if (effect.message) {
        extraContent = `message = ${effect.message}`;
      }

      if (!extraContent) continue;

      if (extraCount === 0) {
        extraChain = `,
                    extra = {
                        ${extraContent}`;

        if (effect.colour && effect.colour.trim()) {
          extraChain += `,
                        colour = ${effect.colour}`;
        }
      } else {
        extraChain += `,
                        extra = {
                            ${extraContent}`;

        if (effect.colour && effect.colour.trim()) {
          extraChain += `,
                            colour = ${effect.colour}`;
        }
      }
      extraCount++;
    }

    for (let i = 0; i < extraCount; i++) {
      extraChain += `
                        }`;
    }

    returnStatement += extraChain;
  }

  returnStatement += `
                }`;

  return returnStatement;
};

export const processPassiveEffects = (
  joker: JokerData
): PassiveEffectResult[] => {
  const passiveEffects: PassiveEffectResult[] = [];

  if (!joker.rules) return passiveEffects;

  joker.rules
    .filter((rule) => rule.trigger === "passive")
    .forEach((rule) => {
      rule.effects?.forEach((effect) => {
        let passiveResult: PassiveEffectResult | null = null;

        const jokerKey = joker.jokerKey;

        switch (effect.type) {
          case "edit_hand_size":
            passiveResult = generatePassiveHandSize(effect);
            break;
          case "edit_hand":
            passiveResult = generatePassiveHand(effect);
            break;
          case "edit_discard":
            passiveResult = generatePassiveDiscard(effect);
            break;
          case "combine_ranks": {
            passiveResult = generatePassiveCombineRanks(effect, jokerKey);
            break;
          }
          case "combine_suits": {
            passiveResult = generatePassiveCombineSuits(effect, jokerKey);
            break;
          }
          case "disable_boss_blind": {
            passiveResult = generatePassiveDisableBossBlind(effect);
            break;
          }
          case "free_rerolls": {
            passiveResult = generateFreeRerollsReturn(effect);
            break;
          }
          case "discount_items": {
            passiveResult = generateDiscountItemsReturn(effect, jokerKey);
            break;
          }
          case "copy_joker_ability": {
            passiveResult = generatePassiveCopyJokerAbility(effect);
            break;
          }
          case "splash_effect": {
            passiveResult = generatePassiveSplashEffect();
            break;
          }
          case "allow_debt": {
            passiveResult = generatePassiveAllowDebt(effect);
            break;
          }
          case "reduce_flush_straight_requirements": {
            passiveResult = generateReduceFlushStraightRequirementsReturn(
              effect,
              jokerKey
            );
            break;
          }
          case "shortcut": {
            passiveResult = generateShortcutReturn(jokerKey);
            break;
          }
          case "showman": {
            passiveResult = generateShowmanReturn(jokerKey);
            break;
          }
          case "edit_consumable_slots": {
            passiveResult = generatePassiveConsumableSlots(effect);
            break;
          }
          case "edit_joker_slots": {
            passiveResult = generatePassiveJokerSlots(effect);
            break;
          }
          case "edit_voucher_slots": {
            passiveResult = generatePassiveVoucherSlots(effect);
            break;
          }
          case "edit_booster_slots": {
            passiveResult = generatePassiveBoosterSlots(effect);
            break;
          }
          case "edit_play_size": {
            passiveResult = generatePassivePlaySize(effect);
            break;
          }
          case "edit_discard_size": {
            passiveResult = generatePassiveDiscardSize(effect);
            break;
          }
        }
        if (passiveResult) {
          passiveEffects.push(passiveResult);
        }
      });
    });

  return passiveEffects;
};

function extractPreReturnCode(statement: string): {
  cleanedStatement: string;
  preReturnCode?: string;
} {
  const preReturnStart = "__PRE_RETURN_CODE__";
  const preReturnEnd = "__PRE_RETURN_CODE_END__";

  if (statement.includes(preReturnStart) && statement.includes(preReturnEnd)) {
    const startIndex =
      statement.indexOf(preReturnStart) + preReturnStart.length;
    const endIndex = statement.indexOf(preReturnEnd);

    if (startIndex < endIndex) {
      const preReturnCode = statement.substring(startIndex, endIndex).trim();
      const cleanedStatement = statement
        .replace(
          new RegExp(`${preReturnStart}[\\s\\S]*?${preReturnEnd}`, "g"),
          ""
        )
        .trim();

      return { cleanedStatement, preReturnCode };
    }
  }

  return { cleanedStatement: statement };
}

function getOrdinalSuffix(num: number): string {
  if (num === 2) return "nd";
  if (num === 3) return "rd";
  return "th";
}

```

### src\components\codeGeneration\Jokers\gameVariableUtils.ts

```
import { getGameVariableById } from "../../data/Jokers/GameVars";
import { ConfigExtraVariable } from "./effectUtils";

export interface ParsedGameVariable {
  isGameVariable: boolean;
  gameVariableId?: string;
  multiplier?: number;
  startsFrom?: number;
  code?: string;
}

export interface ParsedRangeVariable {
  isRangeVariable: boolean;
  min?: number;
  max?: number;
}

export interface ConfigVariablesReturn {
  valueCode: string;
  configVariables: ConfigExtraVariable[];
  isXVariable: {
    isGameVariable: boolean;
    isRangeVariable: boolean;
  };
}

export const parseGameVariable = (value: unknown): ParsedGameVariable => {
  if (typeof value === "string" && value.startsWith("GAMEVAR:")) {
    const parts = value.replace("GAMEVAR:", "").split("|");
    const gameVariableId = parts[0];
    const multiplier = parseFloat(parts[1] || "1");
    const startsFrom = parseFloat(parts[2] || "0");
    const gameVariable = getGameVariableById(gameVariableId);

    return {
      isGameVariable: true,
      gameVariableId,
      multiplier,
      startsFrom,
      code: gameVariable?.code,
    };
  }

  return {
    isGameVariable: false,
  };
};

export const parseRangeVariable = (value: unknown): ParsedRangeVariable => {
  if (typeof value === "string" && value.startsWith("RANGE:")) {
    const parts = value.replace("RANGE:", "").split("|");
    const min = parseFloat(parts[0] || "1");
    const max = parseFloat(parts[1] || "5");

    return {
      isRangeVariable: true,
      min,
      max,
    };
  }

  return {
    isRangeVariable: false,
  };
};

export const generateGameVariableCode = (
  value: unknown,
  itemType: "seal" | "enhancement" | "hook" | "edition" = "enhancement"
): string => {
  const parsed = parseGameVariable(value);

  if (
    parsed.isGameVariable &&
    parsed.code &&
    parsed.multiplier !== undefined &&
    parsed.startsFrom !== undefined
  ) {
    const gameVariable = getGameVariableById(parsed.gameVariableId!);
    const configVarName = gameVariable?.label
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    const startsFromCode =
      itemType === "hook"
        ? parsed.startsFrom.toString()
        : `card.ability.extra.${configVarName}`;

    if (parsed.multiplier === 1 && parsed.startsFrom === 0) {
      return parsed.code;
    } else if (parsed.startsFrom === 0) {
      return `(${parsed.code}) * ${parsed.multiplier}`;
    } else if (parsed.multiplier === 1) {
      return `${startsFromCode} + (${parsed.code})`;
    } else {
      return `${startsFromCode} + (${parsed.code}) * ${parsed.multiplier}`;
    }
  }

  if (typeof value === "string") {
    return `card.ability.extra.${value}`;
  }

  return typeof value === "number" ? value.toString() : "0";
};

export const generateConfigVariables = (
  effectValue: unknown,
  effectId: string,
  variableName: string,
  itemType: "enhancement" | "seal" | "hook" | "edition" = "enhancement"
): ConfigVariablesReturn => {
  effectValue = effectValue ?? 1;
  const parsed = parseGameVariable(effectValue);
  const rangeParsed = parseRangeVariable(effectValue);

  let abilityPath: string;
  if (itemType === "seal") {
    abilityPath = "card.ability.seal.extra";
  } else if (itemType === "edition") {
    abilityPath = "card.edition";
  } else {
    abilityPath = "card.ability.extra";
  }

  let valueCode: string;
  const configVariables: ConfigExtraVariable[] = [];

  if (parsed.isGameVariable) {
    valueCode = generateGameVariableCode(effectValue, itemType);
  } else if (rangeParsed.isRangeVariable) {
    const seedName = `${variableName}_${effectId.substring(0, 8)}`;
    valueCode = `pseudorandom('${seedName}', ${abilityPath}.${variableName}_min, ${abilityPath}.${variableName}_max)`;

    configVariables.push(
      { name: `${variableName}_min`, value: rangeParsed.min ?? 1 },
      { name: `${variableName}_max`, value: rangeParsed.max ?? 5 }
    );
  } else if (itemType === "hook") {
    valueCode = `${effectValue}`;
  } else if (typeof effectValue === "string") {
    if (effectValue.endsWith("_value")) {
      valueCode = effectValue;
    } else {
      valueCode = `${abilityPath}.${effectValue}`;
    }
  } else {
    valueCode = `${abilityPath}.${variableName}`;

    configVariables.push({
      name: variableName,
      value: Number(effectValue ?? 1),
    });
  }

  return {
    valueCode,
    configVariables,
    isXVariable: {
      isGameVariable: parsed.isGameVariable,
      isRangeVariable: rangeParsed.isRangeVariable,
    },
  };
};

```

### src\components\codeGeneration\Jokers\index.ts

```
import { JokerData } from "../../data/BalatroUtils";
import { generateTriggerContext } from "./triggerUtils";
import { generateConditionChain } from "./conditionUtils";
import {
  generateEffectReturnStatement,
  processPassiveEffects,
  ConfigExtraVariable,
} from "./effectUtils";
import {
  extractVariablesFromRules,
  generateVariableConfig,
  getAllVariables,
  extractGameVariablesFromRules,
} from "./variableUtils";
import type { Rule } from "../../ruleBuilder/types";
import type { PassiveEffectResult } from "./effectUtils";
import { generateDiscountItemsHook } from "./effects/DiscountItemsEffect";
import { generateReduceFlushStraightRequirementsHook } from "./effects/ReduceFlushStraightRequirementsEffect";
import { generateShortcutHook } from "./effects/ShortcutEffect";
import { generateShowmanHook } from "./effects/ShowmanEffect";
import { generateCombineRanksHook } from "./effects/CombineRanksEffect";
import { generateCombineSuitsHook } from "./effects/CombineSuitsEffect";
import {
  getRankId,
  getSuitByValue,
  getRankByValue,
} from "../../data/BalatroUtils";
import { slugify } from "../../data/BalatroUtils";
import { RarityData } from "../../data/BalatroUtils";
import { generateUnlockFunction } from "./unlockUtils";
import { generateGameVariableCode, parseGameVariable, parseRangeVariable } from "./gameVariableUtils";
interface CalculateFunctionResult {
  code: string;
  configVariables: ConfigExtraVariable[];
}

const ensureJokerKeys = (jokers: JokerData[]): JokerData[] => {
  return jokers.map((joker) => ({
    ...joker,
    jokerKey: joker.jokerKey || slugify(joker.name),
  }));
};

export const generateJokersCode = (
  jokers: JokerData[],
  atlasKey: string,
  modPrefix: string
): { jokersCode: Record<string, string>; hooks: string } => {
  const jokersWithKeys = ensureJokerKeys(jokers);
  const jokersCode: Record<string, string> = {};
  let currentPosition = 0;

  jokersWithKeys.forEach((joker) => {
    const result = generateSingleJokerCode(
      joker,
      atlasKey,
      currentPosition,
      modPrefix
    );

    let jokerCode = result.code;

    const hookCode = generateHooks([joker], modPrefix);
    if (hookCode.trim()) {
      jokerCode = `${jokerCode}

${hookCode}`;
    }

    jokersCode[`${joker.jokerKey}.lua`] = jokerCode;
    currentPosition = result.nextPosition;
  });

  return { jokersCode, hooks: "" };
};

const convertRandomGroupsForCodegen = (
  randomGroups: import("../../ruleBuilder/types").RandomGroup[]
) => {
  return randomGroups.map((group) => ({
    ...group,
    chance_numerator:
      typeof group.chance_numerator === "string"
      ? generateGameVariableCode(group.chance_numerator)
      : group.chance_numerator,
    chance_denominator:
      typeof group.chance_denominator === "string"
        ? generateGameVariableCode(group.chance_denominator)
        : group.chance_denominator,
  }));
};

const convertLoopGroupsForCodegen = (
  loopGroups: import("../../ruleBuilder/types").LoopGroup[]
) => {
  return loopGroups.map((group) => ({
    ...group,
    repetitions:
      typeof group.repetitions === "string"
        ? (() => {
          const parsed = parseGameVariable(group.repetitions);
          const rangeParsed = parseRangeVariable(group.repetitions);
          if (parsed.isGameVariable) {
            return generateGameVariableCode(group.repetitions);
          } else if (rangeParsed.isRangeVariable) {
            const seedName = `repetitions_${group.id.substring(0, 8)}`;
            return `pseudorandom('${seedName}', ${rangeParsed.min}, ${rangeParsed.max})`;
          } else {
            return `card.ability.extra.${group.repetitions}`
          }
        })()
        : group.repetitions,
  }));
};

export const generateCustomRaritiesCode = (
  customRarities: RarityData[]
): string => {
  if (customRarities.length === 0) {
    return "";
  }

  let output = "";

  customRarities.forEach((rarity) => {
    const hexColor = rarity.badge_colour.startsWith("#")
      ? rarity.badge_colour
      : `#${rarity.badge_colour}`;

    output += `SMODS.Rarity {
    key = "${rarity.key}",
    pools = {
        ["Joker"] = true
    },
    default_weight = ${rarity.default_weight},
    badge_colour = HEX('${hexColor.substring(1)}'),
    loc_txt = {
        name = "${rarity.name}"
    },
    get_weight = function(self, weight, object_type)
        return weight
    end,
}

`;
  });

  return output.trim();
};

const generateInPoolFunction = (
  joker: JokerData,
  modprefix: string
): string => {
  const notAppearsIn: string[] = [];
  const appearsIn: string[] = [];

  const appearFlags: string[] = joker.appearFlags
    ? joker.appearFlags
        .split(",")
        .map((flag) => flag.trim())
        .filter(Boolean)
        .map((flag) => {
          const isNegated = flag.startsWith("not ");
          const rawFlag = isNegated ? flag.slice(4).trim() : flag;
          const safeFlagName = rawFlag.replace(/[^a-zA-Z0-9_]/g, "_"); // replace non-alphanumeric charactes with underscore
          const luaFlag = `G.GAME.pool_flags.${modprefix}_${safeFlagName}`;
          return isNegated ? `not ${luaFlag}` : luaFlag;
        })
    : [];

  joker.appears_in_shop = joker.appears_in_shop ?? true;
  if (joker.appears_in_shop) {
    appearsIn.push("args.source == 'sho'");
  } else {
    notAppearsIn.push("args.source ~= 'sho'");
  }

  Object.entries(joker.cardAppearance).forEach(([key, value]) => {
    if (value) {
      appearsIn.push(`args.source == '${key}'`);
    } else {
      notAppearsIn.push(`args.source ~= '${key}'`);
    }
  });

  // Check if all advanced settings are permissive (no restrictions)
  const isShopPermissive = joker.appears_in_shop !== false;
  const hasCardAppearanceRestrictions = Object.values(
    joker.cardAppearance
  ).some((value) => value === false);
  const hasAppearFlags = appearFlags.length > 0;

  // If everything is permissive (no restrictions), don't generate in_pool function
  if (isShopPermissive && !hasCardAppearanceRestrictions && !hasAppearFlags) {
    return "";
  }

  if (notAppearsIn.length > 0 || appearsIn.length > 0) {
    return `in_pool = function(self, args)
          return (
          not args 
          ${notAppearsIn.length > 0 ? "or" : ""} ${notAppearsIn.join(" and ")} 
          ${appearsIn.length > 0 ? "or" : ""} ${appearsIn.join(" or ")}
          )
          and ${appearFlags.length > 0 ? appearFlags.join(" and ") : "true"}
      end`;
  }
  return `in_pool = function(self, args)
        return ${
          joker.rarity === 4 && joker.appears_in_shop === true
            ? "true"
            : "args.source ~= 'sho'"
        }
    end`;
};

const generateSingleJokerCode = (
  joker: JokerData,
  atlasKey: string,
  currentPosition: number,
  modPrefix: string
): { code: string; nextPosition: number } => {
  const passiveEffects = processPassiveEffects(joker);
  const nonPassiveRules =
    joker.rules?.filter((rule) => rule.trigger !== "passive") || [];

  let calculateResult: CalculateFunctionResult | null = null;
  if (nonPassiveRules.length > 0 || passiveEffects.length > 0) {
    calculateResult = generateCalculateFunction(
      nonPassiveRules,
      joker,
      modPrefix
    );
  }

  const configItems: string[] = [];
  const variableNameCounts = new Map<string, number>();

  const resolveVariableName = (baseName: string): string => {
    const count = variableNameCounts.get(baseName) || 0;
    variableNameCounts.set(baseName, count + 1);
    return count === 0 ? baseName : `${baseName}${count + 1}`;
  };

  passiveEffects.forEach((effect) => {
    if (effect.configVariables) {
      effect.configVariables.forEach((configVar) => {
        if (configVar.trim()) {
          configItems.push(configVar);
        }
      });
    }
  });

  if (joker.userVariables && joker.userVariables.length > 0) {
    joker.userVariables.forEach((variable) => {
      if (variable.type === "number" || !variable.type) {
        configItems.push(`${variable.name} = ${variable.initialValue || 0}`);
      }
    });
  }

  const gameVariables = extractGameVariablesFromRules(joker.rules || []);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  if (calculateResult?.configVariables) {
    calculateResult.configVariables.forEach((configVar) => {
      const finalName = resolveVariableName(configVar.name);
      const valueStr =
        typeof configVar.value === "string"
          ? `"${configVar.value}"`
          : configVar.value;
      configItems.push(`${finalName} = ${valueStr}`);
    });
  }

  if (joker.rules && joker.rules.length > 0) {
    const nonPassiveRules = joker.rules.filter(
      (rule) => rule.trigger !== "passive"
    );
    const variables = extractVariablesFromRules(nonPassiveRules);

    const userVariableNames = new Set(
      joker.userVariables?.map((v) => v.name) || []
    );
    const autoVariables = variables.filter(
      (v) => !userVariableNames.has(v.name)
    );

    if (autoVariables.length > 0) {
      const variableConfig = generateVariableConfig(autoVariables);
      if (variableConfig) {
        configItems.push(variableConfig);
      }
    }
  }

  const effectsConfig = configItems.join(",\n            ");

  const jokersPerRow = 10;
  const col = currentPosition % jokersPerRow;
  const row = Math.floor(currentPosition / jokersPerRow);

  let nextPosition = currentPosition + 1;

  let jokerCode = `SMODS.Joker{ --${joker.name}
    key = "${joker.jokerKey}",
    config = {
        extra = {`;

  if (effectsConfig.trim()) {
    jokerCode += `
            ${effectsConfig}`;
  }

  jokerCode += `
        }
    },
    loc_txt = {
        ['name'] = '${joker.name}',
        ['text'] = ${formatJokerDescription(joker.description)},
        ['unlock'] = ${formatJokerDescription(joker.unlockDescription)}
    },
    pos = {
        x = ${col},
        y = ${row}
    },
    display_size = {
        w = 71 * ${(joker.scale_w || 100) / 100}, 
        h = 95 * ${(joker.scale_h || 100) / 100}
    },
    cost = ${joker.cost !== undefined ? joker.cost : 4},
    rarity = ${(() => {
      if (typeof joker.rarity === "string") {
        const prefixedRarity = modPrefix
          ? `${modPrefix}_${joker.rarity}`
          : joker.rarity;
        return `"${prefixedRarity}"`;
      } else {
        return joker.rarity;
      }
    })()},
    blueprint_compat = ${
      joker.blueprint_compat !== undefined ? joker.blueprint_compat : true
    },
    eternal_compat = ${
      joker.eternal_compat !== undefined ? joker.eternal_compat : true
    },
    perishable_compat = ${
      joker.perishable_compat !== undefined ? joker.perishable_compat : true
    },
    unlocked = ${joker.unlocked !== undefined ? joker.unlocked : true},
    discovered = ${joker.discovered !== undefined ? joker.discovered : true},
    atlas = '${atlasKey}'`;

  if (joker.pools && joker.pools.length > 0) {
    const poolsObject = joker.pools
      .map((poolName) => `["${modPrefix}_${poolName}"] = true`)
      .join(", ");

    jokerCode += `,
    pools = { ${poolsObject} }`;
  }

  if (joker.overlayImagePreview) {
    const soulCol = nextPosition % jokersPerRow;
    const soulRow = Math.floor(nextPosition / jokersPerRow);

    jokerCode += `,
    soul_pos = {
        x = ${soulCol},
        y = ${soulRow}
    }`;

    nextPosition++;
  }

  const inPoolFunction = generateInPoolFunction(joker, modPrefix);
  if (inPoolFunction) {
    jokerCode += `,
    ${inPoolFunction}`;
  }

  const locVarsCode = generateLocVarsFunction(joker, passiveEffects, modPrefix);
  if (locVarsCode) {
    jokerCode += `,\n\n    ${locVarsCode}`;
  }

  const setStickerCode = generateSetAbilityFunction(joker);
  if (setStickerCode) {
    jokerCode += `,\n\n    ${setStickerCode}`;
  }

  if (calculateResult) {
    jokerCode += `,\n\n    ${calculateResult.code}`;
  }

  const addToDeckCode = passiveEffects
    .filter((effect) => effect.addToDeck)
    .map((effect) => effect.addToDeck)
    .join("\n        ");

  const removeFromDeckCode = passiveEffects
    .filter((effect) => effect.removeFromDeck)
    .map((effect) => effect.removeFromDeck)
    .join("\n        ");

  if (addToDeckCode) {
    jokerCode += `,\n\n    add_to_deck = function(self, card, from_debuff)
        ${addToDeckCode}
    end`;
  }

  if (removeFromDeckCode) {
    jokerCode += `,\n\n    remove_from_deck = function(self, card, from_debuff)
        ${removeFromDeckCode}
    end`;
  }

  if (joker.unlockTrigger) {
    jokerCode += `${generateUnlockFunction(joker)}`;
  }
  jokerCode += `\n}`;

  if (joker.ignoreSlotLimit) {
    jokerCode += `\n\nlocal check_for_buy_space_ref = G.FUNCS.check_for_buy_space
G.FUNCS.check_for_buy_space = function(card)
    if card.config.center.key == "j_${modPrefix}_${joker.jokerKey}" then -- ignore slot limit when bought
        return true
    end
    return check_for_buy_space_ref(card)
end

local can_select_card_ref = G.FUNCS.can_select_card
G.FUNCS.can_select_card = function(e)
	if e.config.ref_table.config.center.key == "j_${modPrefix}_${joker.jokerKey}" then
		e.config.colour = G.C.GREEN
		e.config.button = "use_card"
	else
		can_select_card_ref(e)
	end
end`;
  }

  return {
    code: jokerCode,
    nextPosition,
  };
};

export const exportSingleJoker = (joker: JokerData): void => {
  try {
    const jokerWithKey = joker.jokerKey
      ? joker
      : { ...joker, jokerKey: slugify(joker.name) };

    const result = generateSingleJokerCode(
      jokerWithKey,
      "Joker",
      0,
      "modprefix"
    );
    let jokerCode = result.code;

    const hookCode = generateHooks([jokerWithKey], "modprefix");
    if (hookCode.trim()) {
      jokerCode = `${jokerCode} 
      ${hookCode}`;
    }

    const blob = new Blob([jokerCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${jokerWithKey.jokerKey}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export joker:", error);
    throw error;
  }
};

const generateSetAbilityFunction = (joker: JokerData): string | null => {
  const forcedStickers: string[] = [];
  const suitVariables = (joker.userVariables || []).filter(
    (v) => v.type === "suit"
  );
  const rankVariables = (joker.userVariables || []).filter(
    (v) => v.type === "rank"
  );
  const pokerHandVariables = (joker.userVariables || []).filter(
    (v) => v.type === "pokerhand"
  );

  if (joker.force_eternal) {
    forcedStickers.push("card:set_eternal(true)");
  }

  if (joker.force_perishable) {
    forcedStickers.push("card:add_sticker('perishable', true)");
  }

  if (joker.force_rental) {
    forcedStickers.push("card:add_sticker('rental', true)");
  }

  const forcedEditions: string[] = [];

  if (joker.force_foil) {
    forcedEditions.push('card:set_edition("e_foil", true)');
  }

  if (joker.force_holographic) {
    forcedEditions.push('card:set_edition("e_holo", true)');
  }

  if (joker.force_polychrome) {
    forcedEditions.push('card:set_edition("e_polychrome", true)');
  }

  if (joker.force_negative) {
    forcedEditions.push('card:set_edition("e_negative", true)');
  }

  const variableInits: string[] = [];

  suitVariables.forEach((variable) => {
    const defaultSuit =
      variable.initialSuit || getSuitByValue("Spades")?.value || "Spades";
    variableInits.push(
      `G.GAME.current_round.${variable.name}_card = { suit = '${defaultSuit}' }`
    );
  });

  rankVariables.forEach((variable) => {
    const defaultRank =
      variable.initialRank || getRankByValue("A")?.label || "Ace";
    const defaultId = getRankId(defaultRank);
    variableInits.push(
      `G.GAME.current_round.${variable.name}_card = { rank = '${defaultRank}', id = ${defaultId} }`
    );
  });

  pokerHandVariables.forEach((variable) => {
    const defaultPokerHand = variable.initialPokerHand || "High Card";
    variableInits.push(
      `G.GAME.current_round.${variable.name}_hand = '${defaultPokerHand}'`
    );
  });

  if (
    forcedStickers.length === 0 &&
    variableInits.length === 0 &&
    forcedEditions.length === 0
  ) {
    return null;
  }

  const allCode = [...forcedStickers, ...variableInits, ...forcedEditions];

  return `set_ability = function(self, card, initial)
        ${allCode.join("\n        ")}
    end`;
};

const generateCalculateFunction = (
  rules: Rule[],
  joker: JokerData,
  modprefix: string
): CalculateFunctionResult => {
  const jokerKey = joker.jokerKey;
  const rulesByTrigger: Record<string, Rule[]> = {};
  rules.forEach((rule) => {
    if (!rulesByTrigger[rule.trigger]) {
      rulesByTrigger[rule.trigger] = [];
    }
    rulesByTrigger[rule.trigger].push(rule);
  });

  const allConfigVariables: ConfigExtraVariable[] = [];
  const globalEffectCounts = new Map<string, number>();

  let calculateFunction = `calculate = function(self, card, context)`;

  Object.entries(rulesByTrigger).forEach(([triggerType, triggerRules]) => {
    const sortedRules = [...triggerRules].sort((a, b) => {
      const aHasConditions = generateConditionChain(a, joker).length > 0;
      const bHasConditions = generateConditionChain(b, joker).length > 0;

      if (aHasConditions && !bHasConditions) return -1;
      if (!aHasConditions && bHasConditions) return 1;
      return 0;
    });

    const hasRetriggerEffects = sortedRules.some((rule) =>
      [
        ...(rule.effects || []),
        ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
        ...(rule.loops?.flatMap((g) => g.effects) || []),
      ].some((effect) => effect.type === "retrigger_cards")
    );

    const hasDeleteEffects =
      triggerType !== "card_discarded" &&
      sortedRules.some((rule) =>
        [
          ...(rule.effects || []),
          ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
          ...(rule.loops?.flatMap((g) => g.effects) || []),
        ].some((effect) => effect.type === "delete_triggered_card")
      );

    const hasFixProbablityEffects = sortedRules.some((rule) =>
      [
        ...(rule.effects || []),
        ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
        ...(rule.loops?.flatMap((g) => g.effects) || []),
      ].some((effect) => effect.type === "fix_probability")
    );

    const hasModProbablityEffects = sortedRules.some((rule) =>
      [
        ...(rule.effects || []),
        ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
        ...(rule.loops?.flatMap((g) => g.effects) || []),
      ].some((effect) => effect.type === "mod_probability")
    );

    const isBlueprintCompatible = rules.some(
      (rule) => rule.blueprintCompatible ?? true
    );

    if (hasDeleteEffects) {
      calculateFunction += `
        if context.destroy_card and context.destroy_card.should_destroy ${
          isBlueprintCompatible ? "" : "and not context.blueprint"
        } then
            return { remove = true }
        end`;
    }

    if (hasRetriggerEffects) {
      const retriggerContextCheck =
        triggerType === "card_held_in_hand" ||
        triggerType === "card_held_in_hand_end_of_round"
          ? `context.repetition and context.cardarea == G.hand and (next(context.card_effects[1]) or #context.card_effects > 1) ${
              isBlueprintCompatible ? "" : "and not context.blueprint"
            }`
          : `context.repetition and context.cardarea == G.play ${
              isBlueprintCompatible ? "" : "and not context.blueprint"
            }`;

      calculateFunction += `
        if ${retriggerContextCheck} then`;

      let hasAnyConditions = false;

      sortedRules.forEach((rule) => {
        const regularRetriggerEffects = (rule.effects || []).filter(
          (e) => e.type === "retrigger_cards"
        );
        const randomRetriggerEffects = (rule.randomGroups || []).filter(
          (group) => group.effects.some((e) => e.type === "retrigger_cards")
        );
        const loopRetriggerEffects = (rule.loops || []).filter(
          (group) => group.effects.some((e) => e.type === "retrigger_cards")
        );

        if (
          regularRetriggerEffects.length === 0 &&
          randomRetriggerEffects.length === 0 &&
          loopRetriggerEffects.length === 0
        )
          return;

        const conditionCode = generateConditionChain(rule, joker);

        if (conditionCode) {
          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} ${conditionCode} then`;
          hasAnyConditions = true;
        } else {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }
        }

        const effectResult = generateEffectReturnStatement(
          regularRetriggerEffects,
          convertRandomGroupsForCodegen(randomRetriggerEffects),
          convertLoopGroupsForCodegen(loopRetriggerEffects),
          triggerType,
          modprefix,
          jokerKey,
          rule.id,
          globalEffectCounts
        );

        if (effectResult.configVariables) {
          allConfigVariables.push(...effectResult.configVariables);
        }

        if (effectResult.preReturnCode) {
          calculateFunction += `
                ${effectResult.preReturnCode}`;
        }

        if (effectResult.statement) {
          calculateFunction += `
                ${effectResult.statement}`;
        }
      });

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;

      const hasNonRetriggerEffects = sortedRules.some((rule) => {
        const regularNonRetriggerEffects = (rule.effects || []).filter(
          (e) => e.type !== "retrigger_cards"
        );
        const randomNonRetriggerGroups = (rule.randomGroups || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter((e) => e.type !== "retrigger_cards"),
          }))
          .filter((group) => group.effects.length > 0);
        
        const loopNonRetriggerGroups = (rule.loops || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter((e) => e.type !== "retrigger_cards"),
          }))
          .filter((group) => group.effects.length > 0);

        return (
          regularNonRetriggerEffects.length > 0 ||
          randomNonRetriggerGroups.length > 0 ||
          loopNonRetriggerGroups.length > 0
        );
      });

      if (hasNonRetriggerEffects) {
        const nonRetriggerContextCheck =
          triggerType === "card_held_in_hand" ||
          triggerType === "card_held_in_hand_end_of_round"
            ? `context.individual and context.cardarea == G.hand and not context.end_of_round ${
                isBlueprintCompatible ? "" : "and not context.blueprint"
              }`
            : triggerType === "card_discarded"
            ? `context.discard ${
                isBlueprintCompatible ? "" : "and not context.blueprint"
              }`
            : `context.individual and context.cardarea == G.play ${
                isBlueprintCompatible ? "" : "and not context.blueprint"
              }`;

        calculateFunction += `
        if ${nonRetriggerContextCheck} then`;

        if (hasDeleteEffects) {
          calculateFunction += `
            context.other_card.should_destroy = false`;
        }

        hasAnyConditions = false;

        const rulesWithConditions = sortedRules.filter(
          (rule) => generateConditionChain(rule, joker).length > 0
        );
        const rulesWithoutConditions = sortedRules.filter(
          (rule) => generateConditionChain(rule, joker).length === 0
        );

        rulesWithConditions.forEach((rule) => {
          const regularNonRetriggerEffects = (rule.effects || []).filter(
            (e) => e.type !== "retrigger_cards"
          );
          const randomNonRetriggerGroups = (rule.randomGroups || [])
            .map((group) => ({
              ...group,
              effects: group.effects.filter(
                (e) => e.type !== "retrigger_cards"
              ),
            }))
            .filter((group) => group.effects.length > 0);
          
          const loopNonRetriggerGroups = (rule.loops || [])
            .map((group) => ({
              ...group,
              effects: group.effects.filter(
                (e) => e.type !== "retrigger_cards"
              ),
            }))
            .filter((group) => group.effects.length > 0);

          if (
            regularNonRetriggerEffects.length === 0 &&
            randomNonRetriggerGroups.length === 0 &&
            loopNonRetriggerGroups.length === 0
          )
            return;

          const conditionCode = generateConditionChain(rule, joker);

          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} ${conditionCode} then`;
          hasAnyConditions = true;

          const hasDeleteInRegularEffects = (rule.effects || []).some(
            (effect) => effect.type === "delete_triggered_card"
          );

          if (hasDeleteInRegularEffects) {
            calculateFunction += `
                context.other_card.should_destroy = true`;
          }

          const effectResult = generateEffectReturnStatement(
            regularNonRetriggerEffects,
            convertRandomGroupsForCodegen(randomNonRetriggerGroups),
            convertLoopGroupsForCodegen(loopNonRetriggerGroups),
            triggerType,
            modprefix,
            jokerKey,
            rule.id,
            globalEffectCounts
          );

          if (effectResult.configVariables) {
            allConfigVariables.push(...effectResult.configVariables);
          }

          if (effectResult.preReturnCode) {
            calculateFunction += `
                ${effectResult.preReturnCode}`;
          }

          if (effectResult.statement) {
            calculateFunction += `
                ${effectResult.statement}`;
          }
        });

        if (rulesWithoutConditions.length > 0) {
          const rulesWithGroups = rulesWithoutConditions.filter(
            (rule) => (rule.randomGroups || []).length > 0 || (rule.loops || []).length > 0
          );
          const rulesWithoutAnyGroups = rulesWithoutConditions.filter(
            (rule) =>
              (rule.randomGroups || []).length === 0 &&
              (rule.loops || []).length === 0 &&
              (rule.effects || []).length > 0
          );

          rulesWithGroups.forEach((rule) => {
            const regularNonRetriggerEffects = (rule.effects || []).filter(
              (e) => e.type !== "retrigger_cards"
            );
            const randomNonRetriggerGroups = (rule.randomGroups || [])
              .map((group) => ({
                ...group,
                effects: group.effects.filter(
                  (e) => e.type !== "retrigger_cards"
                ),
              }))
              .filter((group) => group.effects.length > 0);
            const loopNonRetriggerGroups = (rule.loops || [])
              .map((group) => ({
                ...group,
                effects: group.effects.filter(
                  (e) => e.type !== "retrigger_cards"
                ),
              }))
              .filter((group) => group.effects.length > 0);

            if (
              regularNonRetriggerEffects.length === 0 &&
              randomNonRetriggerGroups.length === 0 &&
              loopNonRetriggerGroups.length === 0
            )
              return;

            const conditional = hasAnyConditions ? "elseif" : "if";
            calculateFunction += `
            ${conditional} true then`;
            hasAnyConditions = true;

            const hasDeleteInRegularEffects = (rule.effects || []).some(
              (effect) => effect.type === "delete_triggered_card"
            );

            if (hasDeleteInRegularEffects) {
              calculateFunction += `
                context.other_card.should_destroy = true`;
            }

            const effectResult = generateEffectReturnStatement(
              regularNonRetriggerEffects,
              convertRandomGroupsForCodegen(randomNonRetriggerGroups),
              convertLoopGroupsForCodegen(loopNonRetriggerGroups),
              triggerType,
              modprefix,
              jokerKey,
              rule.id,
              globalEffectCounts
            );

            if (effectResult.configVariables) {
              allConfigVariables.push(...effectResult.configVariables);
            }

            if (effectResult.preReturnCode) {
              calculateFunction += `
                ${effectResult.preReturnCode}`;
            }

            if (effectResult.statement) {
              calculateFunction += `
                ${effectResult.statement}`;
            }
          });

          if (rulesWithoutAnyGroups.length > 0) {
            if (hasAnyConditions) {
              calculateFunction += `
            else`;
            }

            rulesWithoutAnyGroups.forEach((rule) => {
              const regularNonRetriggerEffects = (rule.effects || []).filter(
                (e) => e.type !== "retrigger_cards"
              );

              if (regularNonRetriggerEffects.length === 0) return;

              const hasDeleteInRegularEffects = (rule.effects || []).some(
                (effect) => effect.type === "delete_triggered_card"
              );

              if (hasDeleteInRegularEffects) {
                calculateFunction += `
                context.other_card.should_destroy = true`;
              }

              const effectResult = generateEffectReturnStatement(
                regularNonRetriggerEffects,
                [],
                [],
                triggerType,
                modprefix,
                jokerKey,
                rule.id,
                globalEffectCounts
              );

              if (effectResult.configVariables) {
                allConfigVariables.push(...effectResult.configVariables);
              }

              if (effectResult.preReturnCode) {
                calculateFunction += `
                ${effectResult.preReturnCode}`;
              }

              if (effectResult.statement) {
                calculateFunction += `
                ${effectResult.statement}`;
              }
            });
          }
        }

        if (hasAnyConditions) {
          calculateFunction += `
            end`;
        }

        calculateFunction += `
        end`;
      }
    } else if (hasDeleteEffects) {
      const individualContextCheck =
        triggerType === "card_held_in_hand" ||
        triggerType === "card_held_in_hand_end_of_round"
          ? `context.individual and context.cardarea == G.hand and not context.end_of_round ${
              isBlueprintCompatible ? "" : "and not context.blueprint"
            }`
          : triggerType === "card_discarded"
          ? `context.discard ${
              isBlueprintCompatible ? "" : "and not context.blueprint"
            }`
          : `context.individual and context.cardarea == G.play ${
              isBlueprintCompatible ? "" : "and not context.blueprint"
            }`;

      calculateFunction += `
        if ${individualContextCheck} then
            context.other_card.should_destroy = false`;

      let hasAnyConditions = false;

      const rulesWithConditions = sortedRules.filter(
        (rule) => generateConditionChain(rule, joker).length > 0
      );
      const rulesWithoutConditions = sortedRules.filter(
        (rule) => generateConditionChain(rule, joker).length === 0
      );

      rulesWithConditions.forEach((rule) => {
        const regularDeleteEffects = (rule.effects || []).filter(
          (e) => e.type === "delete_triggered_card"
        );
        const randomDeleteGroups = (rule.randomGroups || []).filter((group) =>
          group.effects.some((e) => e.type === "delete_triggered_card")
        );
        const loopDeleteGroups = (rule.loops || []).filter((group) =>
          group.effects.some((e) => e.type === "delete_triggered_card")
        );

        const regularNonDeleteEffects = (rule.effects || []).filter(
          (e) => e.type !== "delete_triggered_card"
        );
        const randomNonDeleteGroups = (rule.randomGroups || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter(
              (e) => e.type !== "delete_triggered_card"
            ),
          }))
          .filter((group) => group.effects.length > 0);
        const loopNonDeleteGroups = (rule.loops || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter(
              (e) => e.type !== "delete_triggered_card"
            ),
          }))
          .filter((group) => group.effects.length > 0);

        if (
          regularDeleteEffects.length === 0 &&
          randomDeleteGroups.length === 0 &&
          loopDeleteGroups.length === 0 &&
          regularNonDeleteEffects.length === 0 &&
          randomNonDeleteGroups.length === 0 &&
          loopNonDeleteGroups.length === 0
        )
          return;

        const conditionCode = generateConditionChain(rule, joker);

        const conditional = hasAnyConditions ? "elseif" : "if";
        calculateFunction += `
            ${conditional} ${conditionCode} then`;
        hasAnyConditions = true;

        if (regularDeleteEffects.length > 0) {
          calculateFunction += `
                context.other_card.should_destroy = true`;
        }

        const allEffects = [
          ...regularNonDeleteEffects,
          ...regularDeleteEffects,
        ];
        const allRandomGroups = [...randomNonDeleteGroups, ...randomDeleteGroups];
        const allLoopGroups = [...loopDeleteGroups, ...loopNonDeleteGroups];

        if (allEffects.length > 0 || allRandomGroups.length > 0 || allLoopGroups.length > 0) {
          const effectResult = generateEffectReturnStatement(
            allEffects,
            convertRandomGroupsForCodegen(allRandomGroups),
            convertLoopGroupsForCodegen(allLoopGroups),
            triggerType,
            modprefix,
            jokerKey,
            rule.id,
            globalEffectCounts
          );

          if (effectResult.configVariables) {
            allConfigVariables.push(...effectResult.configVariables);
          }

          if (effectResult.preReturnCode) {
            calculateFunction += `
                ${effectResult.preReturnCode}`;
          }

          if (effectResult.statement) {
            calculateFunction += `
                ${effectResult.statement}`;
          }
        }
      });

      if (rulesWithoutConditions.length > 0) {
        const rulesWithGroups = rulesWithoutConditions.filter(
          (rule) => (rule.randomGroups || []).length > 0 || (rule.loops || []).length > 0
        );
        const rulesWithoutAnyGroups = rulesWithoutConditions.filter(
          (rule) =>
            (rule.randomGroups || []).length === 0 &&
            (rule.loops || []).length === 0 &&
            (rule.effects || []).length > 0
        );

        rulesWithGroups.forEach((rule) => {
          const regularDeleteEffects = (rule.effects || []).filter(
            (e) => e.type === "delete_triggered_card"
          );
          const randomDeleteGroups = (rule.randomGroups || []).filter((group) =>
            group.effects.some((e) => e.type === "delete_triggered_card")
          );
          const loopDeleteGroups = (rule.loops || []).filter((group) =>
            group.effects.some((e) => e.type === "delete_triggered_card")
          );

          const regularNonDeleteEffects = (rule.effects || []).filter(
            (e) => e.type !== "delete_triggered_card"
          );
          const randomNonDeleteGroups = (rule.randomGroups || [])
            .map((group) => ({
              ...group,
              effects: group.effects.filter(
                (e) => e.type !== "delete_triggered_card"
              ),
            }))
            .filter((group) => group.effects.length > 0);
          const loopNonDeleteGroups = (rule.loops || [])
            .map((group) => ({
              ...group,
              effects: group.effects.filter(
                (e) => e.type !== "delete_triggered_card"
              ),
            }))
            .filter((group) => group.effects.length > 0);

          if (
            regularDeleteEffects.length === 0 &&
            randomDeleteGroups.length === 0 &&
            loopDeleteGroups.length === 0 &&
            regularNonDeleteEffects.length === 0 &&
            randomNonDeleteGroups.length === 0 && 
            loopNonDeleteGroups.length === 0
          )
            return;

          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} true then`;
          hasAnyConditions = true;

          if (regularDeleteEffects.length > 0) {
            calculateFunction += `
                context.other_card.should_destroy = true`;
          }

          const allEffects = [
            ...regularNonDeleteEffects,
            ...regularDeleteEffects,
          ];
          const allRandomGroups = [...randomNonDeleteGroups, ...randomDeleteGroups];
          const allLoopGroups = [...loopDeleteGroups, ...loopNonDeleteGroups];

          if (allEffects.length > 0 || allRandomGroups.length > 0 || allLoopGroups.length > 0) {
            const effectResult = generateEffectReturnStatement(
              allEffects,
              convertRandomGroupsForCodegen(allRandomGroups),
              convertLoopGroupsForCodegen(allLoopGroups),
              triggerType,
              modprefix,
              jokerKey,
              rule.id,
              globalEffectCounts
            );

            if (effectResult.configVariables) {
              allConfigVariables.push(...effectResult.configVariables);
            }

            if (effectResult.preReturnCode) {
              calculateFunction += `
                ${effectResult.preReturnCode}`;
            }

            if (effectResult.statement) {
              calculateFunction += `
                ${effectResult.statement}`;
            }
          }
        });

        if (rulesWithoutAnyGroups.length > 0) {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }

          rulesWithoutAnyGroups.forEach((rule) => {
            const regularDeleteEffects = (rule.effects || []).filter(
              (e) => e.type === "delete_triggered_card"
            );
            const regularNonDeleteEffects = (rule.effects || []).filter(
              (e) => e.type !== "delete_triggered_card"
            );

            if (
              regularDeleteEffects.length === 0 &&
              regularNonDeleteEffects.length === 0
            )
              return;

            if (regularDeleteEffects.length > 0) {
              calculateFunction += `
                context.other_card.should_destroy = true`;
            }

            const allEffects = [
              ...regularNonDeleteEffects,
              ...regularDeleteEffects,
            ];

            if (allEffects.length > 0) {
              const effectResult = generateEffectReturnStatement(
                allEffects,
                [],
                [],
                triggerType,
                modprefix,
                jokerKey,
                rule.id,
                globalEffectCounts
              );

              if (effectResult.configVariables) {
                allConfigVariables.push(...effectResult.configVariables);
              }

              if (effectResult.preReturnCode) {
                calculateFunction += `
                ${effectResult.preReturnCode}`;
              }

              if (effectResult.statement) {
                calculateFunction += `
                ${effectResult.statement}`;
              }
            }
          });
        }
      }

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;
    } else if (hasFixProbablityEffects || hasModProbablityEffects) {
      if (hasFixProbablityEffects) {
        calculateFunction += `
        if context.fix_probability ${
          isBlueprintCompatible ? "" : "and not context.blueprint"
        } then
        local numerator, denominator = context.numerator, context.denominator`;

        let hasAnyConditions = false;

        sortedRules.forEach((rule) => {
          const regularFixProbablityEffects = (rule.effects || []).filter(
            (e) => e.type === "fix_probability"
          );
          const randomFixProbablityEffects = (rule.randomGroups || []).filter(
            (group) => group.effects.some((e) => e.type === "fix_probability")
          );
          const loopFixProbablityEffects = (rule.loops || []).filter(
            (group) => group.effects.some((e) => e.type === "fix_probability")
          );

          if (
            regularFixProbablityEffects.length === 0 &&
            randomFixProbablityEffects.length === 0 &&
            loopFixProbablityEffects.length === 0
          )
            return;

          const conditionCode = generateConditionChain(rule, joker);

          if (conditionCode) {
            const conditional = hasAnyConditions ? "elseif" : "if";
            calculateFunction += `
            ${conditional} ${conditionCode} then`;
            hasAnyConditions = true;
          } else {
            if (hasAnyConditions) {
              calculateFunction += `
            else`;
            }
          }

          const effectResult = generateEffectReturnStatement(
            regularFixProbablityEffects,
            convertRandomGroupsForCodegen(randomFixProbablityEffects),
            convertLoopGroupsForCodegen(loopFixProbablityEffects),
            triggerType,
            modprefix,
            jokerKey,
            rule.id,
            globalEffectCounts
          );

          if (effectResult.configVariables) {
            allConfigVariables.push(...effectResult.configVariables);
          }

          if (effectResult.preReturnCode) {
            calculateFunction += `
                ${effectResult.preReturnCode}`;
          }

          if (effectResult.statement) {
            calculateFunction += `
                ${effectResult.statement}`;
          }
        });

        if (hasAnyConditions) {
          calculateFunction += `
            end`;
        }

        calculateFunction += `
      return {
        numerator = numerator, 
        denominator = denominator
      }
        end`;
      }
      if (hasModProbablityEffects) {
        calculateFunction += `
          if context.mod_probability ${
            isBlueprintCompatible ? "" : "and not context.blueprint"
          } then
          local numerator, denominator = context.numerator, context.denominator`;

        let hasAnyConditions = false;

        sortedRules.forEach((rule) => {
          const regularModProbablityEffects = (rule.effects || []).filter(
            (e) => e.type === "mod_probability"
          );
          const randomModProbablityEffects = (rule.randomGroups || []).filter(
            (group) => group.effects.some((e) => e.type === "mod_probability")
          );
          const loopModProbablityEffects = (rule.loops || []).filter(
            (group) => group.effects.some((e) => e.type === "mod_probability")
          );

          if (
            regularModProbablityEffects.length === 0 &&
            randomModProbablityEffects.length === 0 &&
            loopModProbablityEffects.length === 0
          )
            return;

          const conditionCode = generateConditionChain(rule, joker);

          if (conditionCode) {
            const conditional = hasAnyConditions ? "elseif" : "if";
            calculateFunction += `
              ${conditional} ${conditionCode} then`;
            hasAnyConditions = true;
          } else {
            if (hasAnyConditions) {
              calculateFunction += `
              else`;
            }
          }

          const effectResult = generateEffectReturnStatement(
            regularModProbablityEffects,
            convertRandomGroupsForCodegen(randomModProbablityEffects),
            convertLoopGroupsForCodegen(loopModProbablityEffects),
            triggerType,
            modprefix,
            jokerKey,
            rule.id,
            globalEffectCounts
          );

          if (effectResult.configVariables) {
            allConfigVariables.push(...effectResult.configVariables);
          }

          if (effectResult.preReturnCode) {
            calculateFunction += `
                  ${effectResult.preReturnCode}`;
          }

          if (effectResult.statement) {
            calculateFunction += `
                  ${effectResult.statement}`;
          }
        });

        if (hasAnyConditions) {
          calculateFunction += `
              end`;
        }

        calculateFunction += `
        return {
          numerator = numerator, 
          denominator = denominator
        }
          end`;
      }
    } else {
      const triggerContext = generateTriggerContext(triggerType, sortedRules);

      calculateFunction += `
        if ${triggerContext.check} then`;

      let hasAnyConditions = false;

      const rulesWithConditions = sortedRules.filter(
        (rule) => generateConditionChain(rule, joker).length > 0
      );
      const rulesWithoutConditions = sortedRules.filter(
        (rule) => generateConditionChain(rule, joker).length === 0
      );

      rulesWithConditions.forEach((rule) => {
        const conditionCode = generateConditionChain(rule, joker);

        const conditional = hasAnyConditions ? "elseif" : "if";
        calculateFunction += `
            ${conditional} ${conditionCode} then`;
        hasAnyConditions = true;
        const effectResult = generateEffectReturnStatement(
          rule.effects || [],
          convertRandomGroupsForCodegen(rule.randomGroups || []),
          convertLoopGroupsForCodegen(rule.loops || []),
          triggerType,
          modprefix,
          jokerKey,
          rule.id,
          globalEffectCounts
        );

        if (effectResult.configVariables) {
          allConfigVariables.push(...effectResult.configVariables);
        }

        if (effectResult.preReturnCode) {
          calculateFunction += `
                ${effectResult.preReturnCode}`;
        }

        if (effectResult.statement) {
          calculateFunction += `
                ${effectResult.statement}`;
        }
      });
      if (rulesWithoutConditions.length > 0) {
        const rulesWithGroups = rulesWithoutConditions.filter(
          (rule) => (rule.randomGroups || []).length > 0 || (rule.loops || []).length > 0
        );
        const rulesWithoutAnyGroups = rulesWithoutConditions.filter(
          (rule) =>
            (rule.randomGroups || []).length === 0 &&
            (rule.loops || []).length === 0 &&
            (rule.effects || []).length > 0
        );

        rulesWithGroups.forEach((rule) => {
          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} true then`;
          hasAnyConditions = true;

          const effectResult = generateEffectReturnStatement(
            rule.effects || [],
            convertRandomGroupsForCodegen(rule.randomGroups || []),
            convertLoopGroupsForCodegen(rule.loops || []),
            triggerType,
            modprefix,
            jokerKey,
            rule.id,
            globalEffectCounts
          );

          if (effectResult.configVariables) {
            allConfigVariables.push(...effectResult.configVariables);
          }

          if (effectResult.preReturnCode) {
            calculateFunction += `
                ${effectResult.preReturnCode}`;
          }

          if (effectResult.statement) {
            calculateFunction += `
                ${effectResult.statement}`;
          }
        });

        if (rulesWithoutAnyGroups.length > 0) {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }

          rulesWithoutAnyGroups.forEach((rule) => {
            const effectResult = generateEffectReturnStatement(
              rule.effects || [],
              [],
              [],
              triggerType,
              modprefix,
              jokerKey,
              rule.id,
              globalEffectCounts
            );

            if (effectResult.configVariables) {
              allConfigVariables.push(...effectResult.configVariables);
            }

            if (effectResult.preReturnCode) {
              calculateFunction += `
                ${effectResult.preReturnCode}`;
            }

            if (effectResult.statement) {
              calculateFunction += `
                ${effectResult.statement}`;
            }
          });
        }
      }

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;
    }
  });

  processPassiveEffects(joker)
    .filter((effect) => effect.calculateFunction)
    .forEach((effect) => {
      calculateFunction += `\n        ${effect.calculateFunction}`;
    });

  calculateFunction += `
    end`;

  return {
    code: calculateFunction,
    configVariables: allConfigVariables,
  };
};

const generateLocVarsFunction = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[],
  modPrefix?: string
): string | null => {
  const descriptionHasVariables = joker.description.includes("#");
  if (!descriptionHasVariables) {
    return null;
  }

  const variablePlaceholders = joker.description.match(/#(\d+)#/g) || [];
  const maxVariableIndex = Math.max(
    ...variablePlaceholders.map((placeholder) =>
      parseInt(placeholder.replace(/#/g, ""))
    ),
    0
  );

  if (maxVariableIndex === 0) {
    return null;
  }

  const allVariables = getAllVariables(joker);
  const gameVariables = extractGameVariablesFromRules(joker.rules || []);
  const suitVariables = (joker.userVariables || []).filter(
    (v) => v.type === "suit"
  );
  const rankVariables = (joker.userVariables || []).filter(
    (v) => v.type === "rank"
  );
  const pokerHandVariables = (joker.userVariables || []).filter(
    (v) => v.type === "pokerhand"
  );

  const hasRandomGroups =
    joker.rules?.some(
      (rule) => rule.randomGroups && rule.randomGroups.length > 0
    ) || false;

  const variableMapping: string[] = [];
  const colorVariables: string[] = [];

  const wrapGameVariableCode = (code: string): string => {
    if (code.includes("G.jokers.cards")) {
      return code.replace(
        "G.jokers.cards",
        "(G.jokers and G.jokers.cards or {})"
      );
    }
    if (code.includes("#G.jokers.cards")) {
      return code.replace(
        "#G.jokers.cards",
        "(G.jokers and G.jokers.cards and #G.jokers.cards or 0)"
      );
    }
    if (code.includes("#G.hand.cards")) {
      return code.replace(
        "#G.hand.cards",
        "(G.hand and G.hand.cards and #G.hand.cards or 0)"
      );
    }
    if (code.includes("#G.deck.cards")) {
      return code.replace(
        "#G.deck.cards",
        "(G.deck and G.deck.cards and #G.deck.cards or 0)"
      );
    }
    if (code.includes("#G.consumeables.cards")) {
      return code.replace(
        "#G.consumeables.cards",
        "(G.consumeables and G.consumeables.cards and #G.consumeables.cards or 0)"
      );
    }
    if (
      code.includes("G.GAME") ||
      code.includes("G.jokers") ||
      code.includes("G.hand") ||
      code.includes("G.deck") ||
      code.includes("G.consumeables")
    ) {
      return `(${code} or 0)`;
    }
    return code;
  };

  if (hasRandomGroups) {
    const gameVarNames = new Set(
      gameVariables.map((gv) => gv.name.replace(/\s+/g, "").toLowerCase())
    );
    const remainingVars = allVariables.filter(
      (v) =>
        v.name !== "numerator" &&
        v.name !== "denominator" &&
        !v.name.startsWith("numerator") &&
        !v.name.startsWith("denominator") &&
        v.type !== "suit" &&
        v.type !== "rank" &&
        v.type !== "pokerhand" &&
        !v.id.startsWith("auto_gamevar_") &&
        !gameVarNames.has(v.name)
    );
    const remainingGameVars = gameVariables.filter(
      (gv) =>
        !gv.name.toLowerCase().includes("numerator") &&
        !gv.name.toLowerCase().includes("denominator")
    );

    let currentIndex = 0;

    for (const variable of remainingVars) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(`card.ability.extra.${variable.name}`);
      currentIndex++;
    }

    for (const gameVar of remainingGameVars) {
      if (currentIndex >= maxVariableIndex) break;
      const varName = gameVar.name
        .replace(/\s+/g, "")
        .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
        .toLowerCase();
      let gameVarCode: string;

      if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
        gameVarCode = wrapGameVariableCode(gameVar.code);
      } else if (gameVar.startsFrom === 0) {
        gameVarCode = `(${wrapGameVariableCode(gameVar.code)}) * ${
          gameVar.multiplier
        }`;
      } else if (gameVar.multiplier === 1) {
        gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
          gameVar.code
        )})`;
      } else {
        gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
          gameVar.code
        )}) * ${gameVar.multiplier}`;
      }

      variableMapping.push(gameVarCode);
      currentIndex++;
    }

    for (const suitVar of suitVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const defaultSuit = getSuitByValue("Spades")?.value || "Spades";
      variableMapping.push(
        `localize((G.GAME.current_round.${suitVar.name}_card or {}).suit or '${defaultSuit}', 'suits_singular')`
      );
      colorVariables.push(
        `G.C.SUITS[(G.GAME.current_round.${suitVar.name}_card or {}).suit or '${defaultSuit}']`
      );
      currentIndex++;
    }

    for (const rankVar of rankVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const defaultRank = getRankByValue("A")?.label || "Ace";
      variableMapping.push(
        `localize((G.GAME.current_round.${rankVar.name}_card or {}).rank or '${defaultRank}', 'ranks')`
      );
      currentIndex++;
    }

    for (const pokerHandVar of pokerHandVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${pokerHandVar.name}_hand or 'High Card'), 'poker_hands')`
      );
      currentIndex++;
    }
  } else {
    let currentIndex = 0;

    for (const variable of allVariables) {
      if (currentIndex >= maxVariableIndex) break;

      if (
        !variable.id.startsWith("auto_gamevar_") &&
        variable.type !== "suit" &&
        variable.type !== "rank" &&
        variable.type !== "pokerhand"
      ) {
        variableMapping.push(`card.ability.extra.${variable.name}`);
        currentIndex++;
      }
    }

    for (const suitVar of suitVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const defaultSuit = getSuitByValue("Spades")?.value || "Spades";
      variableMapping.push(
        `localize((G.GAME.current_round.${suitVar.name}_card or {}).suit or '${defaultSuit}', 'suits_singular')`
      );
      colorVariables.push(
        `G.C.SUITS[(G.GAME.current_round.${suitVar.name}_card or {}).suit or '${defaultSuit}']`
      );
      currentIndex++;
    }

    for (const rankVar of rankVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const defaultRank = getRankByValue("A")?.label || "Ace";
      variableMapping.push(
        `localize((G.GAME.current_round.${rankVar.name}_card or {}).rank or '${defaultRank}', 'ranks')`
      );
      currentIndex++;
    }

    for (const pokerHandVar of pokerHandVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${pokerHandVar.name}_hand or 'High Card'), 'poker_hands')`
      );
      currentIndex++;
    }

    for (const gameVar of gameVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const varName = gameVar.name
        .replace(/\s+/g, "")
        .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
        .toLowerCase();
      let gameVarCode: string;

      if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
        gameVarCode = wrapGameVariableCode(gameVar.code);
      } else if (gameVar.startsFrom === 0) {
        gameVarCode = `(${wrapGameVariableCode(gameVar.code)}) * ${
          gameVar.multiplier
        }`;
      } else if (gameVar.multiplier === 1) {
        gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
          gameVar.code
        )})`;
      } else {
        gameVarCode = `card.ability.extra.${varName} + (${wrapGameVariableCode(
          gameVar.code
        )}) * ${gameVar.multiplier}`;
      }

      variableMapping.push(gameVarCode);
      currentIndex++;
    }
  }

  passiveEffects.forEach((effect) => {
    if (effect.locVars) {
      effect.locVars.forEach((locVar) => {
        if (
          !variableMapping.includes(locVar) &&
          variableMapping.length < maxVariableIndex
        ) {
          const wrappedLocVar = wrapGameVariableCode(locVar);
          variableMapping.push(wrappedLocVar);
        }
      });
    }
  });

  const finalVars = variableMapping.slice(0, maxVariableIndex);

  let locVarsReturn: string;
  let hasReturn = false;

  if (hasRandomGroups) {
    const nonPassiveRules =
      joker.rules?.filter((rule) => rule.trigger !== "passive") || [];
    const randomGroups = nonPassiveRules.flatMap(
      (rule) => rule.randomGroups || []
    );
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator)),
    ];
    const numerators = [
      ...new Set(randomGroups.map((group) => group.chance_numerator)),
    ];

    const nonProbabilityVars = finalVars.filter(
      (varName) =>
        !varName.includes("card.ability.extra.odds") &&
        !varName.includes("card.ability.extra.numerator") &&
        !varName.includes("card.ability.extra.denominator")
    );

    if (denominators.length === 1 && numerators.length === 1) {
      const oddsVar = "card.ability.extra.odds";

      locVarsReturn = `local new_numerator, new_denominator = SMODS.get_probability_vars(card, ${
        numerators[0]
      }, ${oddsVar}, 'j_${modPrefix}_${joker.jokerKey}') 
        return {vars = {${nonProbabilityVars.join(", ")}${
        nonProbabilityVars.length > 0 ? `, ` : ``
      }new_numerator, new_denominator}}`;
      hasReturn = true;
    } else if (denominators.length > 1) {
      const probabilityCalls: string[] = [];
      const probabilityVars: string[] = [];

      denominators.forEach((_, index) => {
        const oddsVar =
          index === 0
            ? "card.ability.extra.odds"
            : `card.ability.extra.odds${index + 1}`;
        const numerator = numerators[Math.min(index, numerators.length - 1)];
        const varSuffix = index === 0 ? "" : (index + 1).toString();

        probabilityCalls.push(
          `local new_numerator${varSuffix}, new_denominator${varSuffix} = SMODS.get_probability_vars(card, ${numerator}, ${oddsVar}, 'j_${modPrefix}_${joker.jokerKey}')`
        );
        probabilityVars.push(
          `new_numerator${varSuffix}`,
          `new_denominator${varSuffix}`
        );
      });

      const allReturnVars = [...nonProbabilityVars, ...probabilityVars];

      locVarsReturn = `${probabilityCalls.join("\n        ")}
        return {vars = {${allReturnVars.join(", ")}}}`;
      hasReturn = true;
    } else {
      locVarsReturn = `{vars = {${finalVars.join(", ")}}}`;
      hasReturn = false;
    }
  } else {
    locVarsReturn = `{vars = {${finalVars.join(", ")}}}`;
    hasReturn = false;
  }

  if (colorVariables.length > 0 && !hasRandomGroups) {
    const varsOnly = finalVars.join(", ");
    locVarsReturn = `{vars = {${varsOnly}}, colours = {${colorVariables.join(
      ", "
    )}}}`;
    hasReturn = false;
  }

  return `loc_vars = function(self, info_queue, card)
        ${hasReturn ? locVarsReturn : `return ${locVarsReturn}`}
    end`;
};

const formatJokerDescription = (description: string) => {
  const formatted = description.replace(/<br\s*\/?>/gi, "[s]");

  const escaped = formatted.replace(/\n/g, "[s]");
  const lines = escaped.split("[s]").map((line) => line.trim());
  // .filter((line) => line.length > 0);

  if (lines.length === 0) {
    lines.push(escaped.trim());
  }

  return `{\n${lines
    .map(
      (line, i) =>
        `            [${i + 1}] = '${line
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"')
          .replace(/'/g, "\\'")}'`
    )
    .join(",\n")}\n        }`;
};

export const getEffectVariableName = (fallback: string): string => {
  return fallback;
};

const generateHooks = (jokers: JokerData[], modPrefix: string): string => {
  let allHooks = "";

  const hooksByType: Record<
    string,
    Array<{ jokerKey: string; params: unknown }>
  > = {};

  jokers.forEach((joker) => {
    const passiveEffects = processPassiveEffects(joker);

    passiveEffects.forEach((effect) => {
      if (effect.needsHook) {
        const hookType = effect.needsHook.hookType;
        if (!hooksByType[hookType]) {
          hooksByType[hookType] = [];
        }
        hooksByType[hookType].push({
          jokerKey: joker.jokerKey!,
          params: effect.needsHook.effectParams,
        });
      }
    });
  });

  if (hooksByType.discount_items) {
    allHooks += generateDiscountItemsHook(
      (
        hooksByType.discount_items as Array<{
          jokerKey: string;
          params: {
            discountType: string;
            discountMethod: string;
            discountAmount: number;
          };
        }>
      ).map((item) => ({
        ...item,
        params: {
          ...item.params,
          discountAmount: String(item.params.discountAmount),
        },
      })),
      modPrefix
    );
  }

  if (hooksByType.reduce_flush_straight_requirements) {
    allHooks += generateReduceFlushStraightRequirementsHook(
      hooksByType.reduce_flush_straight_requirements as Array<{
        jokerKey: string;
        params: {
          reductionValue: number;
        };
      }>,
      modPrefix
    );
  }

  if (hooksByType.shortcut) {
    allHooks += generateShortcutHook(
      hooksByType.shortcut as Array<{
        jokerKey: string;
        params: Record<string, unknown>;
      }>,
      modPrefix
    );
  }

  if (hooksByType.showman) {
    allHooks += generateShowmanHook(
      hooksByType.showman as Array<{
        jokerKey: string;
        params: Record<string, unknown>;
      }>,
      modPrefix
    );
  }

  if (hooksByType.combine_ranks) {
    allHooks += generateCombineRanksHook(
      hooksByType.combine_ranks as Array<{
        jokerKey: string;
        params: {
          sourceRankType: string;
          sourceRanks: string[];
          targetRank: string;
        };
      }>,
      modPrefix
    );
  }

  if (hooksByType.combine_suits) {
    allHooks += generateCombineSuitsHook(
      hooksByType.combine_suits as Array<{
        jokerKey: string;
        params: {
          suit1: string;
          suit2: string;
        };
      }>,
      modPrefix
    );
  }

  return allHooks;
};

```

### src\components\codeGeneration\Jokers\triggerUtils.ts

```
import type { Rule } from "../../ruleBuilder/types";

interface TriggerContext {
  check: string;
  comment: string;
}

export const generateTriggerContext = (
  triggerType: string,
  rules: Rule[]
): TriggerContext => {
  const hasRetriggerEffects = rules.some((rule) =>
    rule.effects.some((effect) => effect.type === "retrigger_cards")
  );

  const isBlueprintCompatible = rules.some((rule) => rule.blueprintCompatible ?? true);

  switch (triggerType) {
    case "card_scored":
      if (hasRetriggerEffects) {
        return {
          check: `context.repetition and context.cardarea == G.play ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- Card repetition context for retriggering",
        };
      } else {
        return {
          check:
            `context.individual and context.cardarea == G.play ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- Individual card scoring",
        };
      }

    case "card_held_in_hand":
      if (hasRetriggerEffects) {
        return {
          check:
            `context.repetition and context.cardarea == G.hand and (next(context.card_effects[1]) or #context.card_effects > 1) ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- Card repetition context for held cards",
        };
      } else {
        return {
          check:
            `context.individual and context.cardarea == G.hand and not context.end_of_round ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- Individual card held in hand",
        };
      }

    case "blind_selected":
      return {
        check: `context.setting_blind ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When blind is selected",
      };

    case "blind_skipped":
      return {
        check: `context.skip_blind ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When blind is skipped",
      };

    case "boss_defeated":
      return {
        check:
          `context.end_of_round and context.main_eval and G.GAME.blind.boss ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- After boss blind is defeated",
      };

    case "tag_added":
      return {
        check:
          `context.tag_added ${isBlueprintCompatible ? '' : 'and not context.blueprint'}`,
        comment: "-- When you obtain a Tag",
      };

    case "booster_opened":
      return {
        check: `context.open_booster ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When booster pack is opened",
      };

    case "booster_skipped":
      return {
        check: `context.skipping_booster ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When booster pack is skipped",
      };

    case "consumable_used":
      return {
        check: `context.using_consumeable ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When consumable is used",
      };

    case "hand_drawn":
      return {
        check: `context.hand_drawn ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When hand is drawn",
      };

    case "first_hand_drawn":
      return {
        check: `context.first_hand_drawn ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When first hand is drawn",
      };

    case "shop_entered":
      return {
        check: `context.starting_shop ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When entering shop",
      };

    case "shop_exited":
      return {
        check: `context.ending_shop ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When exiting shop",
      };

    case "shop_reroll":
      return {
        check: `context.reroll_shop ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When shop is rerolled",
      };

    case "round_end":
      return {
        check:
          `context.end_of_round and context.game_over == false and context.main_eval ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- At the end of the round",
      };

    case "card_discarded":
      return {
        check: `context.discard ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When card is discarded",
      };

    case "hand_discarded":
      return {
        check: `context.pre_discard ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When hand is discarded",
      };

    case "before_hand_played":
      return {
        check: `context.before and context.cardarea == G.jokers ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- Before hand starts scoring",
      };

    case "after_hand_played":
      return {
        check: `context.after and context.cardarea == G.jokers ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- After hand has finished scoring",
      };

    case "card_sold":
      return {
        check: `context.selling_card ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When any card is sold",
      };

    case "card_bought":
      return {
        check: `context.buying_card ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When any card is bought",
      };

    case "selling_self":
      return {
        check: `context.selling_self ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When this specific joker is sold",
      };

    case "buying_self":
      return {
        check: `context.buying_card and context.card.config.center.key == self.key and context.cardarea == G.jokers ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When this specific joker is bought",
      };

    case "joker_evaluated":
      return {
        check: `context.other_joker ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When another joker is triggered",
      };

    case "game_over":
      return {
        check:
          `context.end_of_round and context.game_over and context.main_eval ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When the game would end (game over)",
      };

    case "card_held_in_hand_end_of_round":
      if (hasRetriggerEffects) {
        return {
          check:
            `context.repetition and context.cardarea == G.hand and context.end_of_round and (next(context.card_effects[1]) or #context.card_effects > 1) ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- Card repetition context for held cards at end of round",
        };
      } else {
        return {
          check:
            `context.cardarea == G.hand and context.end_of_round ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
          comment: "-- When a card hand is held at the end of the round",
        };
      }

    case "card_destroyed":
      return {
        check: `context.remove_playing_cards ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When cards are destroyed",
      };

    case "playing_card_added":
      return {
        check: `context.playing_card_added ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When playing cards are added to deck",
      };

    case "probability_result":
      return {
        check: `context.pseudorandom_result ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- When chance roll succeeds/failes",
      };

    case "hand_played":
    default:
      return {
        check: `context.cardarea == G.jokers and context.joker_main ${isBlueprintCompatible ? '' : ' and not context.blueprint'}`,
        comment: "-- Main scoring time for jokers",
      };
  }
};

```

### src\components\codeGeneration\Jokers\unlockUtils.ts

```
import {
  JokerData,
  EDITIONS,
  ENHANCEMENTS,
  POKER_HANDS,
  RANKS,
  SEALS,
  STICKERS,
  SUITS,
  getRarityDropdownOptions,
} from "../../data/BalatroUtils";

export const unlockTriggerOptions = [
  { value: "hand_contents", label: "Cards Played" },
  { value: "modify_deck", label: "Cards In Deck" },
  { value: "modify_jokers", label: "Jokers" },
  { value: "career_stat", label: "Career Stat" },
  { value: "discard_custom", label: "Discard Hand" },
  { value: "win", label: "Win a Run" },
  { value: "round_win", label: "Win a Round" },
  { value: "chip_score", label: "Scored in one Hand" },
];

// CARDS
export const rankOptions = [
  ...RANKS.map(({ id, label }) => ({ value: id.toString(), label })),
];
export const suitOptions = [
  ...SUITS.map(({ value, label }) => ({ value, label })),
];

export const enhancementOptions = [
  { value: "any", label: "Any Enhancement" },
  ...ENHANCEMENTS().map(({ key, label }) => ({ value: key, label })),
];

export const sealOptions = [
  { value: "any", label: "Any Seal" },
  ...SEALS().map(({ key, label }) => ({ value: key, label })),
];

export const editionOptions = [
  { value: "any", label: "Any Edition" },
  ...EDITIONS().map(({ key, label }) => ({ value: key, label })),
];

export const stickerOptions = [
  ...STICKERS.map(({ value, label }) => ({ value, label })),
];

// CAREER STATS
export const cardStatsOptions = [
  { value: "c_hands_played", label: "Hands Played" },
  { value: "c_cards_played", label: "Cards Played" },
  { value: "c_face_cards_played", label: "Face Cards Played" },
  { value: "c_cards_discarded", label: "Cards Discarded" },
  { value: "c_playing_cards_bought", label: "Playing Cards Bought" },
  { value: "c_jokers_sold", label: "Jokers Sold" },
  { value: "c_cards_sold", label: "Cards Sold" },
];

export const consumableStatsOptions = [
  { value: "c_planets_bought", label: "Planets Bought" },
  { value: "c_planetarium_used", label: "Planets Used" },
  { value: "c_tarot_bought", label: "Tarot Bought" },
  { value: "c_tarot_reading_used", label: "Tarot Used" },
];

export const economyStatsOptions = [
  { value: "c_dollars_earned", label: "Money Earned" },
  { value: "c_vouchers_bought", label: "Vouchers Bought" },
  { value: "c_shop_rerolls", label: "Shop Rerolls" },
  { value: "c_shop_dollars_spent", label: "Money Spent" },
  { value: "c_round_interest_cap_streak", label: "Interest Cap Streak" },
];

export const runStatsOptions = [
  { value: "c_rounds", label: "Rounds" },
  { value: "c_wins", label: "Wins" },
  { value: "c_losses", label: "Losses" },
  { value: "c_single_hand_round_streak", label: "Round in one Hand Streak" },
];

// WIN RUN
export const pokerHandOptions = [
  ...POKER_HANDS.map(({ value, label }) => ({ value, label })),
];

export const jokersOptions = [
  { value: "max_jokers", label: "Max Jokers Owned" },
  { value: "joker_count", label: "Jokers Owned" },
  { value: "joker_slots", label: "Joker Slots" },
];

export const blindsOptions = [
  { value: "round", label: "Rounds" },
  { value: "ante", label: "Current Ante" },
  { value: "skips", label: "Blinds Skipped" },
  { value: "boss", label: "Boss Beaten" },
];

export const resourcesOptions = [
  { value: "hands", label: "Remaining Hands" },
  { value: "discards", label: "Remaining Discards" },
  { value: "dollars", label: "Current Money" },
];

export const unlockOptions = {
  hand_contents: {
    categories: [
      { value: "rank", label: "Rank", options: rankOptions },
      { value: "suit", label: "Suit", options: suitOptions },
      {
        value: "enhancement",
        label: "Enhancement",
        options: enhancementOptions,
      },
      { value: "seal", label: "Seal", options: sealOptions },
      { value: "edition", label: "Edition", options: editionOptions },
      { value: "poker_hand", label: "Poker Hand", options: pokerHandOptions },
    ],
  },
  modify_deck: {
    categories: [
      { value: "rank", label: "Rank", options: rankOptions },
      { value: "suit", label: "Suit", options: suitOptions },
      {
        value: "enhancement",
        label: "Enhancement",
        options: enhancementOptions,
      },
      { value: "seal", label: "Seal", options: sealOptions },
      { value: "edition", label: "Edition", options: editionOptions },
    ],
  },
  modify_jokers: {
    categories: [
      { value: "rarity", label: "Rarity", options: getRarityDropdownOptions() },
      { value: "edition", label: "Edition", options: editionOptions },
      { value: "sticker", label: "Sticker", options: stickerOptions },
    ],
  },
  career_stat: {
    categories: [
      { value: "card_stats", label: "Cards", options: cardStatsOptions },
      {
        value: "consumable_stats",
        label: "Consumables",
        options: consumableStatsOptions,
      },
      {
        value: "economy_stats",
        label: "Economy",
        options: economyStatsOptions,
      },
      { value: "run_stats", label: "Runs", options: runStatsOptions },
    ],
  },
  discard_custom: {
    categories: [
      { value: "rank", label: "Rank", options: rankOptions },
      { value: "suit", label: "Suit", options: suitOptions },
      {
        value: "enhancement",
        label: "Enhancement",
        options: enhancementOptions,
      },
      { value: "seal", label: "Seal", options: sealOptions },
      { value: "edition", label: "Edition", options: editionOptions },
      { value: "poker_hand", label: "Poker Hand", options: pokerHandOptions },
    ],
  },
  // There are a lot of possible options for win run/round, we can add them in the future as needed
  win: {
    categories: [
      { value: "jokers", label: "Jokers", options: jokersOptions },
      {
        value: "played_hand",
        label: "Hand has been Played",
        options: pokerHandOptions,
      },
      {
        value: "not_played_hand",
        label: "Hand has not been Played",
        options: pokerHandOptions,
      },
      {
        value: "last_played_hand",
        label: "Last Played Hand",
        options: pokerHandOptions,
      },
      { value: "blinds", label: "Blinds", options: blindsOptions },
      {
        value: "resources",
        label: "Player Resources",
        options: resourcesOptions,
      },
    ],
  },
  round_win: {
    categories: [
      { value: "jokers", label: "Jokers", options: jokersOptions },
      {
        value: "played_hand",
        label: "Hand has been Played",
        options: pokerHandOptions,
      },
      {
        value: "not_played_hand",
        label: "Hand has not been Played",
        options: pokerHandOptions,
      },
      {
        value: "last_played_hand",
        label: "Last Played Hand",
        options: pokerHandOptions,
      },
      { value: "blinds", label: "Blinds", options: blindsOptions },
      {
        value: "resources",
        label: "Player Resources",
        options: resourcesOptions,
      },
    ],
  },
  chip_score: {
    categories: [],
  },
};

const propertyConditionGenerators: Record<
  string,
  (property: string, targetCard: string, comparison?: string) => string
> = {
  // CARDS
  rank: (property, target) => `${target}:get_id() == ${property}`,
  suit: (property, target) => `${target}:is_suit("${property}")`,
  enhancement: (property, target) =>
    property === "any"
      ? `SMODS.get_enhancements(${target})`
      : `SMODS.has_enhancement(${target}, "${property}")`,
  seal: (property, target) =>
    property === "any"
      ? `${target}.seal ~= nil`
      : `${target}.seal == "${property}"`,
  edition: (property, target) =>
    property === "any"
      ? `${target}.edition ~= nil`
      : `${target}.edition and ${target}.edition.key == "${property}"`,
  sticker: (property, target) => `${target}.ability.${property}`,
  rarity: (property, target) => `${target}.config.center.rarity == ${property}`,
  poker_hand: (property) =>
    `next(evaluate_poker_hand(args.cards)["${property}"])`,

  // WIN RUN/ROUND
  played_hand: (property, _, comparison) =>
    `G.GAME.hands["${property}"].played ${comparison}`,
  not_played_hand: (property) => `G.GAME.hands["${property}"].played == 0`,
  last_played_hand: (property) => `G.GAME.last_hand_played == "${property}"`,
  jokers: (property, _, comparison) => {
    if (property === "joker_count")
      return `#(G.jokers and G.jokers.cards or {}) ${comparison}`;
    if (property === "joker_slots")
      return `(G.jokers and G.jokers.config.card_limit or 0) ${comparison}`;
    if (property === "max_jokers") return `G.GAME.max_jokers ${comparison}`;
    return "true";
  },
  blinds: (property, _, comparison) => {
    if (property === "boss") return `G.GAME.blind.boss`;
    if (property === "ante") return `args.ante ${comparison}`;
    return `G.GAME.${property} ${comparison}`;
  },
  resources: (property, _, comparison) => {
    if (property === "hands" || property === "discards")
      return `G.GAME.current_round.${property}_left ${comparison}`;
    return `G.GAME.${property} ${comparison}`;
  },
};

const generatePropertyConditions = (
  unlockProperties?: Array<{ category: string; property: string }>,
  targetCard?: string,
  comparison?: string
): string[] | undefined =>
  unlockProperties?.map(({ category, property }) => {
    const generator = propertyConditionGenerators[category];
    return generator
      ? generator(property, targetCard ?? "", comparison)
      : "true";
  });

export const generateUnlockFunction = (jokerData: JokerData) => {
  const unlockTrigger = jokerData.unlockTrigger;
  const unlockProperties = jokerData.unlockProperties;
  const unlockOperator = jokerData.unlockOperator;
  const unlockCount = jokerData.unlockCount ?? 1;

  let comparison = "";
  switch (unlockOperator) {
    case "equals":
      comparison = `== to_big(${unlockCount})`;
      break;
    case "greater_than":
      comparison = `> to_big(${unlockCount})`;
      break;
    case "less_than":
      comparison = `< to_big(${unlockCount})`;
      break;
    case "greater_equals":
      comparison = `>= to_big(${unlockCount})`;
      break;
    case "less_equals":
      comparison = `<= to_big(${unlockCount})`;
      break;
    default:
      comparison = `== to_big(${unlockCount})`;
  }

  let unlockFunction = `,
  check_for_unlock = function(self,args)
    if args.type == "${unlockTrigger}" then
      local count = 0`;

  if (unlockTrigger === "chip_score") {
    unlockFunction += `\n return args.chips ${comparison}`;
  } else if (unlockTrigger === "career_stat") {
    unlockFunction += `\n return G.PROFILES[G.SETTINGS.profile].career_stats.${unlockProperties?.[0].property} ${comparison}`;
  } else if (unlockTrigger === "win" || unlockTrigger === "round_win") {
    const conditions = generatePropertyConditions(
      unlockProperties,
      "",
      comparison
    )?.join(" and ");

    unlockFunction += `\n return ${conditions}`;
  } else if (
    unlockTrigger === "hand_contents" ||
    unlockTrigger === "modify_deck" ||
    unlockTrigger === "modify_jokers" ||
    unlockTrigger === "discard_custom"
  ) {
    let targetCard = "";

    switch (unlockTrigger) {
      case "discard_custom":
      case "hand_contents":
        unlockFunction += `
        for i = 1, #args.cards do`;
        targetCard = `args.cards[i]`;
        break;

      case "modify_deck":
        unlockFunction += `
        if deck_initialized == nil then
          local deck_initialized = false
        end

        if not deck_initialized and #G.playing_cards >= 40 then
          deck_initialized = true
        end

        if not deck_initialized then
          return false
        end

        for _, card in ipairs(G.playing_cards or {}) do`;
        targetCard = `card`;
        break;

      case "modify_jokers":
        unlockFunction += `
        for _, joker in ipairs(G.jokers.cards) do`;
        targetCard = `joker`;
        break;
    }

    const conditions = generatePropertyConditions(
      unlockProperties,
      targetCard
    )?.join(" and ");

    unlockFunction += `
    if ${conditions?.length ? conditions : "true"} then
      count = count + 1
    end
    end
      if count ${comparison} then
        return true
      end`;
  }

  unlockFunction += `
  end
  return false
  end`;

  return unlockFunction;
};

```

### src\components\codeGeneration\Jokers\variableUtils.ts

```
import type { Rule, Effect } from "../../ruleBuilder/types";
import type {
  JokerData,
  ConsumableData,
  EnhancementData,
  UserVariable,
  SealData,
  EditionData,
} from "../../data/BalatroUtils";
import { parseGameVariable } from "../Consumables/gameVariableUtils";
import { getGameVariableById } from "../../data/Jokers/GameVars";
import {
  SUIT_VALUES,
  RANK_VALUES,
  RANK_LABELS,
  ENHANCEMENT_VALUES,
  EDITION_VALUES,
  SEAL_VALUES,
} from "../../data/BalatroUtils";

export interface VariableInfo {
  name: string;
  initialValue: number;
  usedInEffects: string[];
}

export interface VariableUsage {
  variableName: string;
  ruleId: string;
  ruleIndex: number;
  type: "condition" | "effect";
  itemId: string;
  count: number;
}

export interface GameVariableInfo {
  id: string;
  name: string;
  description: string;
  multiplier: number;
  startsFrom: number;
  code: string;
}

export interface SuitVariableInfo {
  isSuitVariable: boolean;
  variableName?: string;
  code?: string;
}

export interface RankVariableInfo {
  isRankVariable: boolean;
  variableName?: string;
  code?: string;
}

export interface PokerHandVariableInfo {
  isPokerHandVariable: boolean;
  variableName?: string;
  code?: string;
}

export const coordinateVariableConflicts = (
  effects: Effect[]
): {
  preReturnCode?: string;
  modifiedEffects: Effect[];
} => {
  const variableOperations: Array<{
    varName: string;
    type: "read" | "write";
    effectIndex: number;
    effect: Effect;
  }> = [];

  effects.forEach((effect, index) => {
    if (effect.type === "modify_internal_variable") {
      const varName = effect.params.variable_name as string;
      if (varName) {
        variableOperations.push({
          varName,
          type: "write",
          effectIndex: index,
          effect,
        });
      }
    }

    const explicitVariables = extractExplicitVariablesFromEffect(effect);
    explicitVariables.forEach((varName) => {
      variableOperations.push({
        varName,
        type: "read",
        effectIndex: index,
        effect,
      });
    });
  });

  const varGroups = variableOperations.reduce((acc, op) => {
    if (!acc[op.varName]) {
      acc[op.varName] = [];
    }
    acc[op.varName].push(op);
    return acc;
  }, {} as Record<string, typeof variableOperations>);

  const conflictedVars: string[] = [];

  Object.entries(varGroups).forEach(([varName, operations]) => {
    const reads = operations.filter((op) => op.type === "read");
    const writes = operations.filter((op) => op.type === "write");

    if (reads.length === 0 || writes.length === 0) {
      return;
    }

    for (const read of reads) {
      for (const write of writes) {
        if (read.effectIndex < write.effectIndex) {
          conflictedVars.push(varName);
          return;
        }
      }
    }
  });

  if (conflictedVars.length === 0) {
    return { modifiedEffects: effects };
  }

  const preReturnCode = conflictedVars
    .map((varName) => `local ${varName}_value = card.ability.extra.${varName}`)
    .join("\n                ");

  const modifiedEffects = effects.map((effect) => {
    if (effect.type === "modify_internal_variable") {
      return effect;
    }

    const modifiedParams = { ...effect.params };
    const explicitVariables = extractExplicitVariablesFromEffect(effect);

    explicitVariables.forEach((varName) => {
      if (conflictedVars.includes(varName)) {
        Object.entries(effect.params).forEach(([key, value]) => {
          if (value === varName) {
            modifiedParams[key] = `${varName}_value`;
          }
        });
      }
    });

    return { ...effect, params: modifiedParams };
  });

  return { preReturnCode, modifiedEffects };
};

const extractExplicitVariablesFromEffect = (effect: Effect): string[] => {
  const variables: string[] = [];

  const keyParameterNames = new Set([
    "joker_key",
    "consumable_key",
    "card_key",
    "target_joker",
    "specific_joker",
    "blind_name",
    "tag_key",
    "enhancement_type",
    "edition_type",
    "seal_type",
    "suit_type",
    "rank_type",
    "poker_hand_type",
    "set",
    "specific_hand"
  ]);

  Object.entries(effect.params).forEach(([paramName, value]) => {
    if (keyParameterNames.has(paramName)) {
      return;
    }

    if (
      typeof value === "string" &&
      (value.startsWith("j_") ||
        value.startsWith("c_") ||
        value.startsWith("m_") ||
        value.startsWith("e_") ||
        value.startsWith("b_") ||
        value.startsWith("tag_") ||
        value.startsWith("v_"))
    ) {
      return;
    }

    if (typeof value === "string" && isUserDefinedVariable(value)) {
      variables.push(value);
    }
  });

  return variables;
};

export const extractGameVariablesFromRules = (
  rules: Rule[]
): GameVariableInfo[] => {
  const gameVariableMap = new Map<string, GameVariableInfo>();

  const processParams = (params: Record<string, unknown>) => {
    Object.values(params).forEach((value) => {
      const parsed = parseGameVariable(value);
      if (parsed.isGameVariable && parsed.gameVariableId && parsed.code) {
        const gameVar = getGameVariableById(parsed.gameVariableId);
        if (gameVar && !gameVariableMap.has(parsed.gameVariableId)) {
          gameVariableMap.set(parsed.gameVariableId, {
            id: parsed.gameVariableId,
            name: gameVar.label,
            description: gameVar.description,
            multiplier: parsed.multiplier || 1,
            startsFrom: parsed.startsFrom || 0,
            code: parsed.code,
          });
        }
      }
    });
  };

  rules.forEach((rule) => {
    rule.conditionGroups.forEach((group) => {
      group.conditions.forEach((condition) => {
        processParams(condition.params);
      });
    });

    (rule.effects || []).forEach((effect) => {
      processParams(effect.params);
    });

    (rule.randomGroups || []).forEach((group) => {
      group.effects.forEach((effect) => {
        processParams(effect.params);
      });
    });
  });

  return Array.from(gameVariableMap.values());
};

export const getSuitVariables = (
  item: JokerData | EnhancementData
): UserVariable[] => {
  return (item.userVariables || []).filter((v) => v.type === "suit");
};

export const getRankVariables = (
  item: JokerData | EnhancementData
): UserVariable[] => {
  return (item.userVariables || []).filter((v) => v.type === "rank");
};

export const parseSuitVariable = (
  value: unknown,
  item?: JokerData | EnhancementData
): SuitVariableInfo => {
  if (typeof value === "string" && item?.userVariables) {
    const suitVariable = item.userVariables.find(
      (v) => v.name === value && v.type === "suit"
    );

    if (suitVariable) {
      return {
        isSuitVariable: true,
        variableName: value,
        code: `G.GAME.current_round.${value}_card.suit`,
      };
    }
  }

  return {
    isSuitVariable: false,
  };
};

export const parseRankVariable = (
  value: unknown,
  item?: JokerData | EnhancementData
): RankVariableInfo => {
  if (typeof value === "string" && item?.userVariables) {
    const rankVariable = item.userVariables.find(
      (v) => v.name === value && v.type === "rank"
    );

    if (rankVariable) {
      return {
        isRankVariable: true,
        variableName: value,
        code: `G.GAME.current_round.${value}_card.id`,
      };
    }
  }

  return {
    isRankVariable: false,
  };
};

export const addSuitVariablesToOptions = (
  baseOptions: Array<{ value: string; label: string }>,
  item: JokerData | EnhancementData
): Array<{ value: string; label: string }> => {
  const suitVariables = getSuitVariables(item);
  const variableOptions = suitVariables.map((variable) => ({
    value: variable.name,
    label: `${variable.name} (suit variable)`,
  }));

  return [...baseOptions, ...variableOptions];
};

export const addRankVariablesToOptions = (
  baseOptions: Array<{ value: string; label: string }>,
  item: JokerData | EnhancementData
): Array<{ value: string; label: string }> => {
  const rankVariables = getRankVariables(item);
  const variableOptions = rankVariables.map((variable) => ({
    value: variable.name,
    label: `${variable.name} (rank variable)`,
  }));

  return [...baseOptions, ...variableOptions];
};

const isUserDefinedVariable = (str: string): boolean => {
  return (
    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str) &&
    !isReservedKeyword(str) &&
    !isBuiltInValue(str)
  );
};

export const getPokerHandVariables = (
  item: JokerData | EnhancementData
): UserVariable[] => {
  return (item.userVariables || []).filter((v) => v.type === "pokerhand");
};

export const parsePokerHandVariable = (
  value: unknown,
  item?: JokerData | EnhancementData
): PokerHandVariableInfo => {
  if (typeof value === "string" && item?.userVariables) {
    const pokerHandVariable = item.userVariables.find(
      (v) => v.name === value && v.type === "pokerhand"
    );

    if (pokerHandVariable) {
      return {
        isPokerHandVariable: true,
        variableName: value,
        code: `G.GAME.current_round.${value}_hand`,
      };
    }
  }

  return {
    isPokerHandVariable: false,
  };
};

export const addPokerHandVariablesToOptions = (
  baseOptions: Array<{ value: string; label: string }>,
  item: JokerData | EnhancementData
): Array<{ value: string; label: string }> => {
  const pokerHandVariables = getPokerHandVariables(item);
  const variableOptions = pokerHandVariables.map((variable) => ({
    value: variable.name,
    label: `${variable.name} (poker hand variable)`,
  }));

  return [...baseOptions, ...variableOptions];
};

const isReservedKeyword = (str: string): boolean => {
  const reserved = new Set([
    "true",
    "false",
    "nil",
    "and",
    "or",
    "not",
    "if",
    "then",
    "else",
    "end",
    "function",
    "return",
    "local",
    "for",
    "while",
    "repeat",
    "until",
    "break",
    "do",
    "in",
    "self",
    "card",
    "context",
    "G",
    "SMODS",
  ]);
  return reserved.has(str);
};

const isBuiltInValue = (str: string): boolean => {
  const suitValues = new Set(SUIT_VALUES);
  const rankValues = new Set([...RANK_VALUES, ...RANK_LABELS]);
  const enhancementValues = new Set(ENHANCEMENT_VALUES());
  const editionValues = new Set(EDITION_VALUES());
  const sealValues = new Set(SEAL_VALUES());

  type SuitType = (typeof SUIT_VALUES)[number];
  type RankType = (typeof RANK_VALUES)[number] | (typeof RANK_LABELS)[number];
  type EnhancementType = string;
  type EditionType = string;
  type SealType = string;

  if (
    suitValues.has(str as SuitType) ||
    rankValues.has(str as RankType) ||
    enhancementValues.has(str as EnhancementType) ||
    editionValues.has(str as EditionType) ||
    sealValues.has(str as SealType)
  ) {
    return true;
  }

  const otherBuiltIns = new Set([
    "random",
    "none",
    "any",
    "all",
    "specific",
    "group",
    "equals",
    "not_equals",
    "greater_than",
    "less_than",
    "greater_equals",
    "less_equals",
    "contains",
    "scoring",
    "all_played",
    "face",
    "even",
    "odd",
    "red",
    "black",
    "current",
    "add",
    "subtract",
    "set",
    "increment",
    "decrement",
    "multiply",
    "divide",
    "small",
    "big",
    "boss",
    "remaining",
    "total",
    "rank",
    "suit",
    "enhancement",
    "seal",
    "edition",
    "first",
    "last",
    "left",
    "right",
    "position",
    "tarot",
    "planet",
    "spectral",
    "negative",
    "common",
    "uncommon",
    "rare",
    "legendary",
    "remove",
    "Gold",
    "Red",
    "Blue",
    "Purple",
    "T",
  ]);

  return otherBuiltIns.has(str);
};

export const extractVariablesFromRules = (rules: Rule[]): VariableInfo[] => {
  const variableMap = new Map<string, VariableInfo>();

  rules.forEach((rule) => {
    rule.conditionGroups.forEach((group) => {
      group.conditions.forEach((condition) => {
        if (condition.type === "internal_variable") {
          const varName = (condition.params.variable_name as string) || "var1";
          if (!variableMap.has(varName)) {
            variableMap.set(varName, {
              name: varName,
              initialValue: 0,
              usedInEffects: [],
            });
          }
        }
      });
    });

    (rule.effects || []).forEach((effect) => {
      if (effect.type === "modify_internal_variable") {
        const varName = (effect.params.variable_name as string) || "var1";
        if (!variableMap.has(varName)) {
          variableMap.set(varName, {
            name: varName,
            initialValue: 0,
            usedInEffects: [],
          });
        }
        variableMap.get(varName)!.usedInEffects.push(effect.type);
      }

      const explicitVariables = extractExplicitVariablesFromEffect(effect);
      explicitVariables.forEach((varName) => {
        if (!variableMap.has(varName)) {
          variableMap.set(varName, {
            name: varName,
            initialValue: 0,
            usedInEffects: [],
          });
        }
        variableMap.get(varName)!.usedInEffects.push(effect.type);
      });
    });

    (rule.randomGroups || []).forEach((group) => {
      group.effects.forEach((effect) => {
        if (effect.type === "modify_internal_variable") {
          const varName = (effect.params.variable_name as string) || "var1";
          if (!variableMap.has(varName)) {
            variableMap.set(varName, {
              name: varName,
              initialValue: 0,
              usedInEffects: [],
            });
          }
          variableMap.get(varName)!.usedInEffects.push(effect.type);
        }

        const explicitVariables = extractExplicitVariablesFromEffect(effect);
        explicitVariables.forEach((varName) => {
          if (!variableMap.has(varName)) {
            variableMap.set(varName, {
              name: varName,
              initialValue: 0,
              usedInEffects: [],
            });
          }
          variableMap.get(varName)!.usedInEffects.push(effect.type);
        });
      });
    });
  });

  return Array.from(variableMap.values());
};

export const generateVariableConfig = (variables: VariableInfo[]): string => {
  if (variables.length === 0) return "";

  const configItems = variables.map((variable) => {
    return `${variable.name} = ${variable.initialValue}`;
  });

  return configItems.join(",\n            ");
};

export const getVariableNamesFromItem = (
  item: JokerData | ConsumableData | EnhancementData
): string[] => {
  if (!item.rules) return [];

  const variableNames = new Set<string>();

  item.rules.forEach((rule) => {
    (rule.effects || []).forEach((effect) => {
      if (effect.type === "modify_internal_variable") {
        const varName = (effect.params.variable_name as string) || "var1";
        variableNames.add(varName);
      }

      const explicitVariables = extractExplicitVariablesFromEffect(effect);
      explicitVariables.forEach((varName) => {
        variableNames.add(varName);
      });
    });

    (rule.randomGroups || []).forEach((group) => {
      group.effects.forEach((effect) => {
        if (effect.type === "modify_internal_variable") {
          const varName = (effect.params.variable_name as string) || "var1";
          variableNames.add(varName);
        }

        const explicitVariables = extractExplicitVariablesFromEffect(effect);
        explicitVariables.forEach((varName) => {
          variableNames.add(varName);
        });
      });
    });

    rule.conditionGroups.forEach((group) => {
      group.conditions.forEach((condition) => {
        if (condition.type === "internal_variable") {
          const varName = (condition.params.variable_name as string) || "var1";
          variableNames.add(varName);
        }
      });
    });
  });

  return Array.from(variableNames).sort();
};

export const getVariableUsageDetails = (
  item: JokerData | ConsumableData | EnhancementData | SealData | EditionData
): VariableUsage[] => {
  if (!item.rules) return [];

  const usageDetails: VariableUsage[] = [];
  const usageCount = new Map<string, number>();

  item.rules.forEach((rule, ruleIndex) => {
    (rule.effects || []).forEach((effect) => {
      if (effect.type === "modify_internal_variable") {
        const varName = (effect.params.variable_name as string) || "var1";
        const currentCount = usageCount.get(varName) || 0;
        usageCount.set(varName, currentCount + 1);

        usageDetails.push({
          variableName: varName,
          ruleId: rule.id,
          ruleIndex: ruleIndex + 1,
          type: "effect",
          itemId: effect.id,
          count: currentCount + 1,
        });
      }

      const explicitVariables = extractExplicitVariablesFromEffect(effect);
      explicitVariables.forEach((varName) => {
        const currentCount = usageCount.get(varName) || 0;
        usageCount.set(varName, currentCount + 1);

        usageDetails.push({
          variableName: varName,
          ruleId: rule.id,
          ruleIndex: ruleIndex + 1,
          type: "effect",
          itemId: effect.id,
          count: currentCount + 1,
        });
      });
    });

    (rule.randomGroups || []).forEach((group) => {
      group.effects.forEach((effect) => {
        if (effect.type === "modify_internal_variable") {
          const varName = (effect.params.variable_name as string) || "var1";
          const currentCount = usageCount.get(varName) || 0;
          usageCount.set(varName, currentCount + 1);

          usageDetails.push({
            variableName: varName,
            ruleId: rule.id,
            ruleIndex: ruleIndex + 1,
            type: "effect",
            itemId: effect.id,
            count: currentCount + 1,
          });
        }

        const explicitVariables = extractExplicitVariablesFromEffect(effect);
        explicitVariables.forEach((varName) => {
          const currentCount = usageCount.get(varName) || 0;
          usageCount.set(varName, currentCount + 1);

          usageDetails.push({
            variableName: varName,
            ruleId: rule.id,
            ruleIndex: ruleIndex + 1,
            type: "effect",
            itemId: effect.id,
            count: currentCount + 1,
          });
        });
      });
    });

    rule.conditionGroups.forEach((group) => {
      group.conditions.forEach((condition) => {
        if (condition.type === "internal_variable") {
          const varName = (condition.params.variable_name as string) || "var1";
          const currentCount = usageCount.get(varName) || 0;
          usageCount.set(varName, currentCount + 1);

          usageDetails.push({
            variableName: varName,
            ruleId: rule.id,
            ruleIndex: ruleIndex + 1,
            type: "condition",
            itemId: condition.id,
            count: currentCount + 1,
          });
        }
      });
    });
  });

  return usageDetails;
};

export const getAllVariables = (
  item: JokerData | ConsumableData | EnhancementData | SealData | EditionData
): UserVariable[] => {
  // For jokers and enhancements, get user variables if they exist
  const userVars = (item as JokerData | EnhancementData).userVariables || [];
  const autoVars: UserVariable[] = [];
  const probabilityVars: UserVariable[] = [];

  if (!item.rules) {
    return userVars;
  }

  const nonPassiveRules =
    item.rules.filter((rule) => rule.trigger !== "passive") || [];

  const hasRandomGroups = nonPassiveRules.some(
    (rule) => rule.randomGroups && rule.randomGroups.length > 0
  );

  if (hasRandomGroups) {
    const randomGroups = nonPassiveRules.flatMap(
      (rule) => rule.randomGroups || []
    );
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator)),
    ];
    const numerators = [
      ...new Set(randomGroups.map((group) => group.chance_numerator)),
    ];

    if (denominators.length === 1 && numerators.length === 1) {
      probabilityVars.push({
        id: "auto_numerator",
        name: "numerator",
        initialValue: Number(numerators[0]),
        description: `Chance numerator (e.g., ${numerators[0]} in '${numerators[0]} in X')`,
      });
      probabilityVars.push({
        id: "auto_denominator",
        name: "denominator",
        initialValue: Number(denominators[0]),
        description: `Chance denominator (e.g., ${denominators[0]} in 'X in ${denominators[0]}')`,
      });
    } else if (denominators.length > 1) {
      denominators.forEach((denom, index) => {
        const numerator = numerators[Math.min(index, numerators.length - 1)];

        if (index === 0) {
          probabilityVars.push({
            id: "auto_numerator",
            name: "numerator",
            initialValue: Number(numerator),
            description: `Chance numerator (e.g., ${numerator} in '${numerator} in X')`,
          });
        } else {
          probabilityVars.push({
            id: `auto_numerator_${index + 1}`,
            name: `numerator${index + 1}`,
            initialValue: Number(numerator),
            description: `${index + 1}${getOrdinalSuffix(
              index + 1
            )} chance numerator (e.g., ${numerator} in '${numerator} in X')`,
          });
        }

        if (index === 0) {
          probabilityVars.push({
            id: "auto_denominator",
            name: "denominator",
            initialValue: Number(denom),
            description: `Chance denominator (e.g., ${denom} in 'X in ${denom}')`,
          });
        } else {
          probabilityVars.push({
            id: `auto_denominator_${index + 1}`,
            name: `denominator${index + 1}`,
            initialValue: Number(denom),
            description: `${index + 1}${getOrdinalSuffix(
              index + 1
            )} chance denominator (e.g., ${denom} in 'X in ${denom}')`,
          });
        }
      });
    } else if (numerators.length > 1) {
      numerators.forEach((num, index) => {
        const denominator =
          denominators[Math.min(index, denominators.length - 1)];

        if (index === 0) {
          probabilityVars.push({
            id: "auto_numerator",
            name: "numerator",
            initialValue: Number(num),
            description: `Chance numerator (e.g., ${num} in '${num} in X')`,
          });
        } else {
          probabilityVars.push({
            id: `auto_numerator_${index + 1}`,
            name: `numerator${index + 1}`,
            initialValue: Number(num),
            description: `${index + 1}${getOrdinalSuffix(
              index + 1
            )} chance numerator (e.g., ${num} in '${num} in X')`,
          });
        }

        if (index === 0) {
          probabilityVars.push({
            id: "auto_denominator",
            name: "denominator",
            initialValue: Number(denominator),
            description: `Chance denominator (e.g., ${denominator} in 'X in ${denominator}')`,
          });
        } else {
          probabilityVars.push({
            id: `auto_denominator_${index + 1}`,
            name: `denominator${index + 1}`,
            initialValue: Number(denominator),
            description: `${index + 1}${getOrdinalSuffix(
              index + 1
            )} chance denominator (e.g., ${denominator} in 'X in ${denominator}')`,
          });
        }
      });
    }
  }

  // For jokers, extract explicit variables (consumables/enhancements don't have these complex variables)
  let explicitVariableNames: string[] = [];
  if ("jokerKey" in item) {
    // Check if it's a joker
    explicitVariableNames = getVariableNamesFromItem(item)
      .filter((name) => !userVars.some((uv) => uv.name === name))
      .filter(
        (name) =>
          !name.startsWith("denominator") && !name.startsWith("numerator")
      );
  }

  const otherAutoVars = explicitVariableNames.map((name) => ({
    id: `auto_${name}`,
    name,
    initialValue: getDefaultVariableValue(name),
    description: getDefaultVariableDescription(name),
  }));

  const gameVariables = extractGameVariablesFromRules(item.rules || []);
  const gameVarAutoVars = gameVariables.map((gameVar) => ({
    id: `auto_gamevar_${gameVar.id}`,
    name: gameVar.name
      .replace(/\s+/g, "")
      .replace(/^([0-9])/, "_$1") // if the name starts with a number prefix it with _
      .toLowerCase(),
    initialValue: gameVar.startsFrom,
    description: `${gameVar.description}${
      gameVar.multiplier !== 1 ? ` (${gameVar.multiplier})` : ""
    }${gameVar.startsFrom !== 0 ? ` (starts from ${gameVar.startsFrom})` : ""}`,
  }));

  return [
    ...userVars,
    ...autoVars,
    ...otherAutoVars,
    ...gameVarAutoVars,
    ...probabilityVars,
  ];
};

const getOrdinalSuffix = (num: number): string => {
  if (num === 2) return "nd";
  if (num === 3) return "rd";
  return "th";
};

const getDefaultVariableValue = (name: string): number => {
  const defaults: Record<string, number> = {
    chips: 10,
    mult: 5,
    Xmult: 1.5,
    xchips: 1.5,
    dollars: 5,
    repetitions: 1,
    hands: 1,
    discards: 1,
    levels: 1,
    ante_value: 1,
  };
  return defaults[name] || 0;
};

const getDefaultVariableDescription = (name: string): string => {
  const descriptions: Record<string, string> = {
    chips: "Chips to add",
    mult: "Mult to add",
    Xmult: "X Mult multiplier",
    xchips: "X Chips multiplier",
    dollars: "Money to add",
    repetitions: "Card repetitions",
    hands: "Hands to modify",
    discards: "Discards to modify",
    levels: "Hand levels to add",
    ante_value: "Ante level value",
  };
  return descriptions[name] || "Custom variable";
};

```

### src\components\Contexts.tsx

```
import {
  createContext,
  ReactNode,
  useCallback,
  useEffect,
  useState,
} from "react";
import { UserConfig } from "./data/BalatroUtils";

const USER_CONFIG_KEY = "joker-forge-user-config";

interface UserConfigContextType {
  userConfig: UserConfig;
  setUserConfig: React.Dispatch<React.SetStateAction<UserConfig>>;
}

// eslint-disable-next-line react-refresh/only-export-components
export const UserConfigContext = createContext<UserConfigContextType>({
  userConfig: { filters: {}, defaultAutoFormat: true, defaultGridSnap: false },
  setUserConfig: () => {},
});

type ContextProviderProps = {
  children: ReactNode;
};

export const UserConfigProvider = ({ children }: ContextProviderProps) => {
  const loadUserConfig = useCallback((): UserConfig => {
    try {
      const stored = localStorage.getItem(USER_CONFIG_KEY);
      return stored
        ? JSON.parse(stored)
        : {
            filters: {},
            defaultAutoFormat: true,
            defaultGridSnap: false,
          };
    } catch (err) {
      console.error("Failed to parse userConfig from localStorage", err);
      return {
        filters: {},
        defaultAutoFormat: true,
        defaultGridSnap: false,
      };
    }
  }, []);

  const [userConfig, setUserConfig] = useState<UserConfig>(() =>
    loadUserConfig()
  );

  useEffect(() => {
    localStorage.setItem(USER_CONFIG_KEY, JSON.stringify(userConfig));
  }, [userConfig]);

  return (
    <UserConfigContext.Provider value={{ userConfig, setUserConfig }}>
      {children}
    </UserConfigContext.Provider>
  );
};

```

### src\components\data\BalatroUtils.ts

```
import { unlockOptions } from "../codeGeneration/Jokers/unlockUtils";
import { Rule } from "../ruleBuilder/types";

export const slugify = (text: string): string => {
  return (
    text
      .toLowerCase()
      .replace(/[\s\W_]+/g, "")
      .replace(/^[\d]/, "_$&") ||
    `booster_${Math.random().toString(36).substring(2, 8)}`
  );
};

export interface ModMetadata {
  id: string;
  name: string;
  author: string[];
  description: string;
  prefix: string;
  main_file: string;
  disable_vanilla?: boolean;
  version: string;
  priority: number;
  badge_colour: string;
  badge_text_colour: string;
  display_name: string;
  dependencies: string[];
  conflicts: string[];
  provides: string[];
  dump_loc?: boolean;
  iconImage?: string;
  hasUserUploadedIcon?: boolean;
}

export interface UserConfig {
  filters: {
    jokersFilter?: string;
    consumablesFilter?: string;
    boostersFilter?: string;
    enhancementsFilter?: string;
    sealsFilter?: string;
    editionsFilter?: string;
  };
  defaultAutoFormat: boolean;
  defaultGridSnap: boolean;
}

// =============================================================================
// DATA REGISTRY INTERFACES
// =============================================================================

export interface UserVariable {
  id: string;
  name: string;
  type?: "number" | "suit" | "rank" | "pokerhand";
  description?: string;
  initialValue?: number;
  initialSuit?: "Spades" | "Hearts" | "Diamonds" | "Clubs";
  initialRank?:
    | "2"
    | "3"
    | "4"
    | "5"
    | "6"
    | "7"
    | "8"
    | "9"
    | "10"
    | "Jack"
    | "Queen"
    | "King"
    | "Ace";
  initialPokerHand?:
    | "High Card"
    | "Pair"
    | "Two Pair"
    | "Three of a Kind"
    | "Straight"
    | "Flush"
    | "Full House"
    | "Flush House"
    | "Four of a Kind"
    | "Five of a Kind"
    | "Straight Flush"
    | "Flush House"
    | "Flush Five";
}

export interface JokerData {
  id: string;
  name: string;
  description: string;
  imagePreview: string;
  overlayImagePreview?: string;
  rarity: number | string;
  cost?: number;
  blueprint_compat?: boolean;
  eternal_compat?: boolean;
  perishable_compat?: boolean;
  unlocked?: boolean;
  discovered?: boolean;
  force_eternal?: boolean;
  force_perishable?: boolean;
  force_rental?: boolean;
  force_foil?: boolean;
  force_holographic?: boolean;
  force_polychrome?: boolean;
  force_negative?: boolean;
  appears_in_shop?: boolean;
  unlockTrigger?: keyof typeof unlockOptions;
  unlockProperties?: Array<{ category: string; property: string }>;
  unlockOperator?: string;
  unlockCount?: number;
  unlockDescription: string;
  rules?: Rule[];
  userVariables?: UserVariable[];
  placeholderCreditIndex?: number;
  jokerKey?: string;
  hasUserUploadedImage?: boolean;
  cardAppearance: {
    // this uses the "source keys" as keys
    jud?: boolean; // judgement
    sou?: boolean; // soul
    wra?: boolean; // wraith
    buf?: boolean; // buffoon_pack
    rif?: boolean; // riff raff
    rta?: boolean; // rare tag
    uta?: boolean; // uncommon tag
  };
  appearFlags?: string;
  ignoreSlotLimit?: boolean;
  scale_w?: number;
  scale_h?: number;
  pools?: string[];
}

export interface RarityData {
  id: string;
  key: string;
  name: string;
  badge_colour: string;
  default_weight: number;
}

export interface ConsumableData {
  id: string;
  name: string;
  description: string;
  imagePreview: string;
  overlayImagePreview?: string;
  set: "Tarot" | "Planet" | "Spectral" | string;
  cost?: number;
  unlocked?: boolean;
  discovered?: boolean;
  hidden?: boolean;
  can_repeat_soul?: boolean;
  rules?: Rule[];
  placeholderCreditIndex?: number;
  consumableKey?: string;
  hasUserUploadedImage?: boolean;
}

export interface ConsumableSetData {
  id: string;
  key: string;
  name: string;
  primary_colour: string;
  secondary_colour: string;
  collection_rows: [number, number];
  default_card?: string;
  shop_rate?: number;
  collection_name?: string;
}

export type BoosterType = "joker" | "consumable" | "playing_card";

export interface BoosterCardRule {
  set?: string;
  enhancement?: string;
  edition?: string;
  rarity?: string;
  suit?: string;
  rank?: string;
  seal?: string;
  weight?: number;
  specific_key?: string;
  specific_type?: "consumable" | "joker" | null;
  pool?: string;
}

export interface BoosterData {
  id: string;
  name: string;
  description: string;
  imagePreview: string;
  cost: number;
  weight: number;
  draw_hand: boolean;
  instant_use: boolean;
  booster_type: BoosterType;
  kind?: string;
  group_key?: string;
  atlas?: string;
  pos?: { x: number; y: number };
  config: {
    extra: number;
    choose: number;
  };
  card_rules: BoosterCardRule[];
  background_colour?: string;
  special_colour?: string;
  discovered?: boolean;
  hidden?: boolean;
  placeholderCreditIndex?: number;
  boosterKey?: string;
  hasUserUploadedImage?: boolean;
}

export interface EnhancementData {
  id: string;
  name: string;
  description: string;
  imagePreview: string;
  enhancementKey: string;
  atlas?: string;
  pos?: { x: number; y: number };
  any_suit?: boolean;
  replace_base_card?: boolean;
  no_rank?: boolean;
  no_suit?: boolean;
  always_scores?: boolean;
  unlocked?: boolean;
  discovered?: boolean;
  no_collection?: boolean;
  rules?: Rule[];
  weight?: number;
  userVariables?: UserVariable[];
  placeholderCreditIndex?: number;
  hasUserUploadedImage?: boolean;
}

export interface SealData {
  id: string;
  name: string;
  description: string;
  imagePreview: string;
  sealKey: string;
  atlas?: string;
  pos?: { x: number; y: number };
  badge_colour?: string;
  unlocked?: boolean;
  discovered?: boolean;
  no_collection?: boolean;
  rules?: Rule[];
  userVariables?: UserVariable[];
  placeholderCreditIndex?: number;
  hasUserUploadedImage?: boolean;
}

export interface EditionData {
  id: string;
  name: string;
  description: string;
  editionKey: string;
  shader: string | false;
  unlocked?: boolean;
  discovered?: boolean;
  no_collection?: boolean;
  in_shop?: boolean;
  weight?: number;
  extra_cost?: number;
  apply_to_float?: boolean;
  badge_colour?: string;
  sound?: string;
  disable_shadow?: boolean;
  disable_base_shader?: boolean;
  rules?: Rule[];
  userVariables?: UserVariable[];
}

export interface SoundData {
  id: string;
  key: string;
  pitch?: number;
  volume?: number;
  soundString: string;
}

// =============================================================================
// DATA REGISTRY SYSTEM
// =============================================================================

interface RegistryState {
  customRarities: RarityData[];
  consumableSets: ConsumableSetData[];
  consumables: ConsumableData[];
  boosters: BoosterData[];
  enhancements: EnhancementData[];
  seals: SealData[];
  editions: EditionData[];
  modPrefix: string;
}

let registryState: RegistryState = {
  customRarities: [],
  consumableSets: [],
  consumables: [],
  boosters: [],
  enhancements: [],
  seals: [],
  editions: [],
  modPrefix: "",
};

const VANILLA_RARITIES_DATA = [
  { value: "common", label: "Common" },
  { value: "uncommon", label: "Uncommon" },
  { value: "rare", label: "Rare" },
  { value: "legendary", label: "Legendary" },
];

const VANILLA_CONSUMABLE_SETS = [
  { value: "Tarot", label: "Tarot", key: "tarot" },
  { value: "Planet", label: "Planet", key: "planet" },
  { value: "Spectral", label: "Spectral", key: "spectral" },
];

const VANILLA_VOUCHERS_DATA = [
  { value: "v_overstock_norm", label: "Overstock" },
  { value: "v_overstock_plus", label: "Overstock Plus" },
  { value: "v_clearance_sale", label: "Clearance Sale" },
  { value: "v_liquidation", label: "Liquidation" },
  { value: "v_hone", label: "Hone" },
  { value: "v_glow_up", label: "Glow Up" },
  { value: "v_reroll_surplus", label: "Reroll Surplus" },
  { value: "v_reroll_glut", label: "Reroll Glut" },
  { value: "v_crystal_ball", label: "Crystal Ball" },
  { value: "v_omen_globe", label: "Omen Globe" },
  { value: "v_telescope", label: "Telescope" },
  { value: "v_observatory", label: "Observatory" },
  { value: "v_grabber", label: "Grabber" },
  { value: "v_nacho_tong", label: "Nacho Tong" },
  { value: "v_wasteful", label: "Wasteful" },
  { value: "v_recyclomancy", label: "Recyclomancy" },
  { value: "v_tarot_merchant", label: "Tarot Merchant" },
  { value: "v_tarot_tycoon", label: "Tarot Tycoon" },
  { value: "v_planet_merchant", label: "Planet Merchant" },
  { value: "v_planet_tycoon", label: "Planet Tycoon" },
  { value: "v_seed_money", label: "Seed Money" },
  { value: "v_money_tree", label: "Money Tree" },
  { value: "v_blank", label: "Blank" },
  { value: "v_antimatter", label: "Antimatter" },
  { value: "v_magic_trick", label: "Magic Trick" },
  { value: "v_illusion", label: "Illusion" },
  { value: "v_hieroglyph", label: "Hieroglyph" },
  { value: "v_petroglyph", label: "Petroglyph" },
  { value: "v_directors_cut", label: "Directors Cut" },
  { value: "v_retcon", label: "Retcon" },
  { value: "v_paint_brush", label: "Paint Brush" },
  { value: "v_palette", label: "Palette" },
];

const VANILLA_SEALS = [
  { key: "Gold", value: "Gold", label: "Gold" },
  { key: "Red", value: "Red", label: "Red" },
  { key: "Blue", value: "Blue", label: "Blue" },
  { key: "Purple", value: "Purple", label: "Purple" },
];

export const VOUCHERS = () => VANILLA_VOUCHERS_DATA; // integrate with data registry when custom vouchers are a thing

export const DataRegistry = {
  update: (
    customRarities: RarityData[],
    consumableSets: ConsumableSetData[],
    consumables: ConsumableData[],
    boosters: BoosterData[],
    enhancements: EnhancementData[],
    seals: SealData[],
    editions: EditionData[],
    modPrefix: string
  ) => {
    registryState = {
      customRarities,
      consumableSets,
      consumables,
      boosters,
      enhancements,
      seals,
      editions,
      modPrefix,
    };
  },

  getRarities: (): Array<{ value: string; label: string }> => {
    const custom = registryState.customRarities.map((rarity) => ({
      value: rarity.key,
      label: rarity.name,
    }));
    return [...VANILLA_RARITIES_DATA, ...custom];
  },

  getConsumableSets: (): Array<{
    value: string;
    label: string;
    key: string;
  }> => {
    const custom = registryState.consumableSets.map((set) => ({
      value: set.key,
      label: set.name,
      key: set.key,
    }));
    return [...VANILLA_CONSUMABLE_SETS, ...custom];
  },

  getConsumables: (): Array<{ value: string; label: string; set: string }> => {
    const custom = registryState.consumables.map((consumable) => ({
      value: `c_${registryState.modPrefix}_${
        consumable.consumableKey ||
        (consumable.name
          ? consumable.name.toLowerCase().replace(/\s+/g, "_")
          : "unnamed_consumable")
      }`,
      label: consumable.name || "Unnamed Consumable",
      set: consumable.set,
    }));
    return [...custom];
  },

  getBoosters: (): Array<{
    value: string;
    label: string;
    type: BoosterType;
  }> => {
    const custom = registryState.boosters.map((booster) => ({
      value: `${registryState.modPrefix}_${
        booster.boosterKey ||
        (booster.name
          ? booster.name.toLowerCase().replace(/\s+/g, "_")
          : "unnamed_booster")
      }`,
      label: booster.name || "Unnamed Booster",
      type: booster.booster_type,
    }));
    return [...custom];
  },

  getEnhancements: (): Array<{ key: string; value: string; label: string }> => {
    const vanilla = VANILLA_ENHANCEMENTS.map((enhancement) => ({
      key: enhancement.key,
      value: enhancement.value,
      label: enhancement.label,
    }));

    const custom = registryState.enhancements.map((enhancement) => ({
      key: `m_${registryState.modPrefix}_${enhancement.enhancementKey}`,
      value: `m_${registryState.modPrefix}_${enhancement.enhancementKey}`,
      label: enhancement.name || "Unnamed Enhancement",
    }));

    return [...vanilla, ...custom];
  },

  getSeals: (): Array<{ key: string; value: string; label: string }> => {
    const vanilla = VANILLA_SEALS.map((seal) => ({
      key: seal.key,
      value: seal.value,
      label: seal.label,
    }));

    const custom = registryState.seals.map((seal) => ({
      key: `${registryState.modPrefix}_${seal.sealKey}`,
      value: `${registryState.modPrefix}_${seal.sealKey}`,
      label: seal.name || "Unnamed Seal",
    }));

    return [...vanilla, ...custom];
  },

  getEditions: (): Array<{ key: string; value: string; label: string }> => {
    const vanilla = VANILLA_EDITIONS.map((edition) => ({
      key: edition.key,
      value: edition.value,
      label: edition.label,
    }));

    const custom = registryState.editions.map((edition) => ({
      key: `e_${registryState.modPrefix}_${edition.editionKey}`,
      value: `e_${registryState.modPrefix}_${edition.editionKey}`,
      label: edition.name || "Unnamed Edition",
    }));

    return [...vanilla, ...custom];
  },

  getState: () => ({ ...registryState }),
};

export const getModPrefix = () => {
  return registryState.modPrefix;
};

export const updateDataRegistry = (
  customRarities: RarityData[],
  consumableSets: ConsumableSetData[],
  consumables: ConsumableData[],
  boosters: BoosterData[],
  enhancements: EnhancementData[],
  seals: SealData[],
  editions: EditionData[],
  modPrefix: string
) => {
  DataRegistry.update(
    customRarities,
    consumableSets,
    consumables,
    boosters,
    enhancements,
    seals,
    editions,
    modPrefix
  );
};

// =============================================================================
// SHADERS SECTIONS
// =============================================================================

export const VANILLA_SHADERS = [
  { label: "Foil", key: "foil" },
  { label: "Holo", key: "holo" },
  { label: "Polychrome", key: "polychrome" },
  { label: "Booster", key: "booster" },
  { label: "Debuff", key: "debuff" },
  { label: "Voucher", key: "voucher" },
  { label: "Negative", key: "negative" },
  { label: "Negative Shine", key: "negative_shine" },
];

export const CUSTOM_SHADERS = [
  {
    label: "Anaglyphic (SMODS)",
    key: "anaglyphic",
    filepath: "/shaders/anaglyphic.fs",
  },
  {
    label: "Flipped (stupxd)",
    key: "flipped",
    filepath: "/shaders/flipped.fs",
  },
  {
    label: "Fluorescent (SMODS)",
    key: "fluorescent",
    filepath: "/shaders/fluorescent.fs",
  },
  { label: "Gilded (SMODS)", key: "gilded", filepath: "/shaders/gilded.fs" },
  { label: "Gold (stupxd)", key: "gold", filepath: "/shaders/gold.fs" },
  {
    label: "Greyscale (SMODS)",
    key: "greyscale",
    filepath: "/shaders/greyscale.fs",
  },
  { label: "Ionized (SMODS)", key: "ionized", filepath: "/shaders/ionized.fs" },
  {
    label: "Laminated (SMODS)",
    key: "laminated",
    filepath: "/shaders/laminated.fs",
  },
  {
    label: "Monochrome (SMODS)",
    key: "monochrome",
    filepath: "/shaders/monochrome.fs",
  },
  {
    label: "Overexposed (SMODS)",
    key: "overexposed",
    filepath: "/shaders/overexposed.fs",
  },
  { label: "Sepia (SMODS)", key: "sepia", filepath: "/shaders/sepia.fs" },
] as const;

export const isVanillaShader = (shaderKey: string): boolean => {
  return VANILLA_SHADERS.some((shader) => shader.key === shaderKey);
};

export const isCustomShader = (shaderKey: string): boolean => {
  return CUSTOM_SHADERS.some((shader) => shader.key === shaderKey);
};

export const getCustomShaderFilepath = (
  shaderKey: string
): string | undefined => {
  return CUSTOM_SHADERS.find((shader) => shader.key === shaderKey)?.filepath;
};

// =============================================================================
// EDITIONS SECTIONS
// =============================================================================

export const EDITIONS = () => DataRegistry.getEditions();
export const EDITION_KEYS = () => DataRegistry.getEditions().map((e) => e.key);
export const EDITION_VALUES = () =>
  DataRegistry.getEditions().map((e) => e.value);
export const EDITION_LABELS = () =>
  DataRegistry.getEditions().map((e) => e.label);

export const isCustomEdition = (
  value: string,
  customEditions: EditionData[] = registryState.editions,
  modPrefix: string = registryState.modPrefix
): boolean => {
  return (
    value.includes("_") &&
    customEditions.some((e) => `e_${modPrefix}_${e.editionKey}` === value)
  );
};

export const getEditionByValue = (
  value: string
): { key: string; value: string; label: string } | undefined => {
  return EDITIONS().find((edition) => edition.value === value);
};

export const getEditionByKey = (
  key: string
): { key: string; value: string; label: string } | undefined => {
  return EDITIONS().find((edition) => edition.key === key);
};

// =============================================================================
// SEALS SECTION
// =============================================================================

export const SEALS = () => DataRegistry.getSeals();
export const SEAL_KEYS = () => DataRegistry.getSeals().map((s) => s.key);
export const SEAL_VALUES = () => DataRegistry.getSeals().map((s) => s.value);
export const SEAL_LABELS = () => DataRegistry.getSeals().map((s) => s.label);

export const isCustomSeal = (
  value: string,
  customSeals: SealData[] = registryState.seals,
  modPrefix: string = registryState.modPrefix
): boolean => {
  return (
    value.includes("_") &&
    customSeals.some((s) => `${modPrefix}_${s.sealKey}` === value)
  );
};

export const getSealByValue = (
  value: string
): { key: string; value: string; label: string } | undefined => {
  return SEALS().find((seal) => seal.value === value);
};

export const getSealByKey = (
  key: string
): { key: string; value: string; label: string } | undefined => {
  return SEALS().find((seal) => seal.key === key);
};

// =============================================================================
// ENHANCEMENTS SECTION
// =============================================================================

const VANILLA_ENHANCEMENTS = [
  { key: "m_gold", value: "m_gold", label: "Gold" },
  { key: "m_steel", value: "m_steel", label: "Steel" },
  { key: "m_glass", value: "m_glass", label: "Glass" },
  { key: "m_wild", value: "m_wild", label: "Wild" },
  { key: "m_mult", value: "m_mult", label: "Mult" },
  { key: "m_lucky", value: "m_lucky", label: "Lucky" },
  { key: "m_stone", value: "m_stone", label: "Stone" },
  { key: "m_bonus", value: "m_bonus", label: "Bonus" },
] as const;

export const ENHANCEMENTS = () => DataRegistry.getEnhancements();
export const ENHANCEMENT_KEYS = () =>
  DataRegistry.getEnhancements().map((e) => e.key);
export const ENHANCEMENT_VALUES = () =>
  DataRegistry.getEnhancements().map((e) => e.value);
export const ENHANCEMENT_LABELS = () =>
  DataRegistry.getEnhancements().map((e) => e.label);

export const isCustomEnhancement = (
  value: string,
  customEnhancements: EnhancementData[] = registryState.enhancements,
  modPrefix: string = registryState.modPrefix
): boolean => {
  return (
    value.includes("_") &&
    customEnhancements.some(
      (e) => `m_${modPrefix}_${e.enhancementKey}` === value
    )
  );
};

export const getEnhancementByValue = (
  value: string
): { key: string; value: string; label: string } | undefined => {
  return ENHANCEMENTS().find((enhancement) => enhancement.value === value);
};

export const getEnhancementByKey = (
  key: string
): { key: string; value: string; label: string } | undefined => {
  return ENHANCEMENTS().find((enhancement) => enhancement.key === key);
};

// =============================================================================
// BOOSTERS SECTION
// =============================================================================

export const CUSTOM_BOOSTERS = () => DataRegistry.getBoosters();
export const CUSTOM_BOOSTER_VALUES = () =>
  DataRegistry.getBoosters().map((b) => b.value);
export const CUSTOM_BOOSTER_LABELS = () =>
  DataRegistry.getBoosters().map((b) => b.label);

export const getBoostersByType = (
  boosterType: BoosterType,
  customBoosters: BoosterData[] = registryState.boosters
): BoosterData[] => {
  return customBoosters.filter(
    (booster) => booster.booster_type === boosterType
  );
};

export const getBoosterDropdownOptions = (
  customBoosters: BoosterData[] = registryState.boosters
) => {
  return customBoosters.map((booster) => ({
    value: `${registryState.modPrefix}_${
      booster.boosterKey ||
      (booster.name
        ? booster.name.toLowerCase().replace(/\s+/g, "_")
        : "unnamed_booster")
    }`,
    label: booster.name || "Unnamed Booster",
  }));
};

export const getBoosterByKey = (
  key: string,
  customBoosters: BoosterData[] = registryState.boosters
): BoosterData | undefined => {
  const searchKey = key.startsWith(`${registryState.modPrefix}_`)
    ? key.substring(`${registryState.modPrefix}_`.length)
    : key;

  return customBoosters.find(
    (booster) =>
      booster.boosterKey === searchKey ||
      (booster.name &&
        booster.name.toLowerCase().replace(/\s+/g, "_") === searchKey)
  );
};

export const isCustomBooster = (
  key: string,
  customBoosters: BoosterData[] = registryState.boosters,
  modPrefix: string = registryState.modPrefix
): boolean => {
  return (
    key.includes("_") &&
    customBoosters.some(
      (b) =>
        `${modPrefix}_${
          b.boosterKey ||
          (b.name ? b.name.toLowerCase().replace(/\s+/g, "_") : "unnamed")
        }` === key
    )
  );
};

// =============================================================================
// RARITIES SECTION
// =============================================================================

export const RARITIES = () => DataRegistry.getRarities();
export const RARITY_VALUES = () =>
  DataRegistry.getRarities().map((r) => r.value);
export const RARITY_LABELS = () =>
  DataRegistry.getRarities().map((r) => r.label);

export const VANILLA_RARITIES = [
  { value: 1, label: "Common", key: "common" },
  { value: 2, label: "Uncommon", key: "uncommon" },
  { value: 3, label: "Rare", key: "rare" },
  { value: 4, label: "Legendary", key: "legendary" },
] as const;

type VanillaRarity = {
  value: number;
  label: string;
  key: string;
  isCustom: false;
};

type CustomRarityOption = {
  value: string;
  label: string;
  key: string;
  isCustom: true;
  customData: RarityData;
};

type RarityOption = VanillaRarity | CustomRarityOption;

export const getAllRarities = (
  customRarities: RarityData[] = registryState.customRarities
): RarityOption[] => {
  const vanillaRarities: VanillaRarity[] = VANILLA_RARITIES.map(
    (rarity, index) => ({
      value: index + 1,
      label: rarity.label,
      key: rarity.key,
      isCustom: false,
    })
  );

  const customRarityOptions: CustomRarityOption[] = customRarities.map(
    (rarity) => ({
      value: rarity.key,
      label: rarity.name,
      key: rarity.key,
      isCustom: true,
      customData: rarity,
    })
  );

  return [...vanillaRarities, ...customRarityOptions];
};
export const getRarityByValue = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities
): RarityOption | undefined => {
  const allRarities = getAllRarities(customRarities);
  return allRarities.find((rarity) => rarity.value === value);
};

export const getRarityByKey = (
  key: string,
  customRarities: RarityData[] = registryState.customRarities
): RarityOption | undefined => {
  const allRarities = getAllRarities(customRarities);
  return allRarities.find((rarity) => rarity.key === key);
};

export const getRarityDisplayName = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities
): string => {
  const rarity = getRarityByValue(value, customRarities);
  return rarity?.label || "Unknown";
};

export const getRarityBadgeColor = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities
): string => {
  const rarity = getRarityByValue(value, customRarities);

  if (rarity?.isCustom) {
    const color = rarity.customData.badge_colour;
    return color.startsWith("#") ? color : `#${color}`;
  }

  const colorMap: Record<number, string> = {
    1: "#009dff",
    2: "#4BC292",
    3: "#fe5f55",
    4: "#b26cbb",
  };

  return colorMap[value as number] || "#666665";
};

export const getRarityStyles = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities
) => {
  const color = getRarityBadgeColor(value, customRarities);

  return {
    text: `text-[${color}]`,
    bg: "bg-black",
    border: `border-[${color}]`,
    bgColor: color,
  };
};

export const isCustomRarity = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities,
  modPrefix: string = registryState.modPrefix
): boolean => {
  if (typeof value === "string") {
    return (
      value.includes("_") &&
      customRarities.some((r) => `${modPrefix}_${r.key}` === value)
    );
  }
  return false;
};

export const getCustomRarityData = (
  value: number | string,
  customRarities: RarityData[] = registryState.customRarities
): RarityData | null => {
  const rarity = getRarityByValue(value, customRarities);
  return rarity?.isCustom ? rarity.customData : null;
};

export const getRarityDropdownOptions = (
  customRarities: RarityData[] = registryState.customRarities
) => {
  return getAllRarities(customRarities).map((rarity) => ({
    value: rarity.value.toString(),
    label: rarity.label,
  }));
};

// =============================================================================
// CONSUMABLES SECTION
// =============================================================================

export const CONSUMABLE_SETS = () => DataRegistry.getConsumableSets();
export const CONSUMABLE_SET_VALUES = () =>
  DataRegistry.getConsumableSets().map((s) => s.value);
export const CONSUMABLE_SET_LABELS = () =>
  DataRegistry.getConsumableSets().map((s) => s.label);

export const CUSTOM_CONSUMABLES = () => DataRegistry.getConsumables();
export const CUSTOM_CONSUMABLE_VALUES = () =>
  DataRegistry.getConsumables().map((c) => c.value);
export const CUSTOM_CONSUMABLE_LABELS = () =>
  DataRegistry.getConsumables().map((c) => c.label);

type VanillaConsumableSet = {
  value: string;
  label: string;
  key: string;
  isCustom: false;
};

type CustomConsumableSetOption = {
  value: string;
  label: string;
  key: string;
  isCustom: true;
  customData: ConsumableSetData;
};

type ConsumableSetOption = VanillaConsumableSet | CustomConsumableSetOption;

export const getAllConsumableSets = (
  customSets: ConsumableSetData[] = registryState.consumableSets
): ConsumableSetOption[] => {
  const vanillaSets: VanillaConsumableSet[] = VANILLA_CONSUMABLE_SETS.map(
    (set) => ({
      value: set.value,
      label: set.label,
      key: set.key,
      isCustom: false,
    })
  );

  const customSetOptions: CustomConsumableSetOption[] = customSets.map(
    (set) => ({
      value: set.key,
      label: set.name,
      key: set.key,
      isCustom: true,
      customData: set,
    })
  );

  return [...vanillaSets, ...customSetOptions];
};

export const getConsumableSetByValue = (
  value: string,
  customSets: ConsumableSetData[] = registryState.consumableSets
): ConsumableSetOption | undefined => {
  const allSets = getAllConsumableSets(customSets);
  return allSets.find((set) => set.value === value);
};

export const getConsumableSetByKey = (
  key: string,
  customSets: ConsumableSetData[] = registryState.consumableSets
): ConsumableSetOption | undefined => {
  const allSets = getAllConsumableSets(customSets);
  return allSets.find((set) => set.key === key);
};

export const isCustomConsumableSet = (
  value: string,
  customSets: ConsumableSetData[] = registryState.consumableSets,
  modPrefix: string = registryState.modPrefix
): boolean => {
  return (
    value.includes("_") &&
    customSets.some((s) => `${modPrefix}_${s.key}` === value)
  );
};

export const getCustomConsumableSetData = (
  value: string,
  customSets: ConsumableSetData[] = registryState.consumableSets
): ConsumableSetData | null => {
  const set = getConsumableSetByValue(value, customSets);
  return set?.isCustom ? set.customData : null;
};

export const getConsumablesBySet = (
  setKey: string,
  customConsumables: ConsumableData[] = registryState.consumables
): ConsumableData[] => {
  return customConsumables.filter((consumable) => consumable.set === setKey);
};

export const getConsumableSetDropdownOptions = (
  customSets: ConsumableSetData[] = registryState.consumableSets
) => {
  return getAllConsumableSets(customSets).map((set) => ({
    value: set.value,
    label: set.label,
  }));
};

//* ==== Centralized Balatro game data and utilities ====

export const BOSS_BLINDS = [
  { value: "bl_hook", label: "The Hook" },
  { value: "bl_ox", label: "The Ox" },
  { value: "bl_house", label: "The House" },
  { value: "bl_wall", label: "The Wall" },
  { value: "bl_wheel", label: "The Wheel" },
  { value: "bl_arm", label: "The Arm" },
  { value: "bl_club", label: "The Club" },
  { value: "bl_fish", label: "The Fish" },
  { value: "bl_psychic", label: "The Psychic" },
  { value: "bl_goad", label: "The Goad" },
  { value: "bl_water", label: "The Water" },
  { value: "bl_window", label: "The Window" },
  { value: "bl_manacle", label: "The Manacle" },
  { value: "bl_eye", label: "The Eye" },
  { value: "bl_mouth", label: "The Mouth" },
  { value: "bl_plant", label: "The Plant" },
  { value: "bl_serpent", label: "The Serpent" },
  { value: "bl_pillar", label: "The Pillar" },
  { value: "bl_needle", label: "The Needle" },
  { value: "bl_head", label: "The Head" },
  { value: "bl_tooth", label: "The Tooth" },
  { value: "bl_flint", label: "The Flint" },
  { value: "bl_mark", label: "The Mark" },

  { value: "bl_final_acorn", label: "Amber Acorn (final)" },
  { value: "bl_final_leaf", label: "Verdant Leaf (final)" },
  { value: "bl_final_vessel", label: "Violet Vessel (final)" },
  { value: "bl_final_heart", label: "Crimson Heart (final)" },
  { value: "bl_final_bell", label: "Cerulean Bell (final)" },
];

// VANILLA JOKERS
export const JOKERS = [
  { key: "j_joker", label: "Joker" },
  { key: "j_greedy_joker", label: "Greedy Joker" },
  { key: "j_lusty_joker", label: "Lusty Joker" },
  { key: "j_wrathful_joker", label: "Wrathful Joker" },
  { key: "j_gluttenous_joker", label: "Gluttonous Joker" },
  { key: "j_jolly", label: "Jolly Joker" },
  { key: "j_zany", label: "Zany Joker" },
  { key: "j_mad", label: "Mad Joker" },
  { key: "j_crazy", label: "Crazy Joker" },
  { key: "j_droll", label: "Droll Joker" },
  { key: "j_sly", label: "Sly Joker" },
  { key: "j_wily", label: "Wily Joker" },
  { key: "j_clever", label: "Clever Joker" },
  { key: "j_devious", label: "Devious Joker" },
  { key: "j_crafty", label: "Crafty Joker" },
  { key: "j_half", label: "Half Joker" },
  { key: "j_stencil", label: "Joker Stencil" },
  { key: "j_four_fingers", label: "Four Fingers" },
  { key: "j_mime", label: "Mime" },
  { key: "j_credit_card", label: "Credit Card" },
  { key: "j_ceremonial", label: "Ceremonial Dagger" },
  { key: "j_banner", label: "Banner" },
  { key: "j_mystic_summit", label: "Mystic Summit" },
  { key: "j_marble", label: "Marble Joker" },
  { key: "j_loyalty_card", label: "Loyalty Card" },
  { key: "j_8_ball", label: "8 Ball" },
  { key: "j_misprint", label: "Misprint" },
  { key: "j_dusk", label: "Dusk" },
  { key: "j_raised_fist", label: "Raised Fist" },
  { key: "j_chaos", label: "Chaos the Clown" },
  { key: "j_fibonacci", label: "Fibonacci" },
  { key: "j_steel_joker", label: "Steel Joker" },
  { key: "j_scary_face", label: "Scary Face" },
  { key: "j_abstract", label: "Abstract Joker" },
  { key: "j_delayed_grat", label: "Delayed Gratification" },
  { key: "j_hack", label: "Hack" },
  { key: "j_pareidolia", label: "Pareidolia" },
  { key: "j_gros_michel", label: "Gros Michel" },
  { key: "j_even_steven", label: "Even Steven" },
  { key: "j_odd_todd", label: "Odd Todd" },
  { key: "j_scholar", label: "Scholar" },
  { key: "j_business", label: "Business Card" },
  { key: "j_supernova", label: "Supernova" },
  { key: "j_ride_the_bus", label: "Ride the Bus" },
  { key: "j_space", label: "Space Joker" },
  { key: "j_egg", label: "Egg" },
  { key: "j_burglar", label: "Burglar" },
  { key: "j_blackboard", label: "Blackboard" },
  { key: "j_runner", label: "Runner" },
  { key: "j_ice_cream", label: "Ice Cream" },
  { key: "j_dna", label: "DNA" },
  { key: "j_splash", label: "Splash" },
  { key: "j_blue_joker", label: "Blue Joker" },
  { key: "j_sixth_sense", label: "Sixth Sense" },
  { key: "j_constellation", label: "Constellation" },
  { key: "j_hiker", label: "Hiker" },
  { key: "j_faceless", label: "Faceless Joker" },
  { key: "j_green_joker", label: "Green Joker" },
  { key: "j_superposition", label: "Superposition" },
  { key: "j_todo_list", label: "To Do List" },
  { key: "j_cavendish", label: "Cavendish" },
  { key: "j_card_sharp", label: "Card Sharp" },
  { key: "j_red_card", label: "Red Card" },
  { key: "j_madness", label: "Madness" },
  { key: "j_square_joker", label: "Square Joker" },
  { key: "j_seance", label: "Sance" },
  { key: "j_riff_raff", label: "Riff-Raff" },
  { key: "j_vampire", label: "Vampire" },
  { key: "j_shortcut", label: "Shortcut" },
  { key: "j_hologram", label: "Hologram" },
  { key: "j_vagabond", label: "Vagabond" },
  { key: "j_baron", label: "Baron" },
  { key: "j_cloud_9", label: "Cloud 9" },
  { key: "j_rocket", label: "Rocket" },
  { key: "j_obelisk", label: "Obelisk" },
  { key: "j_midas_mask", label: "Midas Mask" },
  { key: "j_luchador", label: "Luchador" },
  { key: "j_photograph", label: "Photograph" },
  { key: "j_gift", label: "Gift Card" },
  { key: "j_turtle_bean", label: "Turtle Bean" },
  { key: "j_erosion", label: "Erosion" },
  { key: "j_reserved_parking", label: "Reserved Parking" },
  { key: "j_mail", label: "Mail-In Rebate" },
  { key: "j_to_the_moon", label: "To the Moon" },
  { key: "j_hallucination", label: "Hallucination" },
  { key: "j_fortune_teller", label: "Fortune Teller" },
  { key: "j_juggler", label: "Juggler" },
  { key: "j_drunkard", label: "Drunkard" },
  { key: "j_stone", label: "Stone Joker" },
  { key: "j_golden", label: "Golden Joker" },
  { key: "j_lucky_cat", label: "Lucky Cat" },
  { key: "j_baseball", label: "Baseball Card" },
  { key: "j_bull", label: "Bull" },
  { key: "j_diet_cola", label: "Diet Cola" },
  { key: "j_trading", label: "Trading Card" },
  { key: "j_flash", label: "Flash Card" },
  { key: "j_popcorn", label: "Popcorn" },
  { key: "j_trousers", label: "Spare Trousers" },
  { key: "j_ancient", label: "Ancient Joker" },
  { key: "j_ramen", label: "Ramen" },
  { key: "j_walkie_talkie", label: "Walkie Talkie" },
  { key: "j_selzer", label: "Seltzer" },
  { key: "j_castle", label: "Castle" },
  { key: "j_smiley", label: "Smiley Face" },
  { key: "j_campfire", label: "Campfire" },
  { key: "j_golden_ticket", label: "Golden Ticket" },
  { key: "j_mr_bones", label: "Mr. Bones" },
  { key: "j_acrobat", label: "Acrobat" },
  { key: "j_sock_and_buskin", label: "Sock and Buskin" },
  { key: "j_swashbuckler", label: "Swashbuckler" },
  { key: "j_troubadour", label: "Troubadour" },
  { key: "j_certificate", label: "Certificate" },
  { key: "j_smeared", label: "Smeared Joker" },
  { key: "j_throwback", label: "Throwback" },
  { key: "j_hanging_chad", label: "Hanging Chad" },
  { key: "j_rough_gem", label: "Rough Gem" },
  { key: "j_bloodstone", label: "Bloodstone" },
  { key: "j_arrowhead", label: "Arrowhead" },
  { key: "j_onyx_agate", label: "Onyx Agate" },
  { key: "j_glass", label: "Glass Joker" },
  { key: "j_ring_master", label: "Showman" },
  { key: "j_flower_pot", label: "Flower Pot" },
  { key: "j_blueprint", label: "Blueprint" },
  { key: "j_wee", label: "Wee Joker" },
  { key: "j_merry_andy", label: "Merry Andy" },
  { key: "j_oops", label: "Oops! All 6s" },
  { key: "j_idol", label: "The Idol" },
  { key: "j_seeing_double", label: "Seeing Double" },
  { key: "j_matador", label: "Matador" },
  { key: "j_hit_the_road", label: "Hit the Road" },
  { key: "j_duo", label: "The Duo" },
  { key: "j_trio", label: "The Trio" },
  { key: "j_family", label: "The Family" },
  { key: "j_order", label: "The Order" },
  { key: "j_tribe", label: "The Tribe" },
  { key: "j_stuntman", label: "Stuntman" },
  { key: "j_invisible", label: "Invisible Joker" },
  { key: "j_brainstorm", label: "Brainstorm" },
  { key: "j_satellite", label: "Satellite" },
  { key: "j_shoot_the_moon", label: "Shoot the Moon" },
  { key: "j_drivers_license", label: "Driver's License" },
  { key: "j_cartomancer", label: "Cartomancer" },
  { key: "j_astronomer", label: "Astronomer" },
  { key: "j_burnt", label: "Burnt Joker" },
  { key: "j_bootstraps", label: "Bootstraps" },
  { key: "j_caino", label: "Canio" },
  { key: "j_triboulet", label: "Triboulet" },
  { key: "j_yorick", label: "Yorick" },
  { key: "j_chicot", label: "Chicot" },
  { key: "j_perkeo", label: "Perkeo" },
] as const;

export const JOKER_KEYS = JOKERS.map((joker) => joker.key);
export const JOKER_LABELS = JOKERS.map((joker) => joker.label);

// Ranks
export const RANKS = [
  { value: "2", label: "2", id: 2 },
  { value: "3", label: "3", id: 3 },
  { value: "4", label: "4", id: 4 },
  { value: "5", label: "5", id: 5 },
  { value: "6", label: "6", id: 6 },
  { value: "7", label: "7", id: 7 },
  { value: "8", label: "8", id: 8 },
  { value: "9", label: "9", id: 9 },
  { value: "10", label: "10", id: 10 },
  { value: "J", label: "Jack", id: 11 },
  { value: "Q", label: "Queen", id: 12 },
  { value: "K", label: "King", id: 13 },
  { value: "A", label: "Ace", id: 14 },
] as const;

export const RANK_VALUES = RANKS.map((rank) => rank.value);
export const RANK_LABELS = RANKS.map((rank) => rank.label);

export const RANK_GROUPS = [
  { value: "face", label: "Face Card (J,Q,K)" },
  { value: "even", label: "Even Card (2,4,6,8,10)" },
  { value: "odd", label: "Odd Card (A,3,5,7,9)" },
] as const;

export const RANK_GROUP_VALUES = RANK_GROUPS.map((group) => group.value);

// Suits
export const SUITS = [
  { value: "Spades", label: "Spades" },
  { value: "Hearts", label: "Hearts" },
  { value: "Diamonds", label: "Diamonds" },
  { value: "Clubs", label: "Clubs" },
] as const;

export const SUIT_VALUES = SUITS.map((suit) => suit.value);
export const SUIT_LABELS = SUITS.map((suit) => suit.label);

export const SUIT_GROUPS = [
  { value: "red", label: "Red Suit (Hearts, Diamonds)" },
  { value: "black", label: "Black Suit (Spades, Clubs)" },
] as const;

export const SUIT_GROUP_VALUES = SUIT_GROUPS.map((group) => group.value);

// Poker Hands
export const POKER_HANDS = [
  { value: "High Card", label: "High Card" },
  { value: "Pair", label: "Pair" },
  { value: "Two Pair", label: "Two Pair" },
  { value: "Three of a Kind", label: "Three of a Kind" },
  { value: "Straight", label: "Straight" },
  { value: "Flush", label: "Flush" },
  { value: "Full House", label: "Full House" },
  { value: "Four of a Kind", label: "Four of a Kind" },
  { value: "Five of a Kind", label: "Five of a Kind" },
  { value: "Straight Flush", label: "Straight Flush" },
  { value: "Flush House", label: "Flush House" },
  { value: "Flush Five", label: "Flush Five" },
] as const;

export const POKER_HAND_VALUES = POKER_HANDS.map((hand) => hand.value);
export const POKER_HAND_LABELS = POKER_HANDS.map((hand) => hand.label);

// Editions
export const VANILLA_EDITIONS = [
  { key: "e_foil", value: "e_foil", label: "Foil (+50 Chips)" },
  { key: "e_holo", value: "e_holo", label: "Holographic (+10 Mult)" },
  {
    key: "e_polychrome",
    value: "e_polychrome",
    label: "Polychrome (X1.5 Mult)",
  },
  { key: "e_negative", value: "e_negative", label: "Negative (+1 Joker slot)" },
] as const;

export const STICKERS = [
  { key: "eternal", value: "eternal", label: "Eternal" },
  { key: "rental", value: "rental", label: "Rental" },
  { key: "perishable", value: "perishable", label: "Perishable" },
] as const;

export const STICKER_KEYS = STICKERS.map((sticker) => sticker.key);
export const STICKER_VALUES = STICKERS.map((sticker) => sticker.value);
export const STICKER_LABELS = STICKERS.map((sticker) => sticker.label);

// Tarot Cards
export const TAROT_CARDS = [
  { key: "c_fool", value: "c_fool", label: "The Fool" },
  { key: "c_magician", value: "c_magician", label: "The Magician" },
  {
    key: "c_high_priestess",
    value: "c_high_priestess",
    label: "The High Priestess",
  },
  { key: "c_empress", value: "c_empress", label: "The Empress" },
  { key: "c_emperor", value: "c_emperor", label: "The Emperor" },
  { key: "c_heirophant", value: "c_heirophant", label: "The Hierophant" },
  { key: "c_lovers", value: "c_lovers", label: "The Lovers" },
  { key: "c_chariot", value: "c_chariot", label: "The Chariot" },
  { key: "c_justice", value: "c_justice", label: "Justice" },
  { key: "c_hermit", value: "c_hermit", label: "The Hermit" },
  {
    key: "c_wheel_of_fortune",
    value: "c_wheel_of_fortune",
    label: "Wheel of Fortune",
  },
  { key: "c_strength", value: "c_strength", label: "Strength" },
  { key: "c_hanged_man", value: "c_hanged_man", label: "The Hanged Man" },
  { key: "c_death", value: "c_death", label: "Death" },
  { key: "c_temperance", value: "c_temperance", label: "Temperance" },
  { key: "c_devil", value: "c_devil", label: "The Devil" },
  { key: "c_tower", value: "c_tower", label: "The Tower" },
  { key: "c_star", value: "c_star", label: "The Star" },
  { key: "c_moon", value: "c_moon", label: "The Moon" },
  { key: "c_sun", value: "c_sun", label: "The Sun" },
  { key: "c_judgement", value: "c_judgement", label: "Judgement" },
  { key: "c_world", value: "c_world", label: "The World" },
] as const;

export const TAROT_CARD_KEYS = TAROT_CARDS.map((card) => card.key);
export const TAROT_CARD_VALUES = TAROT_CARDS.map((card) => card.value);
export const TAROT_CARD_LABELS = TAROT_CARDS.map((card) => card.label);

// Planet Cards
export const PLANET_CARDS = [
  { key: "c_pluto", value: "c_pluto", label: "Pluto" },
  { key: "c_mercury", value: "c_mercury", label: "Mercury" },
  { key: "c_uranus", value: "c_uranus", label: "Uranus" },
  { key: "c_venus", value: "c_venus", label: "Venus" },
  { key: "c_saturn", value: "c_saturn", label: "Saturn" },
  { key: "c_jupiter", value: "c_jupiter", label: "Jupiter" },
  { key: "c_earth", value: "c_earth", label: "Earth" },
  { key: "c_mars", value: "c_mars", label: "Mars" },
  { key: "c_neptune", value: "c_neptune", label: "Neptune" },
  { key: "c_planet_x", value: "c_planet_x", label: "Planet X" },
  { key: "c_ceres", value: "c_ceres", label: "Ceres" },
  { key: "c_eris", value: "c_eris", label: "Eris" },
] as const;

export const PLANET_CARD_KEYS = PLANET_CARDS.map((card) => card.key);
export const PLANET_CARD_VALUES = PLANET_CARDS.map((card) => card.value);
export const PLANET_CARD_LABELS = PLANET_CARDS.map((card) => card.label);

// Spectral Cards
export const SPECTRAL_CARDS = [
  { key: "c_familiar", value: "c_familiar", label: "Familiar" },
  { key: "c_grim", value: "c_grim", label: "Grim" },
  { key: "c_incantation", value: "c_incantation", label: "Incantation" },
  { key: "c_talisman", value: "c_talisman", label: "Talisman" },
  { key: "c_aura", value: "c_aura", label: "Aura" },
  { key: "c_wraith", value: "c_wraith", label: "Wraith" },
  { key: "c_sigil", value: "c_sigil", label: "Sigil" },
  { key: "c_ouija", value: "c_ouija", label: "Ouija" },
  { key: "c_ectoplasm", value: "c_ectoplasm", label: "Ectoplasm" },
  { key: "c_immolate", value: "c_immolate", label: "Immolate" },
  { key: "c_ankh", value: "c_ankh", label: "Ankh" },
  { key: "c_deja_vu", value: "c_deja_vu", label: "Deja Vu" },
  { key: "c_hex", value: "c_hex", label: "Hex" },
  { key: "c_trance", value: "c_trance", label: "Trance" },
  { key: "c_medium", value: "c_medium", label: "Medium" },
  { key: "c_cryptid", value: "c_cryptid", label: "Cryptid" },
  { key: "c_soul", value: "c_soul", label: "The Soul" },
  { key: "c_black_hole", value: "c_black_hole", label: "Black Hole" },
] as const;

export const SPECTRAL_CARD_KEYS = SPECTRAL_CARDS.map((card) => card.key);
export const SPECTRAL_CARD_VALUES = SPECTRAL_CARDS.map((card) => card.value);
export const SPECTRAL_CARD_LABELS = SPECTRAL_CARDS.map((card) => card.label);

// All Consumables Combined
export const ALL_CONSUMABLES = [
  ...TAROT_CARDS,
  ...PLANET_CARDS,
  ...SPECTRAL_CARDS,
] as const;

export const ALL_CONSUMABLE_KEYS = ALL_CONSUMABLES.map((card) => card.key);
export const ALL_CONSUMABLE_VALUES = ALL_CONSUMABLES.map((card) => card.value);
export const ALL_CONSUMABLE_LABELS = ALL_CONSUMABLES.map((card) => card.label);

// Blind Types
export const BLIND_TYPES = [
  { value: "small", label: "Small Blind" },
  { value: "big", label: "Big Blind" },
  { value: "boss", label: "Boss Blind" },
] as const;

export const BLIND_TYPE_VALUES = BLIND_TYPES.map((blind) => blind.value);
export const BLIND_TYPE_LABELS = BLIND_TYPES.map((blind) => blind.label);

// Tags
export const TAGS = [
  {
    value: "uncommon",
    label: "Uncommon Tag - Next shop has free Uncommon Joker",
  },
  { value: "rare", label: "Rare Tag - Next shop has free Rare Joker" },
  {
    value: "negative",
    label: "Negative Tag - Next base Joker becomes Negative (+1 slot) and free",
  },
  {
    value: "foil",
    label: "Foil Tag - Next base Joker becomes Foil (+50 Chips) and free",
  },
  {
    value: "holo",
    label: "Holographic Tag - Next base Joker becomes Holo (+10 Mult) and free",
  },
  {
    value: "polychrome",
    label:
      "Polychrome Tag - Next base Joker becomes Polychrome (X1.5 Mult) and free",
  },
  {
    value: "investment",
    label: "Investment Tag - Gain $25 after defeating next Boss Blind",
  },
  {
    value: "voucher",
    label: "Voucher Tag - Adds a Voucher to next shop",
  },
  { value: "boss", label: "Boss Tag - Re-rolls the next Boss Blind" },
  {
    value: "standard",
    label: "Standard Tag - Immediately open free Mega Standard Pack",
  },
  {
    value: "charm",
    label: "Charm Tag - Immediately open free Mega Arcana Pack",
  },
  {
    value: "meteor",
    label: "Meteor Tag - Immediately open free Mega Celestial Pack",
  },
  {
    value: "buffoon",
    label: "Buffoon Tag - Immediately open free Mega Buffoon Pack",
  },
  {
    value: "handy",
    label: "Handy Tag - Gain $1 for each hand played this run",
  },
  {
    value: "garbage",
    label: "Garbage Tag - Gain $1 for each unused discard this run",
  },
  {
    value: "ethereal",
    label: "Ethereal Tag - Immediately open free Spectral Pack",
  },
  {
    value: "coupon",
    label: "Coupon Tag - Next shop items are free ($0)",
  },
  {
    value: "double",
    label: "Double Tag - Gives copy of next Tag selected",
  },
  {
    value: "juggle",
    label: "Juggle Tag - +3 Hand Size for next round only",
  },
  { value: "d_six", label: "D6 Tag - Next shop rerolls start at $0" },
  {
    value: "top_up",
    label: "Top-up Tag - Create up to 2 Common Jokers",
  },
  {
    value: "speed",
    label: "Speed Tag - Gives $5 for each Blind skipped this run",
  },
  {
    value: "orbital",
    label: "Orbital Tag - Upgrades random Poker Hand by 3 levels",
  },
  {
    value: "economy",
    label: "Economy Tag - Doubles your money (max +$40)",
  },
] as const;

export const TAG_TYPES: Record<string, string> = {
  uncommon: "tag_uncommon",
  rare: "tag_rare",
  negative: "tag_negative",
  foil: "tag_foil",
  holo: "tag_holo",
  polychrome: "tag_polychrome",
  investment: "tag_investment",
  voucher: "tag_voucher",
  boss: "tag_boss",
  standard: "tag_standard",
  charm: "tag_charm",
  meteor: "tag_meteor",
  buffoon: "tag_buffoon",
  handy: "tag_handy",
  garbage: "tag_garbage",
  ethereal: "tag_ethereal",
  coupon: "tag_coupon",
  double: "tag_double",
  juggle: "tag_juggle",
  d_six: "tag_d_six",
  top_up: "tag_top_up",
  speed: "tag_speed",
  orbital: "tag_orbital",
  economy: "tag_economy",
} as const;

// Consumable Types
export const CONSUMABLE_TYPES = [
  { value: "any", label: "Any Consumable" },
  { value: "tarot", label: "Tarot Card" },
  { value: "planet", label: "Planet Card" },
  { value: "spectral", label: "Spectral Card" },
] as const;

export const CONSUMABLE_TYPE_VALUES = CONSUMABLE_TYPES.map(
  (type) => type.value
);
export const CONSUMABLE_TYPE_LABELS = CONSUMABLE_TYPES.map(
  (type) => type.label
);

// Comparison Operators
export const COMPARISON_OPERATORS = [
  { value: "equals", label: "equals" },
  { value: "not_equals", label: "not equals" },
  { value: "greater_than", label: "greater than" },
  { value: "less_than", label: "less than" },
  { value: "greater_equals", label: "greater than or equal to" },
  { value: "less_equals", label: "less than or equal to" },
] as const;

export const COMPARISON_OPERATOR_VALUES = COMPARISON_OPERATORS.map(
  (op) => op.value
);
export const COMPARISON_OPERATOR_LABELS = COMPARISON_OPERATORS.map(
  (op) => op.label
);

// Card Scope
export const CARD_SCOPES = [
  { value: "scoring", label: "Scoring cards only" },
  { value: "all_played", label: "All played cards" },
] as const;

export const CARD_SCOPE_VALUES = CARD_SCOPES.map((scope) => scope.value);
export const CARD_SCOPE_LABELS = CARD_SCOPES.map((scope) => scope.label);

// Utilities

// Convert a rank string to its numeric ID
export const getRankId = (rank: string): number => {
  const rankData = RANKS.find((r) => r.value === rank || r.label === rank);
  return rankData?.id ?? (rank === "Ace" ? 14 : parseInt(rank) || 14);
};

// Get rank data by value
export const getRankByValue = (value: string) => {
  return RANKS.find((rank) => rank.value === value);
};

// Get rank data by ID
export const getRankById = (id: number) => {
  return RANKS.find((rank) => rank.id === id);
};

// Get suit data by value
export const getSuitByValue = (value: string) => {
  return SUITS.find((suit) => suit.value === value);
};

// Get tarot card data by key
export const getTarotCardByKey = (key: string) => {
  return TAROT_CARDS.find((card) => card.key === key);
};

// Get planet card data by key
export const getPlanetCardByKey = (key: string) => {
  return PLANET_CARDS.find((card) => card.key === key);
};

// Get spectral card data by key
export const getSpectralCardByKey = (key: string) => {
  return SPECTRAL_CARDS.find((card) => card.key === key);
};

// Get any consumable card data by key
export const getConsumableByKey = (key: string) => {
  return ALL_CONSUMABLES.find((card) => card.key === key);
};

// Check if a rank is a face card
export const isFaceCard = (rank: string): boolean => {
  return ["J", "Q", "K", "Jack", "Queen", "King"].includes(rank);
};

// Check if a rank is even
export const isEvenCard = (rank: string): boolean => {
  return ["2", "4", "6", "8", "10"].includes(rank);
};

// Check if a rank is odd
export const isOddCard = (rank: string): boolean => {
  return ["A", "3", "5", "7", "9", "Ace"].includes(rank);
};

// Check if a suit is red
export const isRedSuit = (suit: string): boolean => {
  return ["Hearts", "Diamonds"].includes(suit);
};

// Check if a suit is black
export const isBlackSuit = (suit: string): boolean => {
  return ["Spades", "Clubs"].includes(suit);
};

// Check if a card key is a tarot card
export const isTarotCard = (key: string): boolean => {
  return (TAROT_CARD_KEYS as readonly string[]).includes(key);
};

// Check if a card key is a planet card
export const isPlanetCard = (key: string): boolean => {
  return (PLANET_CARD_KEYS as readonly string[]).includes(key);
};

// Check if a card key is a spectral card
export const isSpectralCard = (key: string): boolean => {
  return (SPECTRAL_CARD_KEYS as readonly string[]).includes(key);
};

// Check if a card key is any consumable
export const isConsumableCard = (key: string): boolean => {
  return (ALL_CONSUMABLE_KEYS as readonly string[]).includes(key);
};

```

### src\components\data\Card\Conditions.ts

```
import { ConditionTypeDefinition } from "../../ruleBuilder/types";
import {
  UserIcon,
  InformationCircleIcon,
  IdentificationIcon,
  ArchiveBoxIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "../Jokers/Triggers";
import {
  RANKS,
  RANK_GROUPS,
  SUITS,
  SUIT_GROUPS,
  COMPARISON_OPERATORS,
  POKER_HANDS,
  EDITIONS,
  SEALS,
  RARITIES,
  VOUCHERS,
  CARD_SCOPES,
} from "../../data/BalatroUtils";
import { GENERIC_TRIGGERS } from "./Triggers";

export const CARD_GENERIC_TRIGGERS: string[] = ["card_scored", "card_held"];

export const CARD_CONDITION_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Player State",
    icon: UserIcon,
  },
  {
    label: "Game Context",
    icon: InformationCircleIcon,
  },
  {
    label: "Card",
    icon: IdentificationIcon,
  },
  {
    label: "Deck & Jokers",
    icon: ArchiveBoxIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const CARD_CONDITION_TYPES: ConditionTypeDefinition[] = [
  {
    id: "player_money",
    label: "Player Money",
    description: "Check the player's current money",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
        default: "greater_equals",
      },
      {
        id: "value",
        type: "number",
        label: "Dollar Amount",
        default: 5,
        min: 0,
      },
    ],
    category: "Player State",
  },
  {
    id: "card_rank",
    label: "Card Rank",
    description: "Check the rank of the card",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "rank_type",
        type: "select",
        label: "Rank Type",
        options: [
          { value: "specific", label: "Specific Rank" },
          { value: "group", label: "Rank Group" },
        ],
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "rank_type",
          values: ["specific"],
        },
      },
      {
        id: "rank_group",
        type: "select",
        label: "Rank Group",
        options: [...RANK_GROUPS],
        showWhen: {
          parameter: "rank_type",
          values: ["group"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "card_suit",
    label: "Card Suit",
    description: "Check the suit of the card",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "suit_type",
        type: "select",
        label: "Suit Type",
        options: [
          { value: "specific", label: "Specific Suit" },
          { value: "group", label: "Suit Group" },
        ],
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "suit_type",
          values: ["specific"],
        },
      },
      {
        id: "suit_group",
        type: "select",
        label: "Suit Group",
        options: [...SUIT_GROUPS],
        showWhen: {
          parameter: "suit_type",
          values: ["group"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "card_edition",
    label: "Card Edition",
    description: "Check if the card has a specific edition",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "any", label: "Any Edition" },
          { value: "none", label: "No Edition" },
          ...EDITIONS(),
        ],
      },
    ],
    category: "Card",
  },
  {
    id: "card_seal",
    label: "Card Seal",
    description: "Check if the card has a specific seal",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [{ value: "any", label: "Any Seal" }, ...SEALS()],
      },
    ],
    category: "Card",
  },
  {
    id: "card_index",
    label: "Card Index",
    description:
      "Check if the card is at a specific position in the scoring hand",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "index_type",
        type: "select",
        label: "Position Type",
        options: [
          { value: "number", label: "Specific Number" },
          { value: "first", label: "First Card" },
          { value: "last", label: "Last Card" },
        ],
        default: "first",
      },
      {
        id: "index_number",
        type: "number",
        label: "Position Number",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "index_type",
          values: ["number"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "blind_type",
    label: "Blind Type",
    description: "Check the type of the current blind",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "blind_type",
        type: "select",
        label: "Blind Type",
        options: [
          { value: "small", label: "Small Blind" },
          { value: "big", label: "Big Blind" },
          { value: "boss", label: "Boss Blind" },
        ],
      },
    ],
    category: "Game Context",
  },
  {
    id: "ante_level",
    label: "Ante Level",
    description: "Check the current ante level",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Ante Level",
        min: 1,
        default: 1,
      },
    ],
    category: "Game Context",
  },
  {
    id: "hand_size",
    label: "Hand Size",
    description: "Check the current hand size",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Hand Size",
        default: 8,
      },
    ],
    category: "Player State",
  },
  {
    id: "remaining_hands",
    label: "Remaining Hands",
    description: "Check how many hands the player has left",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Hands",
        min: 0,
        default: 1,
      },
    ],
    category: "Player State",
  },
  {
    id: "remaining_discards",
    label: "Remaining Discards",
    description: "Check how many discards the player has left",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Discards",
        min: 0,
        default: 1,
      },
    ],
    category: "Player State",
  },
  {
    id: "first_played_hand",
    label: "First Played Hand",
    description: "Check if this is the first hand played in the current round",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [],
    category: "Game Context",
  },
  {
    id: "poker_hand",
    label: "Poker Hand Type",
    description: "Check the type of poker hand being played",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "contains", label: "contains" },
          { value: "equals", label: "equals" },
        ],
        default: "contains",
      },
      {
        id: "value",
        type: "select",
        label: "Hand Type",
        options: [
          ...POKER_HANDS,
          { value: "most_played_hand", label: "Most Played Hand" },
          { value: "least_played_hand", label: "Least Played Hand" },
        ],
      },
    ],
    category: "Game Context",
  },
  {
    id: "hand_level",
    label: "Hand Level",
    description: "Check the level of a poker hand",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "hand_selection",
        type: "select",
        label: "Hand Selection",
        options: [
          { value: "played", label: "Played Hand" },
          { value: "specific", label: "Specific Hand" },
          { value: "any", label: "Any Hand" },
        ],
        default: "any",
      },
      {
        id: "specific_hand",
        type: "select",
        label: "Specific Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "hand_selection",
          values: ["specific"],
        },
      },
      {
        id: "value",
        type: "number",
        label: "Hand Level",
        min: 0,
        default: 1,
      },
    ],
    category: "Game Context",
  },
  {
    id: "blind_requirements",
    label: "Blind Requirements",
    description: "Check what percentage of the blind requirement is met",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
        default: "greater_equals",
      },
      {
        id: "percentage",
        type: "number",
        label: "Percentage (%)",
        default: 25,
      },
    ],
    category: "Game Context",
  },
  {
    id: "joker_count",
    label: "Joker Count",
    description: "Check how many jokers the player has",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [{ value: "any", label: "Any Rarity" }, ...RARITIES()],
        default: "any",
      },
      {
        id: "value",
        type: "number",
        label: "Number of Jokers",
        min: 0,
        default: 1,
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "specific_joker",
    label: "Specific Joker",
    description: "Check if a specific joker is in your collection",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operator",
        type: "select",
        label: "Condition",
        options: [
          { value: "has", label: "Has this joker" },
          { value: "does_not_have", label: "Does not have this joker" },
        ],
        default: "has",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., j_joker, j_greedy_joker, or just joker)",
        default: "j_joker",
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "deck_size",
    label: "Deck Size",
    description: "Check the size of the deck",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "size_type",
        type: "select",
        label: "Size Type",
        options: [
          { value: "remaining", label: "Remaining in Deck" },
          { value: "total", label: "Total Deck Size" },
        ],
        default: "remaining",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Cards",
        default: 52,
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "voucher_redeemed",
    label: "Voucher Redeemed",
    description: "Check if a specific Voucher was redeemed during the run",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "voucher",
        type: "select",
        label: "Voucher",
        options: [...VOUCHERS()],
        default: "v_overstock_norm",
      },
    ],
    category: "Game Context",
  },
  {
    id: "triggered_boss_blind",
    label: "Boss Blind Triggered",
    description: "Check if the current boss blind's effect has been triggered",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [],
    category: "Game Context",
  },
  {
    id: "system_condition",
    label: "Player OS",
    description: "Check on what Operating System the player is on",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "system",
        type: "select",
        label: "OS",
        options: [
          {value: "Windows",label: "Windows"},
          {value: "OS X",label: "OS X"},
          {value: "Linux",label: "Linux"},
          {value: "Android",label: "Android"},
          {value: "iOS",label: "iOS"},
        ],
        default: "Windows",
      },
    ],
    category: "Game Context",
  },
  {
    id: "generic_compare",
    label: "Generic Compare",
    description: "Compare two custom values with an operator",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "value1",
        type: "number",
        label: "First Value",
        default: 0,
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value2",
        type: "number",
        label: "Second Value",
        default: 0,
      },
    ],
    category: "Special",
  },
  {
    id: "internal_variable",
    label: "Internal Variable",
    description: "Check the value of an internal variable for this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "text",
        label: "Variable Name",
        default: "var1",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Value",
        default: 0,
      },
    ],
    category: "Special",
  },
  {
    id: "check_flag",
    label: "Check Flag",
    description: "Check if a specific flag from your mod is true",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Flag Name",
        default: "custom_flag",
      },
    ],
    category: "Special",
  },
];

export function getCardConditionsForTrigger(
  triggerId: string
): ConditionTypeDefinition[] {
  return CARD_CONDITION_TYPES.filter((condition) =>
    condition.applicableTriggers?.includes(triggerId)
  );
}

export function getCardConditionTypeById(
  id: string
): ConditionTypeDefinition | undefined {
  return CARD_CONDITION_TYPES.find((condition) => condition.id === id);
}

```

### src\components\data\Card\Effects.ts

```
import { EffectTypeDefinition } from "../../ruleBuilder/types";
import {
  SparklesIcon,
  BanknotesIcon,
  ChartBarIcon,
  UserGroupIcon,
  CakeIcon,
  VariableIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "../Jokers/Triggers";
import {
  RARITIES,
  STICKERS,
  POKER_HANDS,
  CONSUMABLE_SETS,
  TAROT_CARDS,
  CUSTOM_CONSUMABLES,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  EDITIONS,
  RANKS,
  SEALS,
  ENHANCEMENTS,
  SUITS,
} from "../BalatroUtils";
import { GENERIC_TRIGGERS, SCORING_TRIGGERS } from "./Triggers";

export const CARD_EFFECT_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Scoring",
    icon: ChartBarIcon,
  },
  {
    label: "Economy",
    icon: BanknotesIcon,
  },
  {
    label: "Consumables",
    icon: CakeIcon,
  },
  {
    label: "Jokers",
    icon: UserGroupIcon,
  },
  {
    label: "Variables",
    icon: VariableIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const CARD_EFFECT_TYPES: EffectTypeDefinition[] = [
  {
    id: "add_mult",
    label: "Add Mult",
    description: "Add mult to the current scoring calculation",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 4,
        min: 1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_chips",
    label: "Add Chips",
    description: "Add chips to the current scoring calculation",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 30,
        min: 1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_x_mult",
    label: "Apply XMult",
    description: "Multiply mult by the specified amount",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Multiplier",
        default: 1.5,
        min: 1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_x_chips",
    label: "Apply XChips",
    description: "Multiply chips by the specified amount",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Multiplier",
        default: 2,
        min: 1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_exp_mult",
    label: "Apply ^Mult (Exponential)",
    description: "Apply exponential mult (emult) - REQUIRES TALISMAN MOD",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Exponential Mult Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_exp_chips",
    label: "Apply ^Chips (Exponential)",
    description: "Apply exponential chips (echips) - REQUIRES TALISMAN MOD",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Exponential Chips Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_hyper_mult",
    label: "Apply HyperMult",
    description: "Apply (n)^ mult - REQUIRES TALISMAN MOD",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "arrows",
        type: "number",
        label: "Number of Arrows",
        default: 1,
        min: 1
      },
      {
        id: "value",
        type: "number",
        label: "Hyper Mult Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_hyper_chips",
    label: "Apply HyperChips",
    description: "Apply (n)^ chips - REQUIRES TALISMAN MOD",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "arrows",
        type: "number",
        label: "Number of Arrows",
        default: 1,
        min: 1
      },
      {
        id: "value",
        type: "number",
        label: "Hyper Chips Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "edit_dollars",
    label: "Edit Dollars",
    description: "Modify the player's money",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set To" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Dollar Amount",
        default: 1,
        min: 1,
      },
    ],
    category: "Economy",
  },{
    id: "modify_internal_variable",
    label: "Modify Internal Variable",
    description: "Change an internal variable value for this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "text",
        label: "Variable Name",
        default: "var1",
      },
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "set", label: "Set to value" },
          { value: "increment", label: "Increment by value" },
          { value: "decrement", label: "Decrement by value" },
          { value: "multiply", label: "Multiply by value" },
          { value: "divide", label: "Divide by value" },
        ],
      },
      {
        id: "value",
        type: "number",
        label: "Value",
        default: 1,
      },
    ],
    category: "Variables",
  },{
      id: "change_suit_variable",
      label: "Change Suit Variable",
      description:
        "Change the value of a suit variable to a specific suit or random suit",
      applicableTriggers: [...GENERIC_TRIGGERS],
      params: [
        {
          id: "variable_name",
          type: "select",
          label: "Suit Variable",
          options: [], // Will be populated dynamically with suit variables
        },
        {
          id: "change_type",
          type: "select",
          label: "Change Type",
          options: [
            { value: "random", label: "Random Suit" },
            { value: "specific", label: "Specific Suit" },
          ],
          default: "random",
        },
        {
          id: "specific_suit",
          type: "select",
          label: "Suit",
          options: [...SUITS],
          showWhen: {
            parameter: "change_type",
            values: ["specific"],
          },
        },
      ],
      category: "Variables",
    },{
    id: "change_rank_variable",
    label: "Change Rank Variable",
    description:
      "Change the value of a rank variable to a specific rank or random rank",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "select",
        label: "Rank Variable",
        options: [], // Will be populated dynamically with rank variables
      },
      {
        id: "change_type",
        type: "select",
        label: "Change Type",
        options: [
          { value: "random", label: "Random Rank" },
          { value: "specific", label: "Specific Rank" },
        ],
        default: "random",
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "change_type",
          values: ["specific"],
        },
      },
    ],
    category: "Variables",
  },
  {
    id: "change_pokerhand_variable",
    label: "Change Poker Hand Variable",
    description:
      "Change the value of a poker hand variable to a specific poker hand or random poker hand",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "select",
        label: "Poker Hand Variable",
        options: [],
      },
      {
        id: "change_type",
        type: "select",
        label: "Change Type",
        options: [
          { value: "random", label: "Random Poker Hand" },
          { value: "specific", label: "Specific Poker Hand" },
          { value: "most_played", label: "Most Played Hand" },
          { value: "least_played", label: "Least Played Hand" },
        ],
        default: "random",
      },
      {
        id: "specific_pokerhand",
        type: "select",
        label: "Poker Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "change_type",
          values: ["specific"],
        },
      },
    ],
    category: "Variables",
  },{
    id: "destroy_card",
    label: "Destroy Card",
    description: "Destroy this card",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "setGlassTrigger",
        type: "select",
        label: "Should Jokers like Glass Joker Trigger?",
        options: [
          { value: "true", label: "Yes" },
          { value: "false", label: "No" },
        ],
        default: "false",
      },
    ],
    category: "Special",
  },
  {
    id: "retrigger_card",
    label: "Retrigger Card",
    description: "Trigger this card's effect additional times",
    applicableTriggers: SCORING_TRIGGERS,
    params: [
      {
        id: "value",
        type: "number",
        label: "Number of Retriggers",
        default: 1,
        min: 1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "create_joker",
    label: "Create Joker",
    description:
      "Create a random or specific joker card. For creating jokers from your own mod, it is [modprefix]_[joker_name]. You can find your mod prefix in the mod metadata page.",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "joker_type",
        type: "select",
        label: "Joker Type",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
        ],
        default: "random",
      },
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [
          { value: "random", label: "Any Rarity" },
          ...RARITIES(),
        ],
        default: "random",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key ( [modprefix]_joker )",
        default: "joker",
        showWhen: {
          parameter: "joker_type",
          values: ["specific"],
        },
      },
      {
        id: "pool",
        type: "text",
        label: "Pool Name (optional)",
        default: "",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [{ value: "none", label: "No Edition" }, ...EDITIONS()],
        default: "none",
      },
      {
        id: "sticker",
        type: "select",
        label: "Sticker for Copy",
        options: [{ value: "none", label: "No Sticker" }, ...STICKERS],
        default: "none",
      },
      {
        id: "ignore_slots",
        type: "select",
        label: "___ Joker Slots",
        options: [
          { value: "respect", label: "Respect" },
          { value: "ignore", label: "Ignore" },
        ],
        default: "respect",
      },
    ],
    category: "Jokers",
  },
  {
    id: "destroy_joker",
    label: "Destroy Joker",
    description: "Destroy an existing joker",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Selection Method",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
          { value: "position", label: "By Position" },
        ],
        default: "random",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., j_joker, j_greedy_joker)",
        default: "j_joker",
        showWhen: {
          parameter: "selection_method",
          values: ["specific"],
        },
      },
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
        ],
        default: "first",
        showWhen: {
          parameter: "selection_method",
          values: ["position"],
        },
      },
    ],
    category: "Jokers",
  },
  {
    id: "copy_joker",
    label: "Copy Joker",
    description: "Copy an existing joker",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Selection Method",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
          { value: "position", label: "By Position" },
        ],
        default: "random",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., j_joker, j_greedy_joker)",
        default: "j_joker",
        showWhen: {
          parameter: "selection_method",
          values: ["specific"],
        },
      },
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
        ],
        default: "first",
        showWhen: {
          parameter: "selection_method",
          values: ["position"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition for Copy",
        options: [
          { value: "none", label: "No Edition" },
          { value: "e_foil", label: "Foil" },
          { value: "e_holo", label: "Holographic" },
          { value: "e_polychrome", label: "Polychrome" },
          { value: "e_negative", label: "Negative" },
        ],
        default: "none",
      },
    ],
    category: "Jokers",
  },
  {
    id: "level_up_hand",
    label: "Level Up Hand",
    description: "Increase the level of a poker hand",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "hand_selection",
        type: "select",
        label: "Hand Selection",
        options: [
          { value: "current", label: "Current Hand (Scored)" },
          { value: "specific", label: "Specific Hand" },
          { value: "most", label: "Most Played" },
          { value: "least", label: "Least Played" },
          { value: "random", label: "Random Hand" },
        ],
        default: "current",
      },
      {
        id: "specific_hand",
        type: "select",
        label: "Specific Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "hand_selection",
          values: ["specific"],
        },
      },
      {
        id: "value",
        type: "number",
        label: "Levels",
        default: 1,
        min: 1,
      },
    ],
    category: "Special",
  },
  {
    id: "create_consumable",
    label: "Create Consumable",
    description:
      "Create consumable cards and add them to your consumables area",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;

          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "random",
      },
      {
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "No Edition" },
          { value: "negative", label: "Negative Edition" },
        ],
        default: "none",
      },
    ],
    category: "Consumables",
  },
  {
    id: "copy_consumable",
    label: "Copy Consumable",
    description: "Copy an existing consumable card from your collection",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;

          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "random",
      },
      {
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "No Edition" },
          { value: "negative", label: "Negative Edition" },
        ],
        default: "none",
      },
    ],
    category: "Consumables",
  },
  {
    id: "destroy_consumable",
    label: "Destroy Consumable",
    description: "Destroy a consumable card from your collection",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;

          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "random",
      },
    ],
    category: "Consumables",
  },
  {
    id: "create_last_played_planet",
    label: "Create Last Played Planet",
    description:
      "Create a Planet card corresponding to the last hand played (Blue Seal effect)",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "No Edition" },
          { value: "negative", label: "Negative Edition" },
        ],
        default: "none",
      },
    ],
    category: "Consumables",
  },
  {
    id: "edit_playing_card",
    label: "Edit Playing Card",
    description: "Modify the properties of this playing card",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "new_rank",
        type: "select",
        label: "New Rank",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "random", label: "Random" },
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
        ],
        default: "none",
      },
      {
        id: "new_suit",
        type: "select",
        label: "New Suit",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "random", label: "Random" },
          ...SUITS,
        ],
        default: "none",
      },
      {
        id: "new_enhancement",
        type: "select",
        label: "New Enhancement",
        options: () => [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Enhancement" },
          { value: "random", label: "Random" },
          ...ENHANCEMENTS(),
        ],
        default: "none",
      },
      {
        id: "new_seal",
        type: "select",
        label: "New Seal",
        options: () => [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Seal" },
          { value: "random", label: "Random" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "new_edition",
        type: "select",
        label: "New Edition",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Edition" },
          { value: "random", label: "Random" },
          ...EDITIONS(),
        ],
        default: "none",
      },
    ],
    category: "Special",
  },
  {
    id: "show_message",
    label: "Show Message",
    description: "Display a custom message with specified color",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "colour",
        type: "select",
        label: "Message Color",
        options: [
          { value: "G.C.WHITE", label: "White" },
          { value: "G.C.RED", label: "Red" },
          { value: "G.C.GREEN", label: "Green" },
          { value: "G.C.BLUE", label: "Blue" },
          { value: "G.C.YELLOW", label: "Yellow" },
          { value: "G.C.PURPLE", label: "Purple" },
          { value: "G.C.ORANGE", label: "Orange" },
          { value: "G.C.BLACK", label: "Black" },
          { value: "G.C.CHIPS", label: "Chips (Blue)" },
          { value: "G.C.MULT", label: "Mult (Red)" },
          { value: "G.C.MONEY", label: "Money (Yellow)" },
        ],
        default: "G.C.WHITE",
      },
    ],
    category: "Special",
  },
  {
    id: "balance",
    label: "Balance Chips and Mult",
    description: "Balance chips and mult values (Plasma Deck effect)",
    applicableTriggers: SCORING_TRIGGERS,
    params: [],
    category: "Special",
  },
  {
    id: "swap_chips_mult",
    label: "Swap Chips & Mult",
    description: "Swap the Chips and Mult values",
    applicableTriggers: SCORING_TRIGGERS,
    params: [],
    category: "Special",
  },
  {
    id: "draw_cards",
    label: "Draw Cards to Hand",
    description: "Draw cards from your deck to your hand",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held",
      "card_held_in_hand_end_of_round",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
      },
    ],
    category: "Special",
  },
  {
    id: "emit_flag",
    label: "Emit Flag",
    description:
      "Emit a custom flag. Flags are global variables that can be set to true or false and checked by any other jokers",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held",
      "card_held_in_hand_end_of_round",
    ],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Unique Flag Name",
        default: "custom_flag",
      },
      {
        id: "change",
        type: "select",
        label: "Set Flag to",
        options: [
          { value: "true", label: "True" },
          { value: "false", label: "False" },
          { value: "invert", label: "Invert Current" },
        ],
        default: "true",
      },
    ],
    category: "Special",
  },
  {
    id: "play_sound",
    label: "Play a sound",
    description: "Play a specific sound defined in the Sound Tab",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "sound_key",
        type: "text",
        label: "Sound Key (modprefix_key)",
        default: "",
      },
    ],
    category: "Special",
  },
];

export function getCardEffectsForTrigger(
  triggerId: string
): EffectTypeDefinition[] {
  return CARD_EFFECT_TYPES.filter((effect) =>
    effect.applicableTriggers?.includes(triggerId)
  );
}

export function getCardEffectTypeById(
  id: string
): EffectTypeDefinition | undefined {
  return CARD_EFFECT_TYPES.find((effect) => effect.id === id);
}

```

### src\components\data\Card\Triggers.ts

```
import { TriggerDefinition } from "../../ruleBuilder/types";
import { HandRaisedIcon } from "@heroicons/react/24/outline";

export interface CategoryDefinition {
  label: string;
  icon: React.ComponentType<{ className?: string }>;
}

export const GENERIC_TRIGGERS = [
  "card_scored",
  "card_held",
  "card_discarded",
  "card_held_in_hand_end_of_round",
];

export const SCORING_TRIGGERS = ["card_scored", "card_held"];

export const CARD_TRIGGER_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Card",
    icon: HandRaisedIcon,
  },
];

export const CARD_TRIGGERS: TriggerDefinition[] = [
  {
    id: "card_scored",
    label: "When Card is Scored",
    description: "Triggers when this card is part of a scoring hand",
    category: "Card",
  },
  {
    id: "card_held",
    label: "When Card is Held in Hand",
    description: "Triggers when this card is in the player's hand",
    category: "Card",
  },
  {
    id: "card_held_in_hand_end_of_round",
    label: "When a Card is Held in Hand at End of Round",
    description:
      "Triggers for each individual card currently held in your hand at the end of the round. Good for effects that mimic Gold Cards or Blue Seals.",
    category: "Card",
  },
  {
    id: "card_discarded",
    label: "When Card is Discarded",
    description:
      "Triggers whenever a card is discarded. Use conditions to check properties of the discarded card.",
    category: "Card",
  },
];

export function getCardTriggerById(id: string): TriggerDefinition | undefined {
  return CARD_TRIGGERS.find((trigger) => trigger.id === id);
}

```

### src\components\data\Consumables\Conditions.ts

```
import { ConditionTypeDefinition } from "../../ruleBuilder/types";
import {
  RectangleStackIcon,
  UserIcon,
  ArchiveBoxIcon,
  InformationCircleIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "../Jokers/Triggers";
import {
  COMPARISON_OPERATORS,
  CONSUMABLE_SETS,
  CUSTOM_CONSUMABLES,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  TAROT_CARDS,
  VOUCHERS,
} from "../BalatroUtils";

export const CONSUMABLE_GENERIC_TRIGGERS: string[] = [
  "consumable_used",
  "card_selected",
  "hand_highlighted",
  "before_use",
  "after_use",
];

export const CONSUMABLE_CONDITION_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Card Selection",
    icon: RectangleStackIcon,
  },
  {
    label: "Player State",
    icon: UserIcon,
  },
  {
    label: "Hand State",
    icon: ArchiveBoxIcon,
  },
  {
    label: "Game Context",
    icon: InformationCircleIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const CONSUMABLE_CONDITION_TYPES: ConditionTypeDefinition[] = [
  {
    id: "cards_selected",
    label: "Cards Selected",
    description: "Check how many cards are selected/highlighted",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "equals" },
          { value: "greater_than", label: "greater than" },
          { value: "less_than", label: "less than" },
          { value: "greater_equals", label: "greater than or equal" },
          { value: "less_equals", label: "less than or equal" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "number",
        label: "Number of Cards",
        default: 1,
        min: 0,
      },
    ],
    category: "Card Selection",
  },
  {
    id: "player_money",
    label: "Player Money",
    description: "Check the player's current money",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "equals" },
          { value: "greater_than", label: "greater than" },
          { value: "less_than", label: "less than" },
          { value: "greater_equals", label: "greater than or equal" },
          { value: "less_equals", label: "less than or equal" },
        ],
        default: "greater_equals",
      },
      {
        id: "value",
        type: "number",
        label: "Dollar Amount",
        default: 5,
        min: 0,
      },
    ],
    category: "Player State",
  },
  {
    id: "ante_level",
    label: "Ante Level",
    description: "Check the current ante level",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "equals" },
          { value: "not_equals", label: "not equals" },
          { value: "greater_than", label: "greater than" },
          { value: "less_than", label: "less than" },
          { value: "greater_equals", label: "greater than or equal" },
          { value: "less_equals", label: "less than or equal" },
        ],
        default: "greater_equals",
      },
      {
        id: "value",
        type: "number",
        label: "Ante Level",
        default: 1,
        min: 1,
      },
    ],
    category: "Game Context",
  },
  {
    id: "voucher_redeemed",
    label: "Voucher Redeemed",
    description: "Check if a specific Voucher was redeemed during the run",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "voucher",
        type: "select",
        label: "Voucher",
        options: [...VOUCHERS()],
        default: "v_overstock_norm",
      },
    ],
    category: "Game Context",
  },
  {
    id: "hand_size",
    label: "Hand Size",
    description: "Check the current hand size",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "equals" },
          { value: "not_equals", label: "not equals" },
          { value: "greater_than", label: "greater than" },
          { value: "less_than", label: "less than" },
          { value: "greater_equals", label: "greater than or equal" },
          { value: "less_equals", label: "less than or equal" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "number",
        label: "Hand Size",
        default: 8,
        min: 1,
      },
    ],
    category: "Player State",
  },
  {
    id: "remaining_hands",
    label: "Remaining Hands",
    description: "Check how many hands the player has left",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "equals" },
          { value: "not_equals", label: "not equals" },
          { value: "greater_than", label: "greater than" },
          { value: "less_than", label: "less than" },
          { value: "greater_equals", label: "greater than or equal" },
          { value: "less_equals", label: "less than or equal" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "number",
        label: "Number of Hands",
        default: 1,
        min: 0,
      },
    ],
    category: "Player State",
  },
  {
    id: "in_blind",
    label: "In Blind",
    description: "Check if the player is currently in a blind (gameplay)",
    applicableTriggers: ["consumable_used"],
    params: [],
    category: "Game Context",
  },
  {
    id: "system_condition",
    label: "Player OS",
    description: "Check on what Operating System the player is on",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "system",
        type: "select",
        label: "OS",
        options: [
          {value: "Windows",label: "Windows"},
          {value: "OS X",label: "OS X"},
          {value: "Linux",label: "Linux"},
          {value: "Android",label: "Android"},
          {value: "iOS",label: "iOS"},
        ],
        default: "Windows",
      },
    ],
    category: "Game Context",
  },
  {
    id: "consumable_count",
    label: "Consumable Count",
    description: "Check how many of a consumable a player has",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "consumable_type",
        type: "select",
        label: "Consumable Type",
        options: () => [
          { value: "any", label: "Any Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "any",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.consumable_type as string;

          if (!selectedSet || selectedSet === "any") {
            return [];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "any", label: "Any from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "any",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Consumables",
        min: 0,
        default: 1,
      },
    ],
    category: "Player State",
  },
  {
    id: "check_flag",
    label: "Check Flag",
    description: "Check if a specific flag from your mod is true",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Flag Name",
        default: "custom_flag",
      },
    ],
    category: "Special",
  },
];

export function getConsumableConditionsForTrigger(
  triggerId: string
): ConditionTypeDefinition[] {
  return CONSUMABLE_CONDITION_TYPES.filter((condition) =>
    condition.applicableTriggers?.includes(triggerId)
  );
}

export function getConsumableConditionTypeById(
  id: string
): ConditionTypeDefinition | undefined {
  return CONSUMABLE_CONDITION_TYPES.find((condition) => condition.id === id);
}

```

### src\components\data\Consumables\Effects.ts

```
import { EffectTypeDefinition } from "../../ruleBuilder/types";
import {
  PencilSquareIcon,
  BanknotesIcon,
  SparklesIcon,
  CakeIcon,
  UserGroupIcon,
  CursorArrowRaysIcon,
  HandRaisedIcon,
  ShoppingBagIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "../Jokers/Triggers";
import {
  ENHANCEMENTS,
  SUITS,
  RANKS,
  SEALS,
  EDITIONS,
  POKER_HANDS,
  TAROT_CARDS,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  CUSTOM_CONSUMABLES,
  CONSUMABLE_SETS,
  RARITIES,
  TAGS,
  VOUCHERS,
  STICKERS,
} from "../BalatroUtils";

export const CONSUMABLE_EFFECT_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Selected Cards",
    icon: CursorArrowRaysIcon,
  },
  {
    label: "Card Modification",
    icon: PencilSquareIcon,
  },
  {
    label: "Economy",
    icon: BanknotesIcon,
  },
  {
    label: "Shop Effects",
    icon: ShoppingBagIcon,
  },
  {
    label: "Hand Effects",
    icon: HandRaisedIcon,
  },
  {
    label: "Consumables",
    icon: CakeIcon,
  },
  {
    label: "Jokers",
    icon: UserGroupIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const CONSUMABLE_EFFECT_TYPES: EffectTypeDefinition[] = [
  // ===== SELECTED CARDS EFFECTS =====
  {
    id: "edit_cards",
    label: "Edit Selected Cards",
    description:
      "Apply multiple modifications to selected cards (enhancement, seal, edition, suit, rank)",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "none", label: "No Change" },
          { value: "remove", label: "Remove Enhancement" },
          ...ENHANCEMENTS(),
          { value: "random", label: "Random Enhancement" },
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [
          { value: "none", label: "No Change" },
          { value: "remove", label: "Remove Seal" },
          { value: "random", label: "Random Seal" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "none", label: "No Change" },
          { value: "remove", label: "Remove Edition" },
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
        ],
        default: "none",
      },
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [
          { value: "none", label: "No Change" },
          ...SUITS,
          { value: "random", label: "Random Suit" },
        ],
        default: "none",
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [
          { value: "none", label: "No Change" },
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
          { value: "random", label: "Random Rank" },
        ],
        default: "none",
      },
    ],
    category: "Selected Cards",
  },
  {
    id: "destroy_selected_cards",
    label: "Destroy Selected Cards",
    description: "Destroy all currently selected cards",
    applicableTriggers: ["consumable_used"],
    params: [],
    category: "Selected Cards",
  },
  {
    id: "increment_rank",
    label: "Increment/Decrement Rank",
    description:
      "Increase or decrease the rank of selected cards by a specified amount",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "increment", label: "Increment (+)" },
          { value: "decrement", label: "Decrement (-)" },
        ],
        default: "increment",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 13,
      },
    ],
    category: "Selected Cards",
  },
  {
    id: "copy_selected_cards",
    label: "Copy Selected Cards",
    description: "Create copies of selected cards with customizable properties",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "copies",
        type: "number",
        label: "Number of Copies per Card",
        default: 1,
        min: 1,
        max: 5,
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "none", label: "Keep Original Enhancement" },
          ...ENHANCEMENTS(),
          { value: "random", label: "Random Enhancement" },
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [
          { value: "none", label: "Keep Original Seal" },
          { value: "random", label: "Random Seal" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "none", label: "Keep Original Edition" },
          { value: "remove", label: "Remove Edition" },
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
        ],
        default: "none",
      },
    ],
    category: "Selected Cards",
  },
  {
    id: "convert_left_to_right",
    label: "Convert Left to Right",
    description:
      "Convert all selected cards to match the rightmost selected card (like Death tarot)",
    applicableTriggers: ["consumable_used"],
    params: [],
    category: "Selected Cards",
  },
  {
    id: "perma_bonus",
    label: "Give Permanent Bonus",
    description:
      "Give selected cards a permanent bonus that persists throughout the run",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "bonus_type",
        type: "select",
        label: "Bonus Type",
        options: [
          { value: "perma_bonus", label: "Permanent Chips" },
          { value: "perma_mult", label: "Permanent Mult" },
          { value: "h_mult", label: "Held Mult" },
          { value: "h_chips", label: "Held Chips" },
        ],
        default: "perma_bonus",
      },
      {
        id: "value",
        type: "number",
        label: "Bonus Amount",
        default: 10,
        min: 1,
      },
    ],
    category: "Selected Cards",
  },

  // ===== HAND EFFECTS =====
  {
    id: "edit_hand_size",
    label: "Edit Hand Size",
    description: "Add, subtract, or set the player's hand size",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 50,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "draw_cards",
    label: "Draw Cards to Hand",
    description: "Draw cards from your deck to your hand",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "edit_play_size",
    label: "Edit Play Size",
    description: "Add, subtract, or set the player's play size",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 50,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "edit_discard_size",
    label: "Edit Discard Size",
    description: "Add, subtract, or set the player's discard size",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 50,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "edit_voucher_slots",
    label: "Edit Voucher Slots",
    description: "Modify the number of vouchers available in shop",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Shop Effects",
  },
  {
    id: "edit_booster_slots",
    label: "Edit Booster Slots",
    description: "Modify the number of booster packs available in shop",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Shop Effects",
  },
  {
    id: "edit_hands",
    label: "Edit Hands",
    description: "Add, subtract, or set the player's hands for this round",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "duration",
        type: "select",
        label: "Duration",
        options: [
          { value: "permanent", label: "Permanent" },
          { value: "round", label: "This Round" },
        ],
        default: "permanent",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 50,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "edit_discards",
    label: "Edit Discards",
    description: "Add, subtract, or set the player's discards for this round",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "duration",
        type: "select",
        label: "Duration",
        options: [
          { value: "permanent", label: "Permanent" },
          { value: "round", label: "This Round" },
        ],
        default: "permanent",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
        max: 50,
      },
    ],
    category: "Hand Effects",
  },

  // ===== OTHER EFFECTS =====
  {
    id: "convert_all_cards_to_suit",
    label: "Convert All Cards to Suit",
    description: "Convert all cards in hand to a specific suit",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "suit",
        type: "select",
        label: "Target Suit",
        options: [...SUITS, { value: "random", label: "Random Suit" }],
        default: "Hearts",
      },
    ],
    category: "Card Modification",
  },
  {
    id: "convert_all_cards_to_rank",
    label: "Convert All Cards to Rank",
    description: "Convert all cards in hand to a specific rank",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "rank",
        type: "select",
        label: "Target Rank",
        options: [
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
          { value: "random", label: "Random Rank" },
        ],
        default: "Ace",
      },
    ],
    category: "Card Modification",
  },
  {
    id: "destroy_random_cards",
    label: "Destroy Random Cards",
    description: "Destroy a number of random cards from hand",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "count",
        type: "number",
        label: "Number of Cards",
        default: 1,
        min: 1,
        max: 8,
      },
    ],
    category: "Card Modification",
  },
  {
    id: "edit_joker_slots",
    label: "Edit Joker Slots",
    description: "Add or remove joker slots available in the game",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Jokers",
  },
  {
    id: "add_cards_to_hand",
    label: "Add Cards to Hand",
    description: "Create and add new cards to hand with specified properties",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "count",
        type: "number",
        label: "Number of Cards",
        default: 1,
        min: 1,
        max: 8,
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [
          { value: "random", label: "Random Rank" },
          { value: "Face Cards", label: "Face Cards" },
          { value: "Numbered Cards", label: "Numbered Cards" },
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
        ],
        default: "random",
      },
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [{ value: "none", label: "Random Suit" }, ...SUITS],
        default: "none",
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "none", label: "No Enhancement" },
          ...ENHANCEMENTS(),
          { value: "random", label: "Random Enhancement" },
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [
          { value: "none", label: "No Seal" },
          { value: "random", label: "Random Seal" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "none", label: "No Edition" },
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
        ],
        default: "none",
      },
    ],
    category: "Card Modification",
  },
  {
    id: "level_up_hand",
    label: "Level Up Poker Hand",
    description: "Level up a specific poker hand, random hand, or all hands",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "hand_type",
        type: "select",
        label: "Poker Hand",
        options: [
          ...POKER_HANDS.map((hand) => ({
            value: hand.value,
            label: hand.label,
          })),
          { value: "random", label: "Random Hand" },
          { value: "all", label: "All Hands" },
        ],
        default: "Pair",
      },
      {
        id: "levels",
        type: "number",
        label: "Number of Levels",
        default: 1,
        min: 1,
        max: 10,
      },
    ],
    category: "Hand Effects",
  },
  {
    id: "edit_dollars",
    label: "Edit Dollars",
    description: "Add, subtract, or set the player's money",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Dollar Amount",
        default: 5,
        min: 0,
      },
    ],
    category: "Economy",
  },
  {
    id: "double_dollars",
    label: "Double Dollars",
    description: "Double your current money up to a specified limit",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "limit",
        type: "number",
        label: "Maximum Amount to Gain",
        default: 20,
        min: 1,
        max: 999,
      },
    ],
    category: "Economy",
  },
  {
    id: "add_dollars_from_jokers",
    label: "Add Dollars from Joker Sell Value",
    description:
      "Gain money equal to the total sell value of all jokers, up to a limit",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "limit",
        type: "number",
        label: "Maximum Amount to Gain",
        default: 50,
        min: 1,
        max: 999,
      },
    ],
    category: "Economy",
  },
  {
    id: "create_consumable",
    label: "Create Consumable",
    description:
      "Create consumable cards and add them to your consumables area",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },{
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;
          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }
          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];}
          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];}
          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }
          // Handle custom sets
          // Remove mod prefix to get the actual set key
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;
          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );
          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];},
        default: "random",
      },{
        id: "soulable",
        type: "select",
        label: "Soulable",
        options: [
          { value: "y", label: "Yes" },
          { value: "n", label: "No" },
        ],
        showWhen: {
          parameter: "specific_card",
          values: ["random"],
        },
        default:"nil",
      },{
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "n", label: "No Edition" },
          { value: "y", label: "Negative Edition" },
        ],
        default: "none",
      },{
        id: "count",
        type: "number",
        label: "Number of Cards",
        default: 1,
        min: 1,
        max: 5,
      },
    ],
    category: "Consumables",
  },
  {
    id: "destroy_consumable",
    label: "Destroy Consumable",
    description: "Destroy a consumable card from your collection",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;

          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "random",
      },
    ],
    category: "Consumables",
  },
  {
    id: "fool_effect",
    label: "Create Last Used Consumable",
    description:
      "Create a copy of the last Tarot or Planet card that was used (like The Fool)",
    applicableTriggers: ["consumable_used"],
    params: [],
    category: "Consumables",
  },
  {
    id: "create_tag",
    label: "Create Tag",
    description: "Create a specific or random tag",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "tag_type",
        type: "select",
        label: "Tag Type",
        options: [
          { value: "random", label: "Random Tag" },
          { value: "specific", label: "Specific Tag" },
        ],
        default: "random",
      },
      {
        id: "specific_tag",
        type: "select",
        label: "Specific Tag",
        options: [...TAGS],
        showWhen: {
          parameter: "tag_type",
          values: ["specific"],
        },
      },
    ],
    category: "Consumables",
  },
  {
    id: "redeem_voucher",
    label: "Redeem Voucher",
    description: "Redeem a specific or random voucher",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "voucher_type",
        type: "select",
        label: "Voucher Type",
        options: [
          { value: "random", label: "Random Voucher" },
          { value: "specific", label: "Specific Voucher" },
        ],
        default: "random",
      },
      {
        id: "specific_voucher",
        type: "select",
        label: "Specific Voucher",
        options: [...VOUCHERS()],
        showWhen: {
          parameter: "voucher_type",
          values: ["specific"],
        },
        default: "v_overstock_norm",
      },
    ],
    category: "Consumables",
  },
  {
    id: "edit_cards_in_hand",
    label: "Edit Cards in Hand",
    description:
      "Apply multiple modifications to random cards in hand (enhancement, seal, edition, suit, rank)",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "amount",
        type: "number",
        label: "Number of Cards",
        default: 1,
        min: 1,
        max: 8,
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "none", label: "No Change" },
          ...ENHANCEMENTS(),
          { value: "random", label: "Random Enhancement" },
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [
          { value: "none", label: "No Change" },
          { value: "random", label: "Random Seal" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "none", label: "No Change" },
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
        ],
        default: "none",
      },
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [
          { value: "none", label: "No Change" },
          ...SUITS,
          { value: "random", label: "Random Suit" },
        ],
        default: "none",
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [
          { value: "none", label: "No Change" },
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
          { value: "random", label: "Random Rank" },
        ],
        default: "none",
      },
    ],
    category: "Card Modification",
  },
  {
    id: "create_joker",
    label: "Create Joker",
    description:
      "Create a random or specific joker card. For creating jokers from your own mod, it is [modprefix]_[joker_name]. You can find your mod prefix in the mod metadata page.",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "joker_type",
        type: "select",
        label: "Joker Type",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
        ],
        default: "random",
      },
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [
          { value: "random", label: "Any Rarity" },
          ...RARITIES(),
        ],
        default: "random",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key ( [modprefix]_joker )",
        default: "joker",
        showWhen: {
          parameter: "joker_type",
          values: ["specific"],
        },
      },
      {
        id: "pool",
        type: "text",
        label: "Pool Name (optional)",
        default: "",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [{ value: "none", label: "No Edition" }, ...EDITIONS()],
        default: "none",
      },
      {
        id: "sticker",
        type: "select",
        label: "Sticker for Copy",
        options: [{ value: "none", label: "No Sticker" }, ...STICKERS],
        default: "none",
      },
      {
        id: "ignore_slots",
        type: "select",
        label: "___ Joker Slots",
        options: [
          { value: "respect", label: "Respect" },
          { value: "ignore", label: "Ignore" },
        ],
        default: "respect",
      },
    ],
    category: "Jokers",
  },
  {
    id: "copy_random_joker",
    label: "Copy Random Joker",
    description: "Create copies of random jokers in your joker area",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "amount",
        type: "number",
        label: "Number of Jokers to Copy",
        default: 1,
        min: 1,
        max: 5,
      },
      {
        id: "edition",
        type: "select",
        label: "Edition to Apply",
        options: [
          { value: "none", label: "Keep Original Edition" },
          { value: "remove", label: "Remove Edition" },
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
        ],
        default: "none",
      },
    ],
    category: "Jokers",
  },
  {
    id: "destroy_random_joker",
    label: "Destroy Random Joker",
    description:
      "Destroy random jokers from your joker area (eternal jokers are safe)",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "amount",
        type: "number",
        label: "Number of Jokers to Destroy",
        default: 1,
        min: 1,
        max: 5,
      },
    ],
    category: "Jokers",
  },
  {
    id: "edition_random_joker",
    label: "Apply Edition to Random Joker",
    description: "Apply an edition to random jokers in your joker area",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "amount",
        type: "number",
        label: "Number of Jokers to Apply Edition",
        default: 1,
        min: 1,
        max: 5,
      },
      {
        id: "edition",
        type: "select",
        label: "Edition to Apply",
        options: [
          ...EDITIONS().map((edition) => ({
            value: edition.key,
            label: edition.label,
          })),
          { value: "random", label: "Random Edition" },
          { value: "remove", label: "Remove Edition" },
        ],
        default: "e_foil",
      },
      {
        id: "target_type",
        type: "select",
        label: "Target Jokers",
        options: [
          { value: "editionless", label: "Only Editionless Jokers" },
          { value: "any", label: "Any Jokers" },
        ],
        default: "editionless",
      },
    ],
    category: "Jokers",
  },
  {
    id: "emit_flag",
    label: "Emit Flag",
    description:
      "Emit a custom flag. Flags are global variables that can be set to true or false and checked by any other jokers",
    applicableTriggers: ["consumable_used"],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Unique Flag Name",
        default: "custom_flag",
      },
      {
        id: "change",
        type: "select",
        label: "Set Flag to",
        options: [
          { value: "true", label: "True" },
          { value: "false", label: "False" },
          { value: "invert", label: "Invert Current" },
        ],
        default: "true",
      },
    ],
    category: "Special",
  },
  {
      id: "play_sound",
      label: "Play a sound",
      description: "Play a specific sound defined in the Sound Tab",
      applicableTriggers: ["consumable_used"],
      params: [
        {
          id: "sound_key",
          type: "text",
          label: "Sound Key (modprefix_key)",
          default: "",
        },
      ],
      category: "Special",
    },
];

export function getConsumableEffectsForTrigger(
  triggerId: string
): EffectTypeDefinition[] {
  return CONSUMABLE_EFFECT_TYPES.filter((effect) =>
    effect.applicableTriggers?.includes(triggerId)
  );
}

export function getConsumableEffectTypeById(
  id: string
): EffectTypeDefinition | undefined {
  return CONSUMABLE_EFFECT_TYPES.find((effect) => effect.id === id);
}

export function getSelectedCardEffects(): EffectTypeDefinition[] {
  return CONSUMABLE_EFFECT_TYPES.filter(
    (effect) => effect.category === "Selected Cards"
  );
}

export function getNonSelectedCardEffects(): EffectTypeDefinition[] {
  return CONSUMABLE_EFFECT_TYPES.filter(
    (effect) => effect.category !== "Selected Cards"
  );
}

```

### src\components\data\Consumables\Triggers.ts

```
import { TriggerDefinition } from "../../ruleBuilder/types";
import { HandRaisedIcon } from "@heroicons/react/24/outline";

export interface CategoryDefinition {
  label: string;
  icon: React.ComponentType<{ className?: string }>;
}

export const CONSUMABLE_TRIGGER_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Usage",
    icon: HandRaisedIcon,
  },
];

export const CONSUMABLE_TRIGGERS: TriggerDefinition[] = [
  {
    id: "consumable_used",
    label: "When Consumable is Used",
    description: "Triggers when this consumable is activated by the player",
    category: "Usage",
  },
];

export function getConsumableTriggerById(
  id: string
): TriggerDefinition | undefined {
  return CONSUMABLE_TRIGGERS.find((trigger) => trigger.id === id);
}

```

### src\components\data\Jokers\Conditions.ts

```
import {
  ConditionParameterOption,
  ConditionTypeDefinition,
} from "../../ruleBuilder/types";
import {
  HandRaisedIcon,
  RectangleStackIcon,
  UserIcon,
  ArchiveBoxIcon,
  ReceiptPercentIcon,
  InformationCircleIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "./Triggers";
import {
  RANKS,
  RANK_GROUPS,
  SUITS,
  SUIT_GROUPS,
  POKER_HANDS,
  ENHANCEMENTS,
  EDITIONS,
  SEALS,
  COMPARISON_OPERATORS,
  CARD_SCOPES,
  TAROT_CARDS,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  CUSTOM_CONSUMABLES,
  CONSUMABLE_SETS,
  RARITIES,
  VOUCHERS,
  STICKERS,
  BOSS_BLINDS,
  TAGS,
} from "../BalatroUtils";

export const GENERIC_TRIGGERS: string[] = [
  "blind_selected",
  "card_scored",
  "hand_played",
  "blind_skipped",
  "boss_defeated",
  "booster_opened",
  "booster_skipped",
  "consumable_used",
  "hand_drawn",
  "first_hand_drawn",
  "shop_entered",
  "shop_exited",
  "card_discarded",
  "hand_discarded",
  "round_end",
  "shop_reroll",
  "card_held_in_hand",
  "card_held_in_hand_end_of_round",
  "after_hand_played",
  "before_hand_played",
  "joker_evaluated",
  "card_sold",
  "card_bought",
  "selling_self",
  "buying_self",
  "card_destroyed",
  "playing_card_added",
  "game_over",
  "probability_result",
  "tag_added",
];

export const PROBABILITY_IDENTIFIERS: {
  jokers: ConditionParameterOption[];
  consumables: ConditionParameterOption[];
  enhancements: ConditionParameterOption[];
  blinds: ConditionParameterOption[];
} = {
  jokers: [
    { value: "8ball", label: "8 Ball" },
    { value: "gros_michel", label: "Gros Michel" },
    { value: "business", label: "Business Card" },
    { value: "space", label: "Space Joker" },
    { value: "cavendish", label: "Cavendish" },
    { value: "parking", label: "Reserved Parking" },
    { value: "halu1", label: "Hallucination" },
    { value: "bloodstone", label: "Bloodstone" },
  ],
  consumables: [{ value: "wheel_of_fortune", label: "Wheel of Fortune" }],
  enhancements: [
    { value: "lucky_mult", label: "Lucky Card Mult" },
    { value: "lucky_money", label: "Lucky Card Money" },
    { value: "glass", label: "Glass Card" },
  ],
  blinds: [{ value: "wheel", label: "The Wheel" }],
};

export const CONDITION_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Hand",
    icon: HandRaisedIcon,
  },
  {
    label: "Card",
    icon: RectangleStackIcon,
  },
  {
    label: "Joker",
    icon: RectangleStackIcon,
  },
  {
    label: "Player Resources",
    icon: UserIcon,
  },
  {
    label: "Deck & Jokers",
    icon: ArchiveBoxIcon,
  },
  {
    label: "Probability",
    icon: ReceiptPercentIcon,
  },
  {
    label: "Game State",
    icon: InformationCircleIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const CONDITION_TYPES: ConditionTypeDefinition[] = [
  {
    id: "hand_type",
    label: "Hand Type",
    description: "Check the type of poker hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "contains", label: "contains" },
          { value: "equals", label: "equals" },
        ],
        default: "contains",
      },
      {
        id: "value",
        type: "select",
        label: "Hand Type",
        options: [
          ...POKER_HANDS,
          { value: "most_played_hand", label: "Most Played Hand" },
          { value: "least_played_hand", label: "Least Played Hand" },
        ],
      },
    ],
    category: "Hand",
  },
  {
    id: "card_count",
    label: "Card Count",
    description: "Check the number of cards in the played hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [
          ...CARD_SCOPES,
          { value: "unscored", label: "Unscored Cards" },
        ],
        default: "scoring",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Cards",
        default: 5,
      },
    ],
    category: "Hand",
  },
  {
    id: "suit_count",
    label: "Suit Count",
    description: "Check how many cards of a specific suit are in the hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "suit_type",
        type: "select",
        label: "Suit Type",
        options: [
          { value: "specific", label: "Specific Suit" },
          { value: "group", label: "Suit Group" },
        ],
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "suit_type",
          values: ["specific"],
        },
      },
      {
        id: "suit_group",
        type: "select",
        label: "Suit Group",
        options: [...SUIT_GROUPS],
        showWhen: {
          parameter: "suit_type",
          values: ["group"],
        },
      },
      {
        id: "quantifier",
        type: "select",
        label: "Condition",
        options: [
          { value: "all", label: "All cards must be this suit" },
          { value: "none", label: "No cards can be this suit" },
          { value: "exactly", label: "Exactly N cards of this suit" },
          { value: "at_least", label: "At least N cards of this suit" },
          { value: "at_most", label: "At most N cards of this suit" },
        ],
      },
      {
        id: "count",
        type: "number",
        label: "Count",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "quantifier",
          values: ["exactly", "at_least", "at_most"],
        },
      },
    ],
    category: "Hand",
  },
  {
    id: "rank_count",
    label: "Rank Count",
    description: "Check how many cards of a specific rank are in the hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "rank_type",
        type: "select",
        label: "Rank Type",
        options: [
          { value: "specific", label: "Specific Rank" },
          { value: "group", label: "Rank Group" },
        ],
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "rank_type",
          values: ["specific"],
        },
      },
      {
        id: "rank_group",
        type: "select",
        label: "Rank Group",
        options: [...RANK_GROUPS],
        showWhen: {
          parameter: "rank_type",
          values: ["group"],
        },
      },
      {
        id: "quantifier",
        type: "select",
        label: "Condition",
        options: [
          { value: "all", label: "All cards must be this rank" },
          { value: "none", label: "No cards can be this rank" },
          { value: "exactly", label: "Exactly N cards of this rank" },
          { value: "at_least", label: "At least N cards of this rank" },
          { value: "at_most", label: "At most N cards of this rank" },
        ],
      },
      {
        id: "count",
        type: "number",
        label: "Count",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "quantifier",
          values: ["exactly", "at_least", "at_most"],
        },
      },
    ],
    category: "Hand",
  },
  {
    id: "discarded_card_count",
    label: "Discarded Card Count",
    description: "Check the number of cards in the discarded hand",
    applicableTriggers: ["card_discarded", "hand_discarded"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Cards",
        default: 5,
      },
    ],
    category: "Hand",
  },
  {
    id: "discarded_suit_count",
    label: "Discarded Suit Count",
    description:
      "Check how many cards of a specific suit are in the discarded hand",
    applicableTriggers: ["card_discarded", "hand_discarded"],
    params: [
      {
        id: "suit_type",
        type: "select",
        label: "Suit Type",
        options: [
          { value: "specific", label: "Specific Suit" },
          { value: "group", label: "Suit Group" },
        ],
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "suit_type",
          values: ["specific"],
        },
      },
      {
        id: "suit_group",
        type: "select",
        label: "Suit Group",
        options: [...SUIT_GROUPS],
        showWhen: {
          parameter: "suit_type",
          values: ["group"],
        },
      },
      {
        id: "quantifier",
        type: "select",
        label: "Condition",
        options: [
          { value: "all", label: "All cards must be this suit" },
          { value: "none", label: "No cards can be this suit" },
          { value: "exactly", label: "Exactly N cards of this suit" },
          { value: "at_least", label: "At least N cards of this suit" },
          { value: "at_most", label: "At most N cards of this suit" },
        ],
      },
      {
        id: "count",
        type: "number",
        label: "Count",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "quantifier",
          values: ["exactly", "at_least", "at_most"],
        },
      },
    ],
    category: "Hand",
  },
  {
    id: "discarded_rank_count",
    label: "Discarded Rank Count",
    description:
      "Check how many cards of a specific rank are in the discarded hand",
    applicableTriggers: ["card_discarded", "hand_discarded"],
    params: [
      {
        id: "rank_type",
        type: "select",
        label: "Rank Type",
        options: [
          { value: "specific", label: "Specific Rank" },
          { value: "group", label: "Rank Group" },
        ],
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "rank_type",
          values: ["specific"],
        },
      },
      {
        id: "rank_group",
        type: "select",
        label: "Rank Group",
        options: [...RANK_GROUPS],
        showWhen: {
          parameter: "rank_type",
          values: ["group"],
        },
      },
      {
        id: "quantifier",
        type: "select",
        label: "Condition",
        options: [
          { value: "all", label: "All cards must be this rank" },
          { value: "none", label: "No cards can be this rank" },
          { value: "exactly", label: "Exactly N cards of this rank" },
          { value: "at_least", label: "At least N cards of this rank" },
          { value: "at_most", label: "At most N cards of this rank" },
        ],
      },
      {
        id: "count",
        type: "number",
        label: "Count",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "quantifier",
          values: ["exactly", "at_least", "at_most"],
        },
      },
    ],
    category: "Hand",
  },
  {
    id: "card_rank",
    label: "Card Rank",
    description: "Check the rank of the card",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_destroyed",
    ],
    params: [
      {
        id: "rank_type",
        type: "select",
        label: "Rank Type",
        options: [
          { value: "specific", label: "Specific Rank" },
          { value: "group", label: "Rank Group" },
        ],
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "rank_type",
          values: ["specific"],
        },
      },
      {
        id: "rank_group",
        type: "select",
        label: "Rank Group",
        options: [...RANK_GROUPS],
        showWhen: {
          parameter: "rank_type",
          values: ["group"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "card_suit",
    label: "Card Suit",
    description: "Check the suit of the card",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_destroyed",
    ],
    params: [
      {
        id: "suit_type",
        type: "select",
        label: "Suit Type",
        options: [
          { value: "specific", label: "Specific Suit" },
          { value: "group", label: "Suit Group" },
        ],
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "suit_type",
          values: ["specific"],
        },
      },
      {
        id: "suit_group",
        type: "select",
        label: "Suit Group",
        options: [...SUIT_GROUPS],
        showWhen: {
          parameter: "suit_type",
          values: ["group"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "card_enhancement",
    label: "Card Enhancement",
    description: "Check if the card has a specific enhancement",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_destroyed",
    ],
    params: [
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "any", label: "Any Enhancement" },
          ...ENHANCEMENTS(),
        ],
      },
    ],
    category: "Card",
  },
  {
    id: "card_edition",
    label: "Card Edition",
    description: "Check if the card has a specific edition",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_destroyed",
    ],
    params: [
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [
          { value: "any", label: "Any Edition" },
          { value: "none", label: "No Edition" },
          ...EDITIONS(),
        ],
      },
    ],
    category: "Card",
  },
  {
    id: "card_seal",
    label: "Card Seal",
    description: "Check if the card has a specific seal",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_destroyed",
    ],
    params: [
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [{ value: "any", label: "Any Seal" }, ...SEALS()],
      },
    ],
    category: "Card",
  },
  {
    id: "card_index",
    label: "Card Index",
    description: "Check if the card is at a specific position in the hand",
    applicableTriggers: [
      "card_scored",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "card_discarded",
    ],
    params: [
      {
        id: "index_type",
        type: "select",
        label: "Position Type",
        options: [
          { value: "number", label: "Specific Number" },
          { value: "first", label: "First Card" },
          { value: "last", label: "Last Card" },
        ],
        default: "first",
      },
      {
        id: "index_number",
        type: "number",
        label: "Position Number",
        default: 1,
        min: 1,
        showWhen: {
          parameter: "index_type",
          values: ["number"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "player_money",
    label: "Player Money",
    description: "Check how much money the player has",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Amount ($)",
        default: 10,
      },
    ],
    category: "Player Resources",
  },
  {
    id: "enhancement_count",
    label: "Enhancement Count",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    description:
      "Check how many cards with a specific enhancement are in the hand",
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement Type",
        options: () => [
          { value: "any", label: "Any Enhancement" },
          ...ENHANCEMENTS(),
        ],
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Count",
        default: 1,
      },
    ],
    category: "Hand",
  },
  {
    id: "edition_count",
    label: "Edition Count",
    description: "Check how many cards with a specific edition are in the hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition Type",
        options: [{ value: "any", label: "Any Edition" }, ...EDITIONS()],
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Count",
        default: 1,
      },
    ],
    category: "Hand",
  },
  {
    id: "seal_count",
    label: "Seal Count",
    description: "Check how many cards with a specific seal are in the hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [
      {
        id: "card_scope",
        type: "select",
        label: "Card Scope",
        options: [...CARD_SCOPES],
        default: "scoring",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal Type",
        options: () => [{ value: "any", label: "Any Seal" }, ...SEALS()],
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Count",
        default: 1,
      },
    ],
    category: "Hand",
  },
  {
    id: "poker_hand_been_played",
    label: "Poker Hand Been Played",
    description:
      "Check if the current poker hand has already been played this round",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [],
    category: "Hand",
  },
  {
    id: "cumulative_chips",
    label: "Cumulative Chips",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "after_hand_played",
      "before_hand_played",
    ],
    description: "Check the sum of chips in hand",
    params: [
      {
        id: "hand",
        type: "select",
        label: "Hand Selection",
        options: [
          { value: "played", label: "Played Hand" },
          { value: "held", label: "Held in Hand" },
        ],
      },
      {
        id: "check",
        type: "select",
        label: "Check",
        options: [
          { value: "base", label: "Base Chips" },
          { value: "total", label: "Total Chips" },
        ],
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 0,
      },
    ],
    category: "Hand",
  },
  {
    id: "generic_compare",
    label: "Generic Compare",
    description: "Compare two custom values with an operator",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "value1",
        type: "number",
        label: "First Value",
        default: 0,
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value2",
        type: "number",
        label: "Second Value",
        default: 0,
      },
    ],
    category: "Special",
  },
  {
    id: "remaining_hands",
    label: "Remaining Hands",
    description: "Check how many hands the player has left",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Hands",
        min: 0,
        default: 1,
      },
    ],
    category: "Player Resources",
  },
  {
    id: "remaining_discards",
    label: "Remaining Discards",
    description: "Check how many discards the player has left",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Discards",
        min: 0,
        default: 1,
      },
    ],
    category: "Player Resources",
  },
  {
    id: "glass_card_destroyed",
    label: "Glass Card Destroyed",
    description: "Check if any glass cards were destroyed/shattered",
    applicableTriggers: ["card_destroyed"],
    params: [],
    category: "Hand",
  },
  {
    id: "joker_count",
    label: "Joker Count",
    description: "Check how many jokers the player has",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [{ value: "any", label: "Any Rarity" }, ...RARITIES()],
        default: "any",
      },
      {
        id: "value",
        type: "number",
        label: "Number of Jokers",
        min: 0,
        default: 1,
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "first_last_scored",
    label: "First/Last Scored",
    description:
      "Check if this is the first or last card of a specific type to be scored",
    applicableTriggers: ["card_scored"],
    params: [
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First" },
          { value: "last", label: "Last" },
        ],
        default: "first",
      },
      {
        id: "check_type",
        type: "select",
        label: "Check Type",
        options: [
          { value: "any", label: "Any Card" },
          { value: "rank", label: "Specific Rank" },
          { value: "suit", label: "Specific Suit" },
        ],
        default: "any",
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS, ...RANK_GROUPS],
        showWhen: {
          parameter: "check_type",
          values: ["rank"],
        },
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "check_type",
          values: ["suit"],
        },
      },
    ],
    category: "Card",
  },
  {
    id: "specific_joker",
    label: "Specific Joker",
    description: "Check if a specific joker is in your collection",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Condition",
        options: [
          { value: "has", label: "Has this joker" },
          { value: "does_not_have", label: "Does not have this joker" },
        ],
        default: "has",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., joker, greedy_joker)",
        default: "joker",
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "internal_variable",
    label: "Internal Variable",
    description: "Check the value of an internal variable for this joker",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "variable_name",
        type: "text",
        label: "Variable Name",
        default: "var1",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Value",
        default: 0,
      },
    ],
    category: "Special",
  },
  {
    id: "check_flag",
    label: "Check Flag",
    description: "Check if a specific flag from your mod is true",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Flag Name",
        default: "custom_flag",
      },
    ],
    category: "Special",
  },
  {
    id: "which_tag",
    label: "Check Which Tag Got Added",
    description: "Check Which Tag Got Added",
    applicableTriggers: ["tag_added"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "Equals" },
          { value: "not_equals", label: "Not Equals" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "select",
        label: "Tag Key",
        options: [...TAGS],
        default: "double",
      },
    ],
    category: "Special",
  },
  {
    id: "consumable_count",
    label: "Consumable Count",
    description: "Check how many of a consumable a player has",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "consumable_type",
        type: "select",
        label: "Consumable Type",
        options: () => [
          { value: "any", label: "Any Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "any",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.consumable_type as string;

          if (!selectedSet || selectedSet === "any") {
            return [];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "any", label: "Any from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "any",
      },

      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Consumables",
        min: 0,
        default: 1,
      },
    ],
    category: "Player Resources",
  },
  {
    id: "consumable_type",
    label: "Consumable Type",
    description: "Check the type of consumable being bought or used",
    applicableTriggers: ["card_bought", "consumable_used"],
    params: [
      {
        id: "consumable_type",
        type: "select",
        label: "Consumable Type",
        options: () => [
          { value: "any", label: "Any Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "any",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.consumable_type as string;

          if (!selectedSet || selectedSet === "any") {
            return [];
          }

          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));

            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));

            return [
              { value: "any", label: "Any from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }

          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "any", label: "Any from Set" },
            ...customConsumablesInSet,
          ];
        },
        default: "any",
      },
    ],
    category: "Player Resources",
  },
  {
    id: "hand_level",
    label: "Hand Level",
    description: "Check the level of a poker hand",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "hand_selection",
        type: "select",
        label: "Hand Selection",
        options: [
          { value: "played", label: "Played Hand" },
          { value: "specific", label: "Specific Hand" },
          { value: "any", label: "Any Hand" },
        ],
        default: "any",
      },
      {
        id: "specific_hand",
        type: "select",
        label: "Specific Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "hand_selection",
          values: ["specific"],
        },
      },
      {
        id: "value",
        type: "number",
        label: "Hand Level",
        min: 0,
        default: 1,
      },
    ],
    category: "Game State",
  },
  {
    id: "blind_type",
    label: "Blind Type",
    description: "Check the type of the current blind",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "blind_type",
        type: "select",
        label: "Blind Type",
        options: [
          { value: "small", label: "Small Blind" },
          { value: "big", label: "Big Blind" },
          { value: "boss", label: "Boss Blind" },
        ],
      },
    ],
    category: "Game State",
  },
  {
    id: "boss_blind_type",
    label: "Boss Blind Type",
    description: "Check the type of the current boss blind",
    applicableTriggers: [...GENERIC_TRIGGERS, "blind_selected"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [
          { value: "equals", label: "Equals" },
          { value: "not_equals", label: "Not Equals" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "select",
        label: "Boss Blind",
        options: [...BOSS_BLINDS],
        default: "bl_hook",
      },
    ],
    category: "Game State",
  },
  {
    id: "blind_name",
    label: "Blind Name",
    description: "Check the current blind",
    applicableTriggers: [...GENERIC_TRIGGERS, "blind_selected"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Mode",
        options: [
          { value: "equals", label: "Equals" },
          { value: "not_equals", label: "Not Equals" },
        ],
        default: "equals",
      },
      {
        id: "value",
        type: "select",
        label: "Blind",
        options: [
          { value: "Small Blind", label: "Small Blind" },
          { value: "Big Blind", label: "Big Blind" },
          { value: "The Hook", label: "The Hook" },
          { value: "The Ox", label: "The Ox" },
          { value: "The House", label: "The House" },
          { value: "The Wall", label: "The Wall" },
          { value: "The Wheel", label: "The Wheel" },
          { value: "The Arm", label: "The Arm" },
          { value: "The Club", label: "The Club" },
          { value: "The Fish", label: "The Fish" },
          { value: "The Psychic", label: "The Psychic" },
          { value: "The Goad", label: "The Goad" },
          { value: "The Water", label: "The Water" },
          { value: "The Window", label: "The Window" },
          { value: "The Manacle", label: "The Manacle" },
          { value: "The Eye", label: "The Eye" },
          { value: "The Mouth", label: "The Mouth" },
          { value: "The Plant", label: "The Plant" },
          { value: "The Serpent", label: "The Serpent" },
          { value: "The Pillar", label: "The Pillar" },
          { value: "The Needle", label: "The Needle" },
          { value: "The Head", label: "The Head" },
          { value: "The Tooth", label: "The Tooth" },
          { value: "The Flint", label: "The Flint" },
          { value: "The Mark", label: "The Mark" },
          { value: "Amber Acorn", label: "Amber Acorn" },
          { value: "Verdant Leaf", label: "Verdant Leaf" },
          { value: "Violet Vessel", label: "Violet Vessel" },
          { value: "Crimson Heart", label: "Crimson Heart" },
          { value: "Cerulean Bell", label: "Cerulean Bell" },
        ],
        default: "Small Blind",
      },
    ],
    category: "Game State",
  },
  {
    id: "check_blind_requirements",
    label: "Blind Requirements",
    description:
      "Check what percentage of the blind requirement the current base hand score represents (e.g., 110% means you've exceeded the blind by 10%, values over 100% check if you've exceeded the blind)",
    applicableTriggers: [
      "after_hand_played",
      "before_hand_played",
      "hand_played",
      "card_scored",
      "round_end",
      "hand_discarded",
      "card_discarded",
      "selling_self",
      "card_sold",
      "hand_drawn",
      "first_hand_drawn",
      "game_over",
      "card_destroyed",
    ],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
        default: "greater_equals",
      },
      {
        id: "percentage",
        type: "number",
        label: "Percentage (%)",
        default: 25,
      },
    ],
    category: "Game State",
  },
  {
    id: "voucher_redeemed",
    label: "Voucher Redeemed",
    description: "Check if a specific Voucher was redeemed during the run",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "voucher",
        type: "select",
        label: "Voucher",
        options: [...VOUCHERS()],
        default: "v_overstock_norm",
      },
    ],
    category: "Game State",
  },
  {
    id: "lucky_card_triggered",
    label: "Lucky Card Triggered",
    description:
      "Check if a lucky card's special effect was triggered when scored",
    applicableTriggers: ["card_scored"],
    params: [],
    category: "Card",
  },
  {
    id: "triggered_boss_blind",
    label: "Boss Blind Triggered",
    description: "Check if the current boss blind's effect has been triggered",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [],
    category: "Game State",
  },
  {
    id: "ante_level",
    label: "Ante Level",
    description: "Check the current ante level",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Ante Level",
        min: 1,
        default: 1,
      },
    ],
    category: "Game State",
  },
  {
    id: "first_played_hand",
    label: "First Played Hand",
    description: "Check if this is the first hand played in the current round",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_discarded",
      "after_hand_played",
      "before_hand_played",
    ],
    params: [],
    category: "Game State",
  },
  {
    id: "first_discarded_hand",
    label: "First Discarded Hand",
    description:
      "Check if this is the first hand discarded in the current round",
    applicableTriggers: ["card_discarded", "hand_discarded"],
    params: [],
    category: "Game State",
  },
  {
    id: "system_condition",
    label: "Player OS",
    description: "Check on what Operating System the player is on",
    applicableTriggers: GENERIC_TRIGGERS,
    params: [
      {
        id: "system",
        type: "select",
        label: "OS",
        options: [
          {value: "Windows",label: "Windows"},
          {value: "OS X",label: "OS X"},
          {value: "Linux",label: "Linux"},
          {value: "Android",label: "Android"},
          {value: "iOS",label: "iOS"},
        ],
        default: "Windows",
      },
    ],
    category: "Game State",
  },
  {
    id: "hand_size",
    label: "Hand Size",
    description: "Check the current hand size",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Hand Size",
        default: 8,
      },
    ],
    category: "Player Resources",
  },
  {
    id: "deck_size",
    label: "Deck Size",
    description: "Check the size of the deck",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "size_type",
        type: "select",
        label: "Size Type",
        options: [
          { value: "remaining", label: "Remaining in Deck" },
          { value: "total", label: "Total Deck Size" },
        ],
        default: "remaining",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Number of Cards",
        default: 52,
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "deck_count",
    label: "Deck Count",
    description: "Count cards in your entire deck by property",
    applicableTriggers: [...GENERIC_TRIGGERS, "change_probability"],
    params: [
      {
        id: "property_type",
        type: "select",
        label: "Property Type",
        options: [
          { value: "rank", label: "Rank" },
          { value: "suit", label: "Suit" },
          { value: "enhancement", label: "Enhancement" },
          { value: "seal", label: "Seal" },
          { value: "edition", label: "Edition" },
        ],
        default: "enhancement",
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [{ value: "any", label: "Any Rank" }, ...RANKS],
        showWhen: {
          parameter: "property_type",
          values: ["rank"],
        },
      },
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [
          { value: "any", label: "Any Suit" },
          ...SUIT_GROUPS,
          ...SUITS,
        ],
        showWhen: {
          parameter: "property_type",
          values: ["suit"],
        },
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement",
        options: () => [
          { value: "any", label: "Any Enhancement" },
          { value: "none", label: "No Enhancement" },
          ...ENHANCEMENTS(),
        ],
        showWhen: {
          parameter: "property_type",
          values: ["enhancement"],
        },
      },
      {
        id: "seal",
        type: "select",
        label: "Seal",
        options: () => [
          { value: "any", label: "Any Seal" },
          { value: "none", label: "No Seal" },
          ...SEALS(),
        ],
        showWhen: {
          parameter: "property_type",
          values: ["seal"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [
          { value: "any", label: "Any Edition" },
          { value: "none", label: "No Edition" },
          ...EDITIONS(),
        ],
        showWhen: {
          parameter: "property_type",
          values: ["edition"],
        },
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Count",
        default: 1,
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "probability_succeeded",
    label: "Probability Succeeded",
    description: "Check if the probability succeeded or failed",
    applicableTriggers: ["probability_result"],
    params: [
      {
        id: "status",
        type: "select",
        label: "Status",
        options: [
          { value: "succeeded", label: "Succeeded" },
          { value: "failed", label: "Failed" },
        ],
        default: "succeeded",
      },
    ],
    category: "Probability",
  },
  {
    id: "probability_identifier",
    label: "Detect Probability",
    description: "Check what card caused the probability roll",
    applicableTriggers: ["change_probability", "probability_result"],
    params: [
      {
        id: "mode",
        type: "select",
        label: "Mode",
        options: [
          { value: "vanilla", label: "Vanilla" },
          { value: "custom", label: "Custom" },
        ],
        default: "vanilla",
      },
      {
        id: "property_type",
        type: "select",
        label: "Property Type",
        options: [
          { value: "jokers", label: "Jokers" },
          { value: "consumables", label: "Consumables" },
          { value: "enhancements", label: "Enhancements" },
          { value: "blinds", label: "Blinds" },
        ],
        default: "jokers",
        showWhen: {
          parameter: "mode",
          values: ["vanilla"],
        },
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues) => {
          switch (parentValues?.property_type) {
            case "jokers":
              return [...PROBABILITY_IDENTIFIERS.jokers];
            case "consumables":
              return [...PROBABILITY_IDENTIFIERS.consumables];
            case "enhancements":
              return [...PROBABILITY_IDENTIFIERS.enhancements];
            case "blinds":
              return [...PROBABILITY_IDENTIFIERS.blinds];
            default:
              return [...PROBABILITY_IDENTIFIERS.jokers];
          }
        },
        default: "8ball",
        showWhen: {
          parameter: "mode",
          values: ["vanilla"],
        },
      },
      {
        id: "card_key",
        type: "text",
        label: "Card Key (joker: j_modprefix_key, consumable: c_modprefix_key)",
        showWhen: {
          parameter: "mode",
          values: ["custom"],
        },
      },
    ],
    category: "Probability",
  },
  {
    id: "probability_part_compare",
    label: "Probability Compare",
    description: "Compare the Numerator or the Denominator with a custom value",
    applicableTriggers: ["change_probability", "probability_result"],
    params: [
      {
        id: "part",
        type: "select",
        label: "Numerator or Denominator",
        options: [
          { value: "numerator", label: "Numerator" },
          { value: "denominator", label: "Denominator" },
        ],
        default: "numerator",
      },
      {
        id: "operator",
        type: "select",
        label: "Operator",
        options: [...COMPARISON_OPERATORS],
      },
      {
        id: "value",
        type: "number",
        label: "Second Value",
        default: 1,
      },
    ],
    category: "Probability",
  },
  {
    id: "joker_specific",
    label: "Specific Joker",
    description: "Check the key of the evaluated joker",
    applicableTriggers: ["joker_evaluated"],
    params: [
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key ( [modprefix]_joker )",
        default: "joker",
      },
    ],
    category: "Joker",
  },
  {
    id: "joker_rarity",
    label: "Joker Rarity",
    description: "Check the rarity of the evaluated joker",
    applicableTriggers: ["joker_evaluated"],
    params: [
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [...RARITIES()],
        default: "common",
      },
    ],
    category: "Joker",
  },
  {
    id: "joker_index",
    label: "Joker Position",
    description: "Check the position of the evaluated joker",
    applicableTriggers: ["joker_evaluated"],
    params: [
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
          { value: "specific", label: "Specific Index" },
        ],
        default: "first",
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Index (1-5)",
        default: 1,
        showWhen: {
          parameter: "position",
          values: ["specific"],
        },
      },
    ],
    category: "Joker",
  },
  {
    id: "this_joker_index",
    label: "This Joker Position",
    description: "Check the position of this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
          { value: "specific", label: "Specific Index" },
        ],
        default: "first",
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Index (1-5)",
        default: 1,
        showWhen: {
          parameter: "position",
          values: ["specific"],
        },
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "joker_sticker",
    label: "Joker Sticker",
    description: "Check the stickers of the evaluated joker",
    applicableTriggers: ["joker_evaluated"],
    params: [
      {
        id: "sticker",
        type: "select",
        label: "Sticker",
        options: [...STICKERS.map(({ value, label }) => ({ value, label }))],
        default: "eternal",
      },
    ],
    category: "Joker",
  },
  {
    id: "this_joker_sticker",
    label: "This Joker Sticker",
    description: "Check the stickers of this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "sticker",
        type: "select",
        label: "Sticker",
        options: [...STICKERS.map(({ value, label }) => ({ value, label }))],
        default: "eternal",
      },
    ],
    category: "Deck & Jokers",
  },
  {
    id: "joker_flipped",
    label: "Joker is Flipped",
    description: "Check if the evaluated joker is flipped (facing back)",
    applicableTriggers: ["joker_evaluated"],
    params: [],
    category: "Joker",
  },
  {
    id: "this_joker_flipped",
    label: "This Joker is Flipped",
    description: "Check if this joker is flipped (facing back)",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [],
    category: "Deck & Jokers",
  },
];

export function getConditionTypeById(
  id: string
): ConditionTypeDefinition | undefined {
  return CONDITION_TYPES.find((conditionType) => conditionType.id === id);
}

export function getConditionsForTrigger(
  triggerId: string
): ConditionTypeDefinition[] {
  return CONDITION_TYPES.filter(
    (condition) =>
      condition.applicableTriggers &&
      condition.applicableTriggers.includes(triggerId)
  );
}

```

### src\components\data\Jokers\Effects.ts

```
import { EffectTypeDefinition } from "../../ruleBuilder/types";
import {
  ChartBarIcon,
  BanknotesIcon,
  Cog6ToothIcon,
  ReceiptPercentIcon,
  PencilSquareIcon,
  SparklesIcon,
  CakeIcon,
  UserGroupIcon,
  VariableIcon,
} from "@heroicons/react/24/outline";
import { CategoryDefinition } from "./Triggers";
import { GENERIC_TRIGGERS } from "./Conditions";
import {
  RANKS,
  SUITS,
  ENHANCEMENTS,
  EDITIONS,
  SEALS,
  POKER_HANDS,
  TAROT_CARDS,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  ALL_CONSUMABLES,
  RARITIES,
  CONSUMABLE_TYPES,
  TAGS,
  CUSTOM_CONSUMABLES,
  CONSUMABLE_SETS,
  STICKERS,
  VOUCHERS,
} from "../BalatroUtils";

export const EFFECT_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Scoring",
    icon: ChartBarIcon,
  },
  {
    label: "Economy",
    icon: BanknotesIcon,
  },
  {
    label: "Card Effects",
    icon: PencilSquareIcon,
  },
  {
    label: "Consumables",
    icon: CakeIcon,
  },
  {
    label: "Jokers",
    icon: UserGroupIcon,
  },
  {
    label: "Game Rules",
    icon: Cog6ToothIcon,
  },
  {
    label: "Probability",
    icon: ReceiptPercentIcon,
  },
  {
    label: "Variables",
    icon: VariableIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },  
];

export const EFFECT_TYPES: EffectTypeDefinition[] = [
  {
    id: "add_chips",
    label: "Add Chips",
    description: "Add a flat amount of chips to the hand score",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 10,
        min: 0,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_x_chips",
    label: "Apply xChips",
    description: "Multiply the chips by this value",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Multiplier",
        default: 1.5,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_exp_chips",
    label: "Apply ^Chips (Exponential)",
    description: "Apply exponential chips (echips) - REQUIRES TALISMAN MOD",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Exponential Chips Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_hyper_chips",
    label: "Apply HyperChips",
    description: "Apply (n)^ chips - REQUIRES TALISMAN MOD",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "arrows",
        type: "number",
        label: "Number of Arrows",
        default: 1,
        min: 1
      },
      {
        id: "value",
        type: "number",
        label: "Hyper Chips Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "add_mult",
    label: "Add Mult",
    description: "Add a flat amount of mult to the hand score",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 5,
        min: 0,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_x_mult",
    label: "Apply xMult",
    description: "Multiply the score by this value",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Multiplier",
        default: 1.5,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_exp_mult",
    label: "Apply ^Mult (Exponential)",
    description: "Apply exponential mult (emult) - REQUIRES TALISMAN MOD",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Exponential Mult Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "apply_hyper_mult",
    label: "Apply HyperMult",
    description: "Apply (n)^ mult - REQUIRES TALISMAN MOD",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "arrows",
        type: "number",
        label: "Number of Arrows",
        default: 1,
        min: 1
      },
      {
        id: "value",
        type: "number",
        label: "Hyper Mult Value",
        default: 1.1,
      },
    ],
    category: "Scoring",
  },
  {
    id: "set_dollars",
    label: "Edit Dollars",
    description: "Modify your money balance",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 5,
      },
    ],
    category: "Economy",
  },
  {
    id: "allow_debt",
    label: "Allow Debt",
    description: "Allow the player to go into debt by a specified amount",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "value",
        type: "number",
        label: "Debt Amount",
        default: 20,
      },
    ],
    category: "Economy",
  },
  {
    id: "retrigger_cards",
    label: "Retrigger",
    description: "Retrigger the scored/activated card",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
    ],
    params: [
      {
        id: "repetitions",
        type: "number",
        label: "Repetitions",
        default: 1,
      },
    ],
    category: "Card Effects",
  },
  {
    id: "level_up_hand",
    label: "Level Up Hand",
    description: "Increase the level of a poker hand",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "hand_selection",
        type: "select",
        label: "Hand Selection",
        options: [
          { value: "current", label: "Current Hand (Played/Discarded)" },
          { value: "specific", label: "Specific Hand" },
          { value: "most", label: "Most Played" },
          { value: "least", label: "Least Played" },
          { value: "random", label: "Random Hand" },
        ],
        default: "current",
      },
      {
        id: "specific_hand",
        type: "select",
        label: "Specific Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "hand_selection",
          values: ["specific"],
        },
      },
      {
        id: "value",
        type: "number",
        label: "Levels",
        default: 1,
        min: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_hand",
    label: "Edit Hands",
    description: "Modify the number of hands available",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "duration",
        type: "select",
        label: "Duration",
        options: [
          { value: "permanent", label: "Permanent" },
          { value: "round", label: "This Round" },
        ],
        default: "permanent",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_discard",
    label: "Edit Discards",
    description: "Modify the number of discards available",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "duration",
        type: "select",
        label: "Duration",
        options: [
          { value: "permanent", label: "Permanent" },
          { value: "round", label: "This Round" },
        ],
        default: "permanent",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_hand_size",
    label: "Edit Hand Size",
    description: "Modify the hand size (number of cards you can hold)",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "draw_cards",
    label: "Draw Cards to Hand",
    description: "Draw cards from your deck to your hand",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_destoyed",
      "card_held_in_hand",
      "after_hand_played",
      "before_hand_played",
      "consumable_used",
      "card_discarded",
      "hand_discarded",
    ],
    params: [
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_play_size",
    label: "Edit Play Size",
    description:
      "Modify the Play size (number of cards you can select and Play)",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_discard_size",
    label: "Edit Discard Size",
    description:
      "Modify the Discard size (number of cards you can select and Discard)",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "modify_internal_variable",
    label: "Modify Internal Variable",
    description: "Change an internal variable value for this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "text",
        label: "Variable Name",
        default: "var1",
      },
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "set", label: "Set to value" },
          { value: "increment", label: "Increment by value" },
          { value: "decrement", label: "Decrement by value" },
          { value: "multiply", label: "Multiply by value" },
          { value: "divide", label: "Divide by value" },
        ],
      },
      {
        id: "value",
        type: "number",
        label: "Value",
        default: 1,
      },
    ],
    category: "Variables",
  },
  {
    id: "add_card_to_deck",
    label: "Add Card to Deck",
    description: "Create a new playing card and add it to your deck",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [{ value: "random", label: "Random" }, ...SUITS],
        default: "random",
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [{ value: "random", label: "Random" }, ...RANKS],
        default: "random",
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement",
        options: () => [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...ENHANCEMENTS(),
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal",
        options: () => [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...EDITIONS(),
        ],
        default: "none",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "copy_triggered_card",
    label: "Copy Triggered Card",
    description: "Copy the card that triggered this effect to your deck",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
    ],
    params: [],
    category: "Card Effects",
  },
  {
    id: "copy_played_card",
    label: "Copy Played Card",
    description: "Copy a specific card from the played hand to your deck",
    applicableTriggers: ["hand_played"],
    params: [
      {
        id: "card_index",
        type: "select",
        label: "Position in Hand",
        options: [
          { value: "any", label: "Any Position" },
          { value: "1", label: "1st Card" },
          { value: "2", label: "2nd Card" },
          { value: "3", label: "3rd Card" },
          { value: "4", label: "4th Card" },
          { value: "5", label: "5th Card" },
        ],
        default: "any",
      },
      {
        id: "card_rank",
        type: "select",
        label: "Rank",
        options: [{ value: "any", label: "Any Rank" }, ...RANKS],
        default: "any",
      },
      {
        id: "card_suit",
        type: "select",
        label: "Suit",
        options: [{ value: "any", label: "Any Suit" }, ...SUITS],
        default: "any",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "delete_triggered_card",
    label: "Destroy Triggered Card",
    description: "Destroy the card that triggered this effect",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
    ],
    params: [],
    category: "Card Effects",
  },
  {
    id: "edit_triggered_card",
    label: "Edit Triggered Card",
    description: "Modify the properties of the card that triggered this effect",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
    ],
    params: [
      {
        id: "new_rank",
        type: "select",
        label: "New Rank",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "random", label: "Random" },
          ...RANKS.map((rank) => ({ value: rank.label, label: rank.label })),
        ],
        default: "none",
      },
      {
        id: "new_suit",
        type: "select",
        label: "New Suit",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "random", label: "Random" },
          ...SUITS,
        ],
        default: "none",
      },
      {
        id: "new_enhancement",
        type: "select",
        label: "New Enhancement",
        options: () => [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Enhancement" },
          { value: "random", label: "Random" },
          ...ENHANCEMENTS(),
        ],
        default: "none",
      },
      {
        id: "new_seal",
        type: "select",
        label: "New Seal",
        options: () => [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Seal" },
          { value: "random", label: "Random" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "new_edition",
        type: "select",
        label: "New Edition",
        options: [
          { value: "none", label: "Don't Change" },
          { value: "remove", label: "Remove Edition" },
          { value: "random", label: "Random" },
          ...EDITIONS(),
        ],
        default: "none",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "add_card_to_hand",
    label: "Add Card to Hand",
    description: "Create a new playing card and add it to your hand",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "suit",
        type: "select",
        label: "Suit",
        options: [{ value: "random", label: "Random" }, ...SUITS],
        default: "random",
      },
      {
        id: "rank",
        type: "select",
        label: "Rank",
        options: [{ value: "random", label: "Random" }, ...RANKS],
        default: "random",
      },
      {
        id: "enhancement",
        type: "select",
        label: "Enhancement",
        options: () => [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...ENHANCEMENTS(),
        ],
        default: "none",
      },
      {
        id: "seal",
        type: "select",
        label: "Seal",
        options: () => [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...SEALS(),
        ],
        default: "none",
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "None" },
          { value: "random", label: "Random" },
          ...EDITIONS(),
        ],
        default: "none",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "copy_triggered_card_to_hand",
    label: "Copy Triggered Card to Hand",
    description: "Copy the card that triggered this effect to your hand",
    applicableTriggers: [
      "card_scored",
      "card_discarded",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
    ],
    params: [],
    category: "Card Effects",
  },
  {
    id: "copy_played_card_to_hand",
    label: "Copy Played Card to Hand",
    description: "Copy a specific card from the played hand to your hand",
    applicableTriggers: ["hand_played"],
    params: [
      {
        id: "card_index",
        type: "select",
        label: "Position in Hand",
        options: [
          { value: "any", label: "Any Position" },
          { value: "1", label: "1st Card" },
          { value: "2", label: "2nd Card" },
          { value: "3", label: "3rd Card" },
          { value: "4", label: "4th Card" },
          { value: "5", label: "5th Card" },
        ],
        default: "any",
      },
      {
        id: "card_rank",
        type: "select",
        label: "Rank",
        options: [{ value: "any", label: "Any Rank" }, ...RANKS],
        default: "any",
      },
      {
        id: "card_suit",
        type: "select",
        label: "Suit",
        options: [{ value: "any", label: "Any Suit" }, ...SUITS],
        default: "any",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "set_sell_value",
    label: "Edit Sell Value",
    description: "Modify the sell value of jokers/consumables",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "target",
        type: "select",
        label: "Target",
        options: [
          { value: "specific", label: "Specific Joker" },
          { value: "all_jokers", label: "All Jokers" },
          { value: "all", label: "All Jokers and Consumables" },
        ],
        default: "specific",
      },{
        id: "specific_target",
        type: "select",
        label: "Specific Joker",
        options: [
          { value: "self", label: "This Joker" },
          { value: "right", label: "Joker on my Right" },
          { value: "left", label: "Joker on my Left" },
          { value: "first", label: "Leftmost Joker" },
          { value: "last", label: "Rightmost Joker" },
          { value: "random", label: "Random Joker" },
        ],
        showWhen: {
          parameter: "target",
          values: ["specific"],},
        default: "self",
      },{
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Sell Value Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Economy",
  },
  {
    id: "create_joker",
    label: "Create Joker",
    description:
      "Create a random or specific joker card. For creating jokers from your own mod, it is [modprefix]_[joker_name]. You can find your mod prefix in the mod metadata page.",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "joker_type",
        type: "select",
        label: "Joker Type",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
        ],
        default: "random",
      },
      {
        id: "rarity",
        type: "select",
        label: "Rarity",
        options: () => [
          { value: "random", label: "Any Rarity" },
          ...RARITIES(),
        ],
        default: "random",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key ( [modprefix]_joker )",
        default: "joker",
        showWhen: {
          parameter: "joker_type",
          values: ["specific"],
        },
      },
      {
        id: "pool",
        type: "text",
        label: "Pool Name (optional)",
        default: "",
        showWhen: {
          parameter: "joker_type",
          values: ["random"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition",
        options: [{ value: "none", label: "No Edition" }, ...EDITIONS()],
        default: "none",
      },
      {
        id: "sticker",
        type: "select",
        label: "Sticker for Copy",
        options: [{ value: "none", label: "No Sticker" }, ...STICKERS],
        default: "none",
      },
      {
        id: "ignore_slots",
        type: "select",
        label: "___ Joker Slots",
        options: [
          { value: "respect", label: "Respect" },
          { value: "ignore", label: "Ignore" },
        ],
        default: "respect",
      },
    ],
    category: "Jokers",
  },
  {
    id: "copy_joker",
    label: "Copy Joker",
    description:
      "Copy an existing joker from your collection. For copying jokers from your own mod, it is j_[modprefix]_[joker_name]. You can find your mod prefix in the mod metadata page.",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Selection Method",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
          { value: "position", label: "By Position" },
        ],
        default: "random",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., j_joker, j_greedy_joker)",
        default: "j_joker",
        showWhen: {
          parameter: "selection_method",
          values: ["specific"],
        },
      },
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
          { value: "left", label: "Left of This Joker" },
          { value: "right", label: "Right of This Joker" },
          { value: "specific", label: "Specific Index" },
        ],
        default: "first",
        showWhen: {
          parameter: "selection_method",
          values: ["position"],
        },
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Index (1-5)",
        default: 1,
        showWhen: {
          parameter: "position",
          values: ["specific"],
        },
      },
      {
        id: "edition",
        type: "select",
        label: "Edition for Copy",
        options: [{ value: "none", label: "No Edition" }, ...EDITIONS()],
        default: "none",
      },
      {
        id: "sticker",
        type: "select",
        label: "Sticker for Copy",
        options: [{ value: "none", label: "No Sticker" }, ...STICKERS],
        default: "none",
      },
      {
        id: "ignore_slots",
        type: "select",
        label: "___ Joker Slots",
        options: [
          { value: "respect", label: "Respect" },
          { value: "ignore", label: "Ignore" },
        ],
        default: "respect",
      },
    ],
    category: "Jokers",
  },
  {
    id: "destroy_joker",
    label: "Destroy Joker",
    description:
      "Destroy an existing joker from your collection. For destroying jokers from your own mod, it is j_[modprefix]_[joker_name]. You can find your mod prefix in the mod metadata page.",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Selection Method",
        options: [
          { value: "random", label: "Random Joker" },
          { value: "specific", label: "Specific Joker" },
          { value: "position", label: "By Position" },
        ],
        default: "random",
      },
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key (e.g., j_joker, j_greedy_joker)",
        default: "j_joker",
        showWhen: {
          parameter: "selection_method",
          values: ["specific"],
        },
      },
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
          { value: "left", label: "Left of This Joker" },
          { value: "right", label: "Right of This Joker" },
          { value: "specific", label: "Specific Index" },
        ],
        default: "first",
        showWhen: {
          parameter: "selection_method",
          values: ["position"],
        },
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Index (1-5)",
        default: 1,
        showWhen: {
          parameter: "position",
          values: ["specific"],
        },
      },
      {
        id: "bypass_eternal",
        type: "select",
        label: "Bypass Eternal",
        options: [
          { value: "no", label: "No" },
          { value: "yes", label: "Yes" },
        ],
        default: "no",
      },
      {
        id: "sell_value_multiplier",
        type: "number",
        label: "Sell Value Multiplier (0 = disabled)",
        default: 0,
      },
      {
        id: "variable_name",
        type: "text",
        label: "Variable to Add Sell Value To",
        default: "var1",
      },
    ],
    category: "Jokers",
  },
  {
    id: "unlock_joker",
    label: "Unlock Joker",
    description: "Unlock a locked joker in the collection ",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "joker_key",
        type: "text",
        label: "Joker Key ( [modprefix]_joker )",
        default: "joker",
      },
      {
        id: "discover",
        type: "select",
        label: "Discover the Unlocked Joker",
        options: [
          { value: "true", label: "Discover" },
          { value: "false", label: "Leave Undiscovered" },
        ],
        default: "false",
      },
    ],
    category: "Jokers",
  },
  {
    id: "flip_joker",
    label: "Flip Joker",
    description: "Flip a joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Selection Method",
        options: [
          { value: "all", label: "All Jokers" },
          { value: "random", label: "Random Joker" },
          { value: "self", label: "This Joker" },
          { value: "position", label: "By Position" },
        ],
        default: "all",
      },
      {
        id: "position",
        type: "select",
        label: "Position",
        options: [
          { value: "first", label: "First Joker" },
          { value: "last", label: "Last Joker" },
          { value: "left", label: "Left of This Joker" },
          { value: "right", label: "Right of This Joker" },
          { value: "specific", label: "Specific Index" },
        ],
        default: "first",
        showWhen: {
          parameter: "selection_method",
          values: ["position"],
        },
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Index (1-5)",
        default: 1,
        showWhen: {
          parameter: "position",
          values: ["specific"],
        },
      },
    ],
    category: "Jokers",
  },
  {
    id: "shuffle_jokers",
    label: "Shuffle Jokers",
    description: "Shuffle all jokers",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [],
    category: "Jokers",
  },
  {
    id: "redeem_voucher",
    label: "Redeem Voucher",
    description: "Redeem a specific or random voucher",
    applicableTriggers: [
      ...GENERIC_TRIGGERS.filter((trigger) => {
        return ![
          "card_scored",
          "hand_played",
          "hand_drawn",
          "card_discarded",
          "hand_discarded",
          "first_hand_drawn",
          "after_hand_played",
          "before_hand_played",
          "card_held_in_hand",
          "card_held_in_hand_end_of_round",
        ].includes(trigger); // redeeming a voucher while in blind is buggy adding vouchers to other cards in play etc.
      }),
    ],
    params: [
      {
        id: "voucher_type",
        type: "select",
        label: "Voucher Type",
        options: [
          { value: "random", label: "Random Voucher" },
          { value: "specific", label: "Specific Voucher" },
        ],
        default: "random",
      },
      {
        id: "specific_voucher",
        type: "select",
        label: "Specific Voucher",
        options: [...VOUCHERS()],
        showWhen: {
          parameter: "voucher_type",
          values: ["specific"],
        },
        default: "v_overstock_norm",
      },
    ],
    category: "Consumables",
  },
  {
    id: "create_consumable",
    label: "Create Consumable",
    description:
      "Create consumable cards and add them to your consumables area",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "set",
        type: "select",
        label: "Consumable Set",
        options: () => [
          { value: "random", label: "Random Consumable" },
          ...CONSUMABLE_SETS(),
        ],
        default: "random",
      },{
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: (parentValues: Record<string, unknown>) => {
          const selectedSet = parentValues?.set as string;

          if (!selectedSet || selectedSet === "random") {
            return [{ value: "random", label: "Random from Set" }];
          }
          // Handle vanilla sets
          if (selectedSet === "Tarot") {
            const vanillaCards = TAROT_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Tarot")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }
          if (selectedSet === "Planet") {
            const vanillaCards = PLANET_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Planet")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];
          }
          if (selectedSet === "Spectral") {
            const vanillaCards = SPECTRAL_CARDS.map((card) => ({
              value: card.key,
              label: card.label,
            }));
            const customCards = CUSTOM_CONSUMABLES()
              .filter((consumable) => consumable.set === "Spectral")
              .map((consumable) => ({
                value: consumable.value,
                label: consumable.label,
              }));
            return [
              { value: "random", label: "Random from Set" },
              ...vanillaCards,
              ...customCards,
            ];}
          // Handle custom sets
          const setKey = selectedSet.includes("_")
            ? selectedSet.split("_").slice(1).join("_")
            : selectedSet;

          const customConsumablesInSet = CUSTOM_CONSUMABLES().filter(
            (consumable) =>
              consumable.set === setKey || consumable.set === selectedSet
          );

          return [
            { value: "random", label: "Random from Set" },
            ...customConsumablesInSet,
          ];},
        default: "random",
      },{
        id: "soulable",
        type: "select",
        label: "Soulable",
        options: [
          { value: "true", label: "Yes" },
          { value: "nil", label: "No" },
        ],
        showWhen: {
          parameter: "specific_card",
          values: ["random"],
        },
        default:"nil",
      },{
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "y", label: "No Edition" },
          { value: "n", label: "Negative Edition" },
        ],
        default: "none",
      },
    ],
    category: "Consumables",
  },
  {
    id: "destroy_consumable",
    label: "Destroy Consumable",
    description: "Destroy a consumable card from your collection",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "consumable_type",
        type: "select",
        label: "Consumable Type",
        options: [
          { value: "random", label: "Random Type" },
          ...CONSUMABLE_TYPES,
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: [
          { value: "random", label: "Random Card" },
          ...ALL_CONSUMABLES,
        ],
        showWhen: {
          parameter: "consumable_type",
          values: ["tarot", "planet", "spectral"],
        },
      },
    ],
    category: "Consumables",
  },
  {
    id: "copy_consumable",
    label: "Copy Consumable",
    description: "Copy an existing consumable card from your collection",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "consumable_type",
        type: "select",
        label: "Consumable Type",
        options: [
          { value: "random", label: "Random Type" },
          ...CONSUMABLE_TYPES,
        ],
        default: "random",
      },
      {
        id: "specific_card",
        type: "select",
        label: "Specific Card",
        options: [
          { value: "random", label: "Random Card" },
          ...ALL_CONSUMABLES,
        ],
        showWhen: {
          parameter: "consumable_type",
          values: ["tarot", "planet", "spectral"],
        },
      },
      {
        id: "is_negative",
        type: "select",
        label: "Edition",
        options: [
          { value: "none", label: "No Edition" },
          { value: "negative", label: "Negative Edition" },
        ],
        default: "none",
      },
    ],
    category: "Consumables",
  },
  {
    id: "permanent_bonus",
    label: "Add Permanent Bonus",
    description:
      "Add permanent bonuses to the triggered card (like Hiker joker)",
    applicableTriggers: ["card_scored"],
    params: [
      {
        id: "bonus_type",
        type: "select",
        label: "Bonus Type",
        options: [
          { value: "perma_bonus", label: "Permanent Chips" },
          { value: "perma_mult", label: "Permanent Mult" },
          { value: "perma_x_chips", label: "Permanent X Chips" },
          { value: "perma_x_mult", label: "Permanent X Mult" },
          { value: "perma_h_chips", label: "Permanent Held Chips" },
          { value: "perma_h_mult", label: "Permanent Held Mult" },
          { value: "perma_h_x_chips", label: "Permanent Held X Chips" },
          { value: "perma_h_x_mult", label: "Permanent Held X Mult" },
          { value: "perma_p_dollars", label: "Permanent Dollars (on scoring)" },
          {
            value: "perma_h_dollars",
            label: "Permanent Held Dollars (end of round)",
          },
        ],
        default: "perma_bonus",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Card Effects",
  },
  {
    id: "set_ante",
    label: "Set Ante Level",
    description: "Modify the current ante level",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "set", label: "Set to" },
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
        ],
        default: "set",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "create_tag",
    label: "Create Tag",
    description: "Create a specific or random tag",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "tag_type",
        type: "select",
        label: "Tag Type",
        options: [
          { value: "random", label: "Random Tag" },
          { value: "specific", label: "Specific Tag" },
        ],
        default: "random",
      },
      {
        id: "specific_tag",
        type: "select",
        label: "Specific Tag",
        options: [...TAGS],
        showWhen: {
          parameter: "tag_type",
          values: ["specific"],
        },
      },
    ],
    category: "Consumables",
  },
  {
    id: "destroy_self",
    label: "Destroy Self",
    description: "Destroy this joker",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [{
      id: "animation",
      type: "select",
      label: "Animation",
      options: [
          { value: "start_dissolve", label: "Dissolve" },
          { value: "shatter", label: "Shatter" },
          { value: "explode", label: "Explode" },
        ],
      default : "start_dissolve",},{
      id: "display_message",
      type: "select",
      label: "Show Message",
      options: [
          { value: "y", label: "Yes" },
          { value: "n", label: "No" },
        ],
      default : "n",
    }],
    category: "Jokers",
  },{
    id: "disable_boss_blind",
    label: "Disable Boss Blind",
    description: "Disable the current boss blind, removing its effect",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [],
    category: "Game Rules",
  },
  {
    id: "beat_current_blind",
    label: "Beat Current Blind",
    description: "Instantly beat the current boss blind",
    applicableTriggers: ["after_hand_played"],
    params: [],
    category: "Game Rules",
  },
  {
    id: "modify_blind_requirement",
    label: "Modify Blind Requirement",
    description: "Changes the score requirement of a blind",
    applicableTriggers: [
      "blind_selected",
      "card_scored",
      "hand_played",
      "card_discarded",
      "hand_discarded",
      "card_held_in_hand",
      "joker_evaluated",
    ],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
          { value: "multiply", label: "Multiply" },
          { value: "divide", label: "Divide" },
        ],
        default: "multiply",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 2,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "free_rerolls",
    label: "Free Rerolls",
    description: "Provide free shop rerolls",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "value",
        type: "number",
        label: "Number of Free Rerolls",
        default: 1,
      },
    ],
    category: "Economy",
  },
  {
    id: "edit_consumable_slots",
    label: "Edit Consumable Slots",
    description: "Modify the number of consumable slots available",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_voucher_slots",
    label: "Edit Voucher Slots",
    description: "Modify the number of vouchers available in shop",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "edit_booster_slots",
    label: "Edit Booster Slots",
    description: "Modify the number of booster packs available in shop",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "discount_items",
    label: "Discount Items",
    description: "Reduce the cost of specific shop items",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "discount_type",
        type: "select",
        label: "Discount Type",
        options: [
          { value: "planet", label: "Planet (Cards & Packs)" },
          { value: "tarot", label: "Tarot (Cards & Packs)" },
          { value: "spectral", label: "Spectral (Cards & Packs)" },
          { value: "standard", label: "Standard (Playing Cards & Packs)" },
          { value: "jokers", label: "Jokers" },
          { value: "vouchers", label: "Vouchers" },
          { value: "all_consumables", label: "All Consumables" },
          { value: "all_cards", label: "All Cards" },
          { value: "all_shop_items", label: "All Shop Items" },
        ],
        default: "planet",
      },
      {
        id: "discount_method",
        type: "select",
        label: "Discount Method",
        options: [
          { value: "flat_reduction", label: "Flat Dollar Reduction ($X off)" },
          {
            value: "percentage_reduction",
            label: "Percentage Reduction (X% off)",
          },
          { value: "make_free", label: "Make Completely Free ($0)" },
        ],
        default: "make_free",
      },
      {
        id: "discount_amount",
        type: "number",
        label: "Discount Amount",
        default: 1,
        showWhen: {
          parameter: "discount_method",
          values: ["flat_reduction", "percentage_reduction"],
        },
      },
    ],
    category: "Economy",
  },
  {
    id: "edit_joker_slots",
    label: "Edit Joker Slots",
    description: "Modify the number of joker slots available",
    applicableTriggers: [...GENERIC_TRIGGERS, "passive"],
    params: [
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "add", label: "Add" },
          { value: "subtract", label: "Subtract" },
          { value: "set", label: "Set to" },
        ],
        default: "add",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "balance",
    label: "Balance Chips and Mult",
    description: "Plasma Deck effect",
    applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "joker_evaluated",
      "before_hand_played",
      "after_hand_played",
    ],
    params: [],
    category: "Scoring",
  },{
      id: "swap_chips_mult",
      label: "Swap Chips and Mult",
      description: "Swap the Chips and Mult values",
      applicableTriggers: [
      "hand_played",
      "card_scored",
      "card_held_in_hand",
      "card_held_in_hand_end_of_round",
      "joker_evaluated",
      "before_hand_played",
      "after_hand_played",
    ],
      params: [],
      category: "Scoring",
  },
  {
    id: "change_suit_variable",
    label: "Change Suit Variable",
    description:
      "Change the value of a suit variable to a specific suit or random suit",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "select",
        label: "Suit Variable",
        options: [], // Will be populated dynamically with suit variables
      },
      {
        id: "change_type",
        type: "select",
        label: "Change Type",
        options: [
          { value: "random", label: "Random Suit" },
          { value: "specific", label: "Specific Suit" },
        ],
        default: "random",
      },
      {
        id: "specific_suit",
        type: "select",
        label: "Suit",
        options: [...SUITS],
        showWhen: {
          parameter: "change_type",
          values: ["specific"],
        },
      },
    ],
    category: "Variables",
  },
  {
    id: "reduce_flush_straight_requirements",
    label: "Reduce Flush/Straight Requirements",
    description:
      "Reduce the number of cards required to make Flushes and Straights",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "reduction_value",
        type: "number",
        label: "Reduction Amount",
        default: 1,
      },
    ],
    category: "Game Rules",
  },
  {
    id: "shortcut",
    label: "Shortcut Straights",
    description:
      "Allow gaps in straights (e.g., 2, 4, 6, 8, 10 counts as a straight)",
    applicableTriggers: ["passive"],
    params: [],
    category: "Game Rules",
  },
  {
    id: "showman",
    label: "Allow Duplicate Cards (Showman)",
    description:
      "Joker, Tarot, Planet, and Spectral cards may appear multiple times",
    applicableTriggers: ["passive"],
    params: [],
    category: "Game Rules",
  },
  {
    id: "change_rank_variable",
    label: "Change Rank Variable",
    description:
      "Change the value of a rank variable to a specific rank or random rank",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "select",
        label: "Rank Variable",
        options: [], // Will be populated dynamically with rank variables
      },
      {
        id: "change_type",
        type: "select",
        label: "Change Type",
        options: [
          { value: "random", label: "Random Rank" },
          { value: "specific", label: "Specific Rank" },
        ],
        default: "random",
      },
      {
        id: "specific_rank",
        type: "select",
        label: "Rank",
        options: [...RANKS],
        showWhen: {
          parameter: "change_type",
          values: ["specific"],
        },
      },
    ],
    category: "Variables",
  },
  {
    id: "change_pokerhand_variable",
    label: "Change Poker Hand Variable",
    description:
      "Change the value of a poker hand variable to a specific poker hand or random poker hand",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "variable_name",
        type: "select",
        label: "Poker Hand Variable",
        options: [], // Will be populated dynamically with poker hand variables
      },
      {
        id: "change_type",
        type: "select",
        label: "Change Type",
        options: [
          { value: "random", label: "Random Poker Hand" },
          { value: "specific", label: "Specific Poker Hand" },
          { value: "most_played", label: "Most Played Hand" },
          { value: "least_played", label: "Least Played Hand" },
        ],
        default: "random",
      },
      {
        id: "specific_pokerhand",
        type: "select",
        label: "Poker Hand",
        options: [...POKER_HANDS],
        showWhen: {
          parameter: "change_type",
          values: ["specific"],
        },
      },
    ],
    category: "Variables",
  },
  {
    id: "combine_ranks",
    label: "Rank X Considered as Y",
    description: "Treat specified ranks as a different rank",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "source_rank_type",
        type: "select",
        label: "Source Rank Type",
        options: [
          { value: "specific", label: "Specific Ranks" },
          { value: "face_cards", label: "Face Cards (J, Q, K)" },
          { value: "all", label: "All Ranks" },
        ],
        default: "specific",
      },
      {
        id: "source_ranks",
        type: "text",
        label: "Source Ranks (comma-separated: 2,3,J,K)",
        default: "J,Q,K",
        showWhen: {
          parameter: "source_rank_type",
          values: ["specific"],
        },
      },
      {
        id: "target_rank",
        type: "select",
        label: "Target Rank",
        options: [
          ...RANKS,
          { value: "face_cards", label: "Face Cards (J, Q, K)" },
        ],
        default: "J",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "combine_suits",
    label: "Combine Suits",
    description: "Two suits are considered as each other (bidirectional)",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "suit_1",
        type: "select",
        label: "First Suit",
        options: [...SUITS],
        default: "Spades",
      },
      {
        id: "suit_2",
        type: "select",
        label: "Second Suit",
        options: [...SUITS],
        default: "Hearts",
      },
    ],
    category: "Card Effects",
  },
  {
    id: "splash_effect",
    label: "Every Played Card is Scored (Splash)",
    description: "When a hand is played, every card in it is scored",
    applicableTriggers: ["passive"],
    params: [],
    category: "Special",
  },
  {
    id: "copy_joker_ability",
    label: "Copy Joker Ability",
    description:
      "Copy the calculate function of another joker (like Blueprint/Brainstorm)",
    applicableTriggers: ["passive"],
    params: [
      {
        id: "selection_method",
        type: "select",
        label: "Target Joker",
        options: [
          { value: "right", label: "Joker to the Right" },
          { value: "left", label: "Joker to the Left" },
          { value: "specific", label: "Specific Position" },
        ],
        default: "right",
      },
      {
        id: "specific_index",
        type: "number",
        label: "Joker Position (1-5)",
        default: 1,
        showWhen: {
          parameter: "selection_method",
          values: ["specific"],
        },
      },
    ],
    category: "Jokers",
  },
  {
    id: "prevent_game_over",
    label: "Prevent Game Over",
    description:
      "Prevent the run from ending when game over conditions are met (like Mr. Bones)",
    applicableTriggers: ["game_over"],
    params: [],
    category: "Special",
  },
  {
    id: "force_game_over",
    label: "Force Game Over",
    description: "Forces the run to end (ignores Mr. Bones)",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [],
    category: "Special",
  },
  {
    id: "juice_up_joker",
    label: "Juice Up The Joker",
    description: "Make the joker play a animation",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "mode",
        type: "select",
        label: "Juice Up Mode",
        options: [
          { value: "constant", label: "Constant" },
          { value: "onetime", label: "One-time" },
        ],
        default: "constant",
      },
      {
        id: "scale",
        type: "number",
        label: "Scale",
        min: 0,
        default: 1,
      },
      {
        id: "rotation",
        type: "number",
        label: "Rotation",
        min: 0,
        default: 1,
      },
    ],
    category: "Special",
  },
  {
    id: "juice_up_card",
    label: "Juice Up The Card",
    description: "Make the Card play a animation",
    applicableTriggers: ["card_scored", "card_held_in_hand"],
    params: [
      {
        id: "mode",
        type: "select",
        label: "Juice Up Mode",
        options: [
          { value: "constant", label: "Constant" },
          { value: "onetime", label: "One-time" },
        ],
        default: "constant",
      },
      {
        id: "scale",
        type: "number",
        label: "Scale",
        min: 0,
        default: 1,
      },
      {
        id: "rotation",
        type: "number",
        label: "Rotation",
        min: 0,
        default: 1,
      },
    ],
    category: "Special",
  },
  {
    id: "show_message",
    label: "Show Message",
    description: "Display a custom message with specified color",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "colour",
        type: "select",
        label: "Message Color",
        options: [
          { value: "G.C.WHITE", label: "White" },
          { value: "G.C.RED", label: "Red" },
          { value: "G.C.GREEN", label: "Green" },
          { value: "G.C.BLUE", label: "Blue" },
          { value: "G.C.YELLOW", label: "Yellow" },
          { value: "G.C.PURPLE", label: "Purple" },
          { value: "G.C.ORANGE", label: "Orange" },
          { value: "G.C.BLACK", label: "Black" },
          { value: "G.C.CHIPS", label: "Chips (Blue)" },
          { value: "G.C.MULT", label: "Mult (Red)" },
          { value: "G.C.MONEY", label: "Money (Yellow)" },
        ],
        default: "G.C.WHITE",
      },
    ],
    category: "Special",
  },
  {
    id: "emit_flag",
    label: "Emit Flag",
    description:
      "Emit a custom flag. Flags are global variables that can be set to true or false and checked by any other jokers",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "flag_name",
        type: "text",
        label: "Unique Flag Name",
        default: "custom_flag",
      },
      {
        id: "change",
        type: "select",
        label: "Set Flag to",
        options: [
          { value: "true", label: "True" },
          { value: "false", label: "False" },
          { value: "invert", label: "Invert Current" },
        ],
        default: "true",
      },
      {
      id: "display_message",
      type: "select",
      label: "Show Message",
      options: [
          { value: "y", label: "Yes" },
          { value: "n", label: "No" },
        ],
      default : "n",
    },
    ],
    category: "Special",
  },
  {
    id: "play_sound",
    label: "Play a sound",
    description: "Play a specific sound defined in the Sound Tab",
    applicableTriggers: [...GENERIC_TRIGGERS],
    params: [
      {
        id: "sound_key",
        type: "text",
        label: "Sound Key (modprefix_key)",
        default: "",
      },
    ],
    category: "Special",
  },
  {
    id: "fix_probability",
    label: "Set Probability",
    description: "Set the Numerator or the Denominator of a chance roll",
    applicableTriggers: ["change_probability"],
    params: [
      {
        id: "part",
        type: "select",
        label: "Numerator or Denominator",
        options: [
          { value: "numerator", label: "Numerator" },
          { value: "denominator", label: "Denominator" },
          { value: "both", label: "Both" },
        ],
        default: "numerator",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 1,
        min: 0,
      },
    ],
    category: "Probability",
  },
  {
    id: "mod_probability",
    label: "Modify Probability",
    description: "Modify the Numerator or the Denominator of a chance roll",
    applicableTriggers: ["change_probability"],
    params: [
      {
        id: "part",
        type: "select",
        label: "Numerator or Denominator",
        options: [
          { value: "numerator", label: "Numerator" },
          { value: "denominator", label: "Denominator" },
        ],
        default: "numerator",
      },
      {
        id: "operation",
        type: "select",
        label: "Operation",
        options: [
          { value: "increment", label: "Increment by value" },
          { value: "decrement", label: "Decrement by value" },
          { value: "multiply", label: "Multiply" },
          { value: "divide", label: "Divide" },
        ],
        default: "multiply",
      },
      {
        id: "value",
        type: "number",
        label: "Amount",
        default: 2,
      },
    ],
    category: "Probability",
  },
];

export function getEffectTypeById(
  id: string
): EffectTypeDefinition | undefined {
  return EFFECT_TYPES.find((effectType) => effectType.id === id);
}

export function getEffectsForTrigger(
  triggerId: string
): EffectTypeDefinition[] {
  return EFFECT_TYPES.filter(
    (effect) =>
      effect.applicableTriggers && effect.applicableTriggers.includes(triggerId)
  );
}

```

### src\components\data\Jokers\GameVars.ts

```
import {
  RectangleStackIcon,
  CreditCardIcon,
  SparklesIcon,
  FaceSmileIcon,
  PlayIcon,
  BanknotesIcon,
  ChartBarIcon,
  HandRaisedIcon,
} from "@heroicons/react/24/outline";

export interface GameVariable {
  id: string;
  label: string;
  description: string;
  category: string;
  subcategory?: string;
  code: string;
}

export interface GameVariableSubcategory {
  id: string;
  label: string;
  variables: GameVariable[];
}

export interface GameVariableCategory {
  id: string;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  variables: GameVariable[];
  subcategories?: GameVariableSubcategory[];
}

export const GAME_VARIABLE_CATEGORIES: GameVariableCategory[] = [
  {
    id: "deck",
    label: "Deck & Cards",
    icon: RectangleStackIcon,
    variables: [
      {
        id: "cards_in_deck",
        label: "Cards in Deck",
        description: "Number of cards currently in the deck pile",
        category: "deck",
        code: "#(G.deck and G.deck.cards or {})",
      },
      {
        id: "total_playing_cards",
        label: "Total Playing Cards",
        description: "Total playing cards in the game",
        category: "deck",
        code: "#(G.playing_cards or {})",
      },
      {
        id: "current_hand_size",
        label: "Current Hand Size",
        description: "Current hand size",
        category: "deck",
        code: "(G.hand and G.hand.config.card_limit or 0)",
      },
      {
        id: "cards_removed_from_deck",
        label: "Cards Removed From Deck",
        description: "Number of cards removed from starting deck",
        category: "deck",
        code: "(G.GAME.starting_deck_size - #(G.playing_cards or {}))",
      },
      {
        id: "cards_in_hand",
        label: "Cards in Hand",
        description: "Number of cards currently in hand",
        category: "deck",
        code: "#(G.hand and G.hand.cards or {})",
      },
      {
        id: "cards_in_discard",
        label: "Cards in Discard",
        description: "Number of cards in discard pile",
        category: "deck",
        code: "#(G.discard and G.discard.cards or {})",
      },
    ],
    subcategories: [
      {
        id: "hand_analysis",
        label: "Hand Analysis",
        variables: [
          {
            id: "lowest_rank_in_hand",
            label: "Lowest Rank in Hand",
            description: "Rank value of the lowest card in hand",
            category: "deck",
            subcategory: "hand_analysis",
            code: "(function() local min = 14; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id < min then min = card.base.id end end; return min end)()",
          },
          {
            id: "highest_rank_in_hand",
            label: "Highest Rank in Hand",
            description: "Rank value of the highest card in hand",
            category: "deck",
            subcategory: "hand_analysis",
            code: "(function() local max = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id > max then max = card.base.id end end; return max end)()",
          },
        ],
      },
      {
        id: "deck_composition_ranks",
        label: "Deck Composition - Ranks",
        variables: [
          {
            id: "twos_in_deck",
            label: "2s in Deck",
            description: "Number of 2s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 2 then count = count + 1 end end; return count end)()",
          },
          {
            id: "threes_in_deck",
            label: "3s in Deck",
            description: "Number of 3s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 3 then count = count + 1 end end; return count end)()",
          },
          {
            id: "fours_in_deck",
            label: "4s in Deck",
            description: "Number of 4s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 4 then count = count + 1 end end; return count end)()",
          },
          {
            id: "fives_in_deck",
            label: "5s in Deck",
            description: "Number of 5s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 5 then count = count + 1 end end; return count end)()",
          },
          {
            id: "sixes_in_deck",
            label: "6s in Deck",
            description: "Number of 6s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 6 then count = count + 1 end end; return count end)()",
          },
          {
            id: "sevens_in_deck",
            label: "7s in Deck",
            description: "Number of 7s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 7 then count = count + 1 end end; return count end)()",
          },
          {
            id: "eights_in_deck",
            label: "8s in Deck",
            description: "Number of 8s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 8 then count = count + 1 end end; return count end)()",
          },
          {
            id: "nines_in_deck",
            label: "9s in Deck",
            description: "Number of 9s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 9 then count = count + 1 end end; return count end)()",
          },
          {
            id: "tens_in_deck",
            label: "10s in Deck",
            description: "Number of 10s in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 10 then count = count + 1 end end; return count end)()",
          },
          {
            id: "jacks_in_deck",
            label: "Jacks in Deck",
            description: "Number of Jacks in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 11 then count = count + 1 end end; return count end)()",
          },
          {
            id: "queens_in_deck",
            label: "Queens in Deck",
            description: "Number of Queens in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 12 then count = count + 1 end end; return count end)()",
          },
          {
            id: "kings_in_deck",
            label: "Kings in Deck",
            description: "Number of Kings in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 13 then count = count + 1 end end; return count end)()",
          },
          {
            id: "aces_in_deck",
            label: "Aces in Deck",
            description: "Number of Aces in full deck",
            category: "deck",
            subcategory: "deck_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.id == 14 then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "deck_composition_suits",
        label: "Deck Composition - Suits",
        variables: [
          {
            id: "spades_in_deck",
            label: "Spades in Deck",
            description: "Number of Spades in full deck",
            category: "deck",
            subcategory: "deck_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.suit == 'Spades' then count = count + 1 end end; return count end)()",
          },
          {
            id: "hearts_in_deck",
            label: "Hearts in Deck",
            description: "Number of Hearts in full deck",
            category: "deck",
            subcategory: "deck_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.suit == 'Hearts' then count = count + 1 end end; return count end)()",
          },
          {
            id: "diamonds_in_deck",
            label: "Diamonds in Deck",
            description: "Number of Diamonds in full deck",
            category: "deck",
            subcategory: "deck_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.suit == 'Diamonds' then count = count + 1 end end; return count end)()",
          },
          {
            id: "clubs_in_deck",
            label: "Clubs in Deck",
            description: "Number of Clubs in full deck",
            category: "deck",
            subcategory: "deck_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.base.suit == 'Clubs' then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "deck_composition_enhancements",
        label: "Deck Composition - Enhancements",
        variables: [
          {
            id: "bonus_cards_in_deck",
            label: "Bonus Cards in Deck",
            description: "Number of Bonus cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_bonus') then count = count + 1 end end; return count end)()",
          },
          {
            id: "mult_cards_in_deck",
            label: "Mult Cards in Deck",
            description: "Number of Mult cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_mult') then count = count + 1 end end; return count end)()",
          },
          {
            id: "wild_cards_in_deck",
            label: "Wild Cards in Deck",
            description: "Number of Wild cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_wild') then count = count + 1 end end; return count end)()",
          },
          {
            id: "glass_cards_in_deck",
            label: "Glass Cards in Deck",
            description: "Number of Glass cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_glass') then count = count + 1 end end; return count end)()",
          },
          {
            id: "steel_cards_in_deck",
            label: "Steel Cards in Deck",
            description: "Number of Steel cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_steel') then count = count + 1 end end; return count end)()",
          },
          {
            id: "stone_cards_in_deck",
            label: "Stone Cards in Deck",
            description: "Number of Stone cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_stone') then count = count + 1 end end; return count end)()",
          },
          {
            id: "gold_cards_in_deck",
            label: "Gold Cards in Deck",
            description: "Number of Gold cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_gold') then count = count + 1 end end; return count end)()",
          },
          {
            id: "lucky_cards_in_deck",
            label: "Lucky Cards in Deck",
            description: "Number of Lucky cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if SMODS.has_enhancement(card, 'm_lucky') then count = count + 1 end end; return count end)()",
          },
          {
            id: "enhanced_cards_in_deck",
            label: "Enhanced Cards in Deck",
            description: "Total number of enhanced cards in full deck",
            category: "deck",
            subcategory: "deck_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if next(SMODS.get_enhancements(card)) then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "deck_composition_editions",
        label: "Deck Composition - Editions",
        variables: [
          {
            id: "foil_cards_in_deck",
            label: "Foil Cards in Deck",
            description: "Number of Foil cards in full deck",
            category: "deck",
            subcategory: "deck_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.edition and card.edition.foil then count = count + 1 end end; return count end)()",
          },
          {
            id: "holographic_cards_in_deck",
            label: "Holographic Cards in Deck",
            description: "Number of Holographic cards in full deck",
            category: "deck",
            subcategory: "deck_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.edition and card.edition.holo then count = count + 1 end end; return count end)()",
          },
          {
            id: "polychrome_cards_in_deck",
            label: "Polychrome Cards in Deck",
            description: "Number of Polychrome cards in full deck",
            category: "deck",
            subcategory: "deck_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.edition and card.edition.polychrome then count = count + 1 end end; return count end)()",
          },
          {
            id: "negative_cards_in_deck",
            label: "Negative Cards in Deck",
            description: "Number of Negative cards in full deck",
            category: "deck",
            subcategory: "deck_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.edition and card.edition.negative then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "deck_composition_seals",
        label: "Deck Composition - Seals",
        variables: [
          {
            id: "gold_sealed_cards_in_deck",
            label: "Gold Sealed Cards in Deck",
            description: "Number of Gold sealed cards in full deck",
            category: "deck",
            subcategory: "deck_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.seal == 'Gold' then count = count + 1 end end; return count end)()",
          },
          {
            id: "red_sealed_cards_in_deck",
            label: "Red Sealed Cards in Deck",
            description: "Number of Red sealed cards in full deck",
            category: "deck",
            subcategory: "deck_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.seal == 'Red' then count = count + 1 end end; return count end)()",
          },
          {
            id: "blue_sealed_cards_in_deck",
            label: "Blue Sealed Cards in Deck",
            description: "Number of Blue sealed cards in full deck",
            category: "deck",
            subcategory: "deck_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.seal == 'Blue' then count = count + 1 end end; return count end)()",
          },
          {
            id: "purple_sealed_cards_in_deck",
            label: "Purple Sealed Cards in Deck",
            description: "Number of Purple sealed cards in full deck",
            category: "deck",
            subcategory: "deck_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.playing_cards or {}) do if card.seal == 'Purple' then count = count + 1 end end; return count end)()",
          },
        ],
      },
    ],
  },
  {
    id: "hand",
    label: "Hand",
    icon: HandRaisedIcon,
    variables: [],
    subcategories: [
      {
        id: "hand_composition_ranks",
        label: "Hand Composition - Ranks",
        variables: [
          {
            id: "twos_in_hand",
            label: "2s in Hand",
            description: "Number of 2s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 2 then count = count + 1 end end; return count end)()",
          },
          {
            id: "threes_in_hand",
            label: "3s in Hand",
            description: "Number of 3s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 3 then count = count + 1 end end; return count end)()",
          },
          {
            id: "fours_in_hand",
            label: "4s in Hand",
            description: "Number of 4s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 4 then count = count + 1 end end; return count end)()",
          },
          {
            id: "fives_in_hand",
            label: "5s in Hand",
            description: "Number of 5s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 5 then count = count + 1 end end; return count end)()",
          },
          {
            id: "sixes_in_hand",
            label: "6s in Hand",
            description: "Number of 6s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 6 then count = count + 1 end end; return count end)()",
          },
          {
            id: "sevens_in_hand",
            label: "7s in Hand",
            description: "Number of 7s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 7 then count = count + 1 end end; return count end)()",
          },
          {
            id: "eights_in_hand",
            label: "8s in Hand",
            description: "Number of 8s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 8 then count = count + 1 end end; return count end)()",
          },
          {
            id: "nines_in_hand",
            label: "9s in Hand",
            description: "Number of 9s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 9 then count = count + 1 end end; return count end)()",
          },
          {
            id: "tens_in_hand",
            label: "10s in Hand",
            description: "Number of 10s in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 10 then count = count + 1 end end; return count end)()",
          },
          {
            id: "jacks_in_hand",
            label: "Jacks in Hand",
            description: "Number of Jacks in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 11 then count = count + 1 end end; return count end)()",
          },
          {
            id: "queens_in_hand",
            label: "Queens in Hand",
            description: "Number of Queens in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 12 then count = count + 1 end end; return count end)()",
          },
          {
            id: "kings_in_hand",
            label: "Kings in Hand",
            description: "Number of Kings in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 13 then count = count + 1 end end; return count end)()",
          },
          {
            id: "aces_in_hand",
            label: "Aces in Hand",
            description: "Number of Aces in hand",
            category: "hand",
            subcategory: "hand_composition_ranks",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id == 14 then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "hand_composition_suits",
        label: "Hand Composition - Suits",
        variables: [
          {
            id: "spades_in_hand",
            label: "Spades in Hand",
            description: "Number of Spades in hand",
            category: "hand",
            subcategory: "hand_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.suit == 'Spades' then count = count + 1 end end; return count end)()",
          },
          {
            id: "hearts_in_hand",
            label: "Hearts in Hand",
            description: "Number of Hearts in hand",
            category: "hand",
            subcategory: "hand_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.suit == 'Hearts' then count = count + 1 end end; return count end)()",
          },
          {
            id: "diamonds_in_hand",
            label: "Diamonds in Hand",
            description: "Number of Diamonds in hand",
            category: "hand",
            subcategory: "hand_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.suit == 'Diamonds' then count = count + 1 end end; return count end)()",
          },
          {
            id: "clubs_in_hand",
            label: "Clubs in Hand",
            description: "Number of Clubs in hand",
            category: "hand",
            subcategory: "hand_composition_suits",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.suit == 'Clubs' then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "hand_composition_enhancements",
        label: "Hand Composition - Enhancements",
        variables: [
          {
            id: "bonus_cards_in_hand",
            label: "Bonus Cards in Hand",
            description: "Number of Bonus cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_bonus') then count = count + 1 end end; return count end)()",
          },
          {
            id: "mult_cards_in_hand",
            label: "Mult Cards in Hand",
            description: "Number of Mult cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_mult') then count = count + 1 end end; return count end)()",
          },
          {
            id: "wild_cards_in_hand",
            label: "Wild Cards in Hand",
            description: "Number of Wild cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_wild') then count = count + 1 end end; return count end)()",
          },
          {
            id: "glass_cards_in_hand",
            label: "Glass Cards in Hand",
            description: "Number of Glass cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_glass') then count = count + 1 end end; return count end)()",
          },
          {
            id: "steel_cards_in_hand",
            label: "Steel Cards in Hand",
            description: "Number of Steel cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_steel') then count = count + 1 end end; return count end)()",
          },
          {
            id: "stone_cards_in_hand",
            label: "Stone Cards in Hand",
            description: "Number of Stone cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_stone') then count = count + 1 end end; return count end)()",
          },
          {
            id: "gold_cards_in_hand",
            label: "Gold Cards in Hand",
            description: "Number of Gold cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_gold') then count = count + 1 end end; return count end)()",
          },
          {
            id: "lucky_cards_in_hand",
            label: "Lucky Cards in Hand",
            description: "Number of Lucky cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if SMODS.has_enhancement(card, 'm_lucky') then count = count + 1 end end; return count end)()",
          },
          {
            id: "enhanced_cards_in_hand",
            label: "Enhanced Cards in Hand",
            description: "Total number of enhanced cards in hand",
            category: "hand",
            subcategory: "hand_composition_enhancements",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if next(SMODS.get_enhancements(card)) then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "hand_composition_editions",
        label: "Hand Composition - Editions",
        variables: [
          {
            id: "foil_cards_in_hand",
            label: "Foil Cards in Hand",
            description: "Number of Foil cards in hand",
            category: "hand",
            subcategory: "hand_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.edition and card.edition.foil then count = count + 1 end end; return count end)()",
          },
          {
            id: "holographic_cards_in_hand",
            label: "Holographic Cards in Hand",
            description: "Number of Holographic cards in hand",
            category: "hand",
            subcategory: "hand_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.edition and card.edition.holo then count = count + 1 end end; return count end)()",
          },
          {
            id: "polychrome_cards_in_hand",
            label: "Polychrome Cards in Hand",
            description: "Number of Polychrome cards in hand",
            category: "hand",
            subcategory: "hand_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.edition and card.edition.polychrome then count = count + 1 end end; return count end)()",
          },
          {
            id: "negative_cards_in_hand",
            label: "Negative Cards in Hand",
            description: "Number of Negative cards in hand",
            category: "hand",
            subcategory: "hand_composition_editions",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.edition and card.edition.negative then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "hand_composition_seals",
        label: "Hand Composition - Seals",
        variables: [
          {
            id: "gold_sealed_cards_in_hand",
            label: "Gold Sealed Cards in Hand",
            description: "Number of Gold sealed cards in hand",
            category: "hand",
            subcategory: "hand_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.seal == 'Gold' then count = count + 1 end end; return count end)()",
          },
          {
            id: "red_sealed_cards_in_hand",
            label: "Red Sealed Cards in Hand",
            description: "Number of Red sealed cards in hand",
            category: "hand",
            subcategory: "hand_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.seal == 'Red' then count = count + 1 end end; return count end)()",
          },
          {
            id: "blue_sealed_cards_in_hand",
            label: "Blue Sealed Cards in Hand",
            description: "Number of Blue sealed cards in hand",
            category: "hand",
            subcategory: "hand_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.seal == 'Blue' then count = count + 1 end end; return count end)()",
          },
          {
            id: "purple_sealed_cards_in_hand",
            label: "Purple Sealed Cards in Hand",
            description: "Number of Purple sealed cards in hand",
            category: "hand",
            subcategory: "hand_composition_seals",
            code: "(function() local count = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.seal == 'Purple' then count = count + 1 end end; return count end)()",
          },
        ],
      },
    ],
  },
  {
    id: "consumables",
    label: "Consumables",
    icon: CreditCardIcon,
    variables: [
      {
        id: "consumables_held",
        label: "Consumables Held",
        description: "Number of consumables currently held",
        category: "consumables",
        code: "#(G.consumeables and G.consumeables.cards or {})",
      },
      {
        id: "consumable_slots",
        label: "Consumable Slots",
        description: "Total number of consumable slots available",
        category: "consumables",
        code: "G.consumeables and G.consumeables.config.card_limit or 0",
      },
      {
        id: "free_consumable_slots",
        label: "Free Consumable Slots",
        description: "Number of empty consumable slots",
        category: "consumables",
        code: "(G.consumeables and G.consumeables.config.card_limit or 0 - #(G.consumeables and G.consumeables.cards or {}))",
      },
    ],
    subcategories: [
      {
        id: "consumable_usage",
        label: "Consumable Usage",
        variables: [
          {
            id: "tarot_cards_used",
            label: "Tarot Cards Used",
            description: "Total number of Tarot cards used this run",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.tarot or 0)",
          },
          {
            id: "spectral_cards_used",
            label: "Spectral Cards Used",
            description: "Total number of Spectral cards used this run",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.spectral or 0)",
          },
          {
            id: "planet_cards_used",
            label: "Planet Cards Used",
            description: "Total number of Planet cards used this run",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.planet or 0)",
          },
          {
            id: "unique_tarots_used",
            label: "Unique Tarot Cards Used",
            description: "Number of unique Tarot cards used",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(function() local count = 0; for k, v in pairs(G.GAME.consumeable_usage) do if v.set == 'Tarot' then count = count + 1 end end; return count end)()",
          },
          {
            id: "unique_planets_used",
            label: "Unique Planet Cards Used",
            description: "Number of unique Planet cards used",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(function() local count = 0; for k, v in pairs(G.GAME.consumeable_usage) do if v.set == 'Planet' then count = count + 1 end end; return count end)()",
          },
          {
            id: "unique_spectrals_used",
            label: "Unique Spectral Cards Used",
            description: "Number of unique Spectral cards used",
            category: "consumables",
            subcategory: "consumable_usage",
            code: "(function() local count = 0; for k, v in pairs(G.GAME.consumeable_usage) do if v.set == 'Spectral' then count = count + 1 end end; return count end)()",
          },
        ],
      },
    ],
  },
  {
    id: "jokers",
    label: "Jokers",
    icon: FaceSmileIcon,
    variables: [
      {
        id: "joker_count",
        label: "Joker Count",
        description: "Number of jokers currently held",
        category: "jokers",
        code: "#(G.jokers and G.jokers.cards or {})",
      },
      {
        id: "joker_slots",
        label: "Total Joker Slots",
        description: "Total number of joker slots available",
        category: "jokers",
        code: "G.jokers and G.jokers.config.card_limit or 0",
      },
      {
        id: "free_joker_slots",
        label: "Free Joker Slots",
        description: "Number of empty joker slots",
        category: "jokers",
        code: "((G.jokers and G.jokers.config.card_limit or 0) - #(G.jokers and G.jokers.cards or {}))",
      },
    ],
    subcategories: [
      {
        id: "joker_rarities",
        label: "Jokers by Rarity",
        variables: [
          {
            id: "common_jokers",
            label: "Common Jokers",
            description: "Number of Common rarity jokers owned",
            category: "jokers",
            subcategory: "joker_rarities",
            code: "(function() local count = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do if joker.config.center.rarity == 1 then count = count + 1 end end; return count end)()",
          },
          {
            id: "uncommon_jokers",
            label: "Uncommon Jokers",
            description: "Number of Uncommon rarity jokers owned",
            category: "jokers",
            subcategory: "joker_rarities",
            code: "(function() local count = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do if joker.config.center.rarity == 2 then count = count + 1 end end; return count end)()",
          },
          {
            id: "rare_jokers",
            label: "Rare Jokers",
            description: "Number of Rare rarity jokers owned",
            category: "jokers",
            subcategory: "joker_rarities",
            code: "(function() local count = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do if joker.config.center.rarity == 3 then count = count + 1 end end; return count end)()",
          },
          {
            id: "legendary_jokers",
            label: "Legendary Jokers",
            description: "Number of Legendary rarity jokers owned",
            category: "jokers",
            subcategory: "joker_rarities",
            code: "(function() local count = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do if joker.config.center.rarity == 4 then count = count + 1 end end; return count end)()",
          },
        ],
      },
      {
        id: "joker_economics",
        label: "Joker Economics",
        variables: [
          {
            id: "other_jokers_sell_value",
            label: "Other Jokers Sell Value",
            description: "Combined sell value of all other jokers",
            category: "jokers",
            subcategory: "joker_economics",
            code: "(function() local total = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do if joker ~= card then total = total + joker.sell_cost end end; return total end)()",
          },
          {
            id: "all_jokers_sell_value",
            label: "All Jokers Sell Value",
            description: "Combined sell value of all jokers",
            category: "jokers",
            subcategory: "joker_economics",
            code: "(function() local total = 0; for _, joker in ipairs(G.jokers and G.jokers.cards or {}) do total = total + joker.sell_cost end; return total end)()",
          },
        ],
      },
    ],
  },
  {
    id: "poker_hands",
    label: "Poker Hands",
    icon: PlayIcon,
    variables: [
      {
        id: "current_hand_played_count",
        label: "Current Hand Played Count",
        description: "Times the currently played hand has been played",
        category: "poker_hands",
        code: "G.GAME.hands[context.scoring_name].played",
      },
      {
        id: "total_hand_levels",
        label: "Total Hand Levels",
        description: "Sum of all poker hand levels",
        category: "poker_hands",
        code: "(function() local total = 0; for hand, data in pairs(G.GAME.hands) do if data.level >= to_big(1) then total = total + data.level end end; return total end)()",
      },
      {
        id: "hand_levels_above_one",
        label: "Hand Levels Above One",
        description: "Total levels minus base level for each hand",
        category: "poker_hands",
        code: "(function() local total_levels = 0; local total_hands = 0; for hand, data in pairs(G.GAME.hands) do if data.level >= to_big(1) then total_hands = total_hands + 1; total_levels = total_levels + data.level end end; return total_levels - total_hands end)()",
      },
    ],
    subcategories: [
      {
        id: "hand_play_counts",
        label: "Hand Play Counts",
        variables: [
          {
            id: "high_card_played",
            label: "High Card Played",
            description: "Number of times High Card has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['High Card'].played",
          },
          {
            id: "pair_played",
            label: "Pair Played",
            description: "Number of times Pair has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Pair'].played",
          },
          {
            id: "two_pair_played",
            label: "Two Pair Played",
            description: "Number of times Two Pair has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Two Pair'].played",
          },
          {
            id: "three_of_a_kind_played",
            label: "Three of a Kind Played",
            description: "Number of times Three of a Kind has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Three of a Kind'].played",
          },
          {
            id: "straight_played",
            label: "Straight Played",
            description: "Number of times Straight has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Straight'].played",
          },
          {
            id: "flush_played",
            label: "Flush Played",
            description: "Number of times Flush has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Flush'].played",
          },
          {
            id: "full_house_played",
            label: "Full House Played",
            description: "Number of times Full House has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Full House'].played",
          },
          {
            id: "four_of_a_kind_played",
            label: "Four of a Kind Played",
            description: "Number of times Four of a Kind has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Four of a Kind'].played",
          },
          {
            id: "straight_flush_played",
            label: "Straight Flush Played",
            description: "Number of times Straight Flush has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Straight Flush'].played",
          },
          {
            id: "five_of_a_kind_played",
            label: "Five of a Kind Played",
            description: "Number of times Five of a Kind has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Five of a Kind'].played",
          },
          {
            id: "flush_house_played",
            label: "Flush House Played",
            description: "Number of times Flush House has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Flush House'].played",
          },
          {
            id: "flush_five_played",
            label: "Flush Five Played",
            description: "Number of times Flush Five has been played",
            category: "poker_hands",
            subcategory: "hand_play_counts",
            code: "G.GAME.hands['Flush Five'].played",
          },
        ],
      },
      {
        id: "hand_levels",
        label: "Hand Levels",
        variables: [
          {
            id: "high_card_level",
            label: "High Card Level",
            description: "Current level of High Card",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['High Card'].level",
          },
          {
            id: "pair_level",
            label: "Pair Level",
            description: "Current level of Pair",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Pair'].level",
          },
          {
            id: "two_pair_level",
            label: "Two Pair Level",
            description: "Current level of Two Pair",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Two Pair'].level",
          },
          {
            id: "three_of_a_kind_level",
            label: "Three of a Kind Level",
            description: "Current level of Three of a Kind",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Three of a Kind'].level",
          },
          {
            id: "straight_level",
            label: "Straight Level",
            description: "Current level of Straight",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Straight'].level",
          },
          {
            id: "flush_level",
            label: "Flush Level",
            description: "Current level of Flush",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Flush'].level",
          },
          {
            id: "full_house_level",
            label: "Full House Level",
            description: "Current level of Full House",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Full House'].level",
          },
          {
            id: "four_of_a_kind_level",
            label: "Four of a Kind Level",
            description: "Current level of Four of a Kind",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Four of a Kind'].level",
          },
          {
            id: "straight_flush_level",
            label: "Straight Flush Level",
            description: "Current level of Straight Flush",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Straight Flush'].level",
          },
          {
            id: "five_of_a_kind_level",
            label: "Five of a Kind Level",
            description: "Current level of Five of a Kind",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Five of a Kind'].level",
          },
          {
            id: "flush_house_level",
            label: "Flush House Level",
            description: "Current level of Flush House",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Flush House'].level",
          },
          {
            id: "flush_five_level",
            label: "Flush Five Level",
            description: "Current level of Flush Five",
            category: "poker_hands",
            subcategory: "hand_levels",
            code: "G.GAME.hands['Flush Five'].level",
          },
          {
            id: "most_played_hand_level",
            label: "Most Played Hand Level",
            description: "Level of the most frequently played hand",
            category: "poker_hands",
            subcategory: "hand_analytics",
            code: "(function() local most_played = 0; local most_played_hand = ''; for hand, data in pairs(G.GAME.hands) do if data.played > most_played then most_played = data.played; most_played_hand = hand end end; return most_played_hand ~= '' and G.GAME.hands[most_played_hand].level or 0 end)()",
          },
          {
            id: "least_played_hand_level",
            label: "Least Played Hand Level",
            description: "Level of the least frequently played hand",
            category: "poker_hands",
            subcategory: "hand_analytics",
            code: "(function() local least_played = math.huge; local least_played_hand = ''; for hand, data in pairs(G.GAME.hands) do if data.played < least_played then least_played = data.played; least_played_hand = hand end end; return least_played_hand ~= '' and G.GAME.hands[least_played_hand].level or 0 end)()",
          },
          {
            id: "most_recent_hand_level",
            label: "Most Recent Hand Level",
            description: "Level of the most recently played hand",
            category: "poker_hands",
            subcategory: "hand_analytics",
            code: "(G.GAME.last_hand_played and G.GAME.hands[G.GAME.last_hand_played] and G.GAME.hands[G.GAME.last_hand_played].level or 0)",
          },
        ],
      },
    ],
  },
  {
    id: "game_state",
    label: "Game State",
    icon: ChartBarIcon,
    variables: [
      {
        id: "current_ante",
        label: "Current Ante",
        description: "Current ante level",
        category: "game_state",
        code: "G.GAME.round_resets.ante",
      },
      {
        id: "current_money",
        label: "Current Money",
        description: "Current amount of money",
        category: "game_state",
        code: "G.GAME.dollars",
      },
      {
        id: "hands_remaining",
        label: "Hands Remaining",
        description: "Number of hands left this round",
        category: "game_state",
        code: "G.GAME.current_round.hands_left",
      },
      {
        id: "discards_remaining",
        label: "Discards Remaining",
        description: "Number of discards left this round",
        category: "game_state",
        code: "G.GAME.current_round.discards_left",
      },
      {
        id: "hands_played_this_round",
        label: "Hands Played This Round",
        description: "Number of hands played this round",
        category: "game_state",
        code: "G.GAME.current_round.hands_played",
      },
      {
        id: "discards_used_this_round",
        label: "Discards Used This Round",
        description: "Number of discards used this round",
        category: "game_state",
        code: "G.GAME.current_round.discards_used",
      },
      {
        id: "blinds_skipped",
        label: "Blinds Skipped",
        description: "Total number of blinds skipped this run",
        category: "game_state",
        code: "G.GAME.skips",
      },
      {
        id: "base_hands_per_round",
        label: "Base Hands Per Round",
        description: "Base number of hands per round",
        category: "game_state",
        code: "G.GAME.round_resets.hands",
      },
      {
        id: "base_discards_per_round",
        label: "Base Discards Per Round",
        description: "Base number of discards per round",
        category: "game_state",
        code: "G.GAME.round_resets.discards",
      },
    ],
  },
  {
    id: "money_thresholds",
    label: "Money Thresholds",
    icon: BanknotesIcon,
    variables: [],
    subcategories: [
      {
        id: "money_intervals",
        label: "Money Intervals",
        variables: [
          {
            id: "money_per_5",
            label: "Money  5",
            description: "Current money divided by 5 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 5))",
          },
          {
            id: "money_per_10",
            label: "Money  10",
            description: "Current money divided by 10 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 10))",
          },
          {
            id: "money_per_15",
            label: "Money  15",
            description: "Current money divided by 15 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 15))",
          },
          {
            id: "money_per_20",
            label: "Money  20",
            description: "Current money divided by 20 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 20))",
          },
          {
            id: "money_per_25",
            label: "Money  25",
            description: "Current money divided by 25 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 25))",
          },
          {
            id: "money_per_30",
            label: "Money  30",
            description: "Current money divided by 30 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 30))",
          },
          {
            id: "money_per_40",
            label: "Money  40",
            description: "Current money divided by 40 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 40))",
          },
          {
            id: "money_per_50",
            label: "Money  50",
            description: "Current money divided by 50 (rounded down)",
            category: "money_thresholds",
            subcategory: "money_intervals",
            code: "math.floor(lenient_bignum(G.GAME.dollars / 50))",
          },
        ],
      },
    ],
  },
  {
    id: "special",
    label: "Special",
    icon: SparklesIcon,
    variables: [],
    subcategories: [
      {
        id: "hand_position",
        label: "Hand Position",
        variables: [
          {
            id: "leftmost_card_rank",
            label: "Leftmost Card Rank",
            description: "Rank of the leftmost card in hand",
            category: "special",
            subcategory: "hand_position",
            code: "(G.hand and G.hand.cards[1] and G.hand.cards[1].base.id or 0)",
          },
          {
            id: "rightmost_card_rank",
            label: "Rightmost Card Rank",
            description: "Rank of the rightmost card in hand",
            category: "special",
            subcategory: "hand_position",
            code: "(G.hand and G.hand.cards[#G.hand.cards] and G.hand.cards[#G.hand.cards].base.id or 0)",
          },
          {
            id: "highest_card_mult",
            label: "Highest Card Mult",
            description: "Mult value from the highest rank card in hand",
            category: "special",
            subcategory: "hand_position",
            code: "(function() local max = 0; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id > max then max = card.base.id end end; return max end)()",
          },
          {
            id: "lowest_card_mult",
            label: "Lowest Card Mult",
            description: "Mult value from the lowest rank card in hand",
            category: "special",
            subcategory: "hand_position",
            code: "(function() local min = 14; for _, card in ipairs(G.hand and G.hand.cards or {}) do if card.base.id < min then min = card.base.id end end; return min end)()",
          },
        ],
      },
      {
        id: "time_based",
        label: "Time Based",
        variables: [
          {
            id: "current_seconds",
            label: "Current Seconds",
            description: "Current Seconds (0-59)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).sec',
          },
          {
            id: "current_minutes",
            label: "Current Minutes",
            description: "Current Minutes (0-59)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).min',
          },
          {
            id: "current_hours",
            label: "Current Hours",
            description: "Current Hours (0-23)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).hour',
          },
          {
            id: "current_day",
            label: "Current Day",
            description: "Current Day of the Month (1-31)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).day',
          },
          {
            id: "current_month",
            label: "Current Month",
            description: "Current Month (1-12)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).month',
          },
          {
            id: "current_year",
            label: "Current Year",
            description: "Current Year (how else do i describe this)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).year',
          },
          {
            id: "current_year_day",
            label: "Current Year Day",
            description: "Current day of the Year (1-365)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).yday',
          },
          {
            id: "current_week_day",
            label: "Current Week Day",
            description: "Current day of the Week where 1 is Sunday (1-7)",
            category: "special",
            subcategory: "time_based",
            code: 'os.date("*t", os.time()).wday',
          },
        ],
      },
    ],
  },
];

export const getAllGameVariables = (): GameVariable[] => {
  const allVariables: GameVariable[] = [];

  GAME_VARIABLE_CATEGORIES.forEach((category) => {
    allVariables.push(...category.variables);
    if (category.subcategories) {
      category.subcategories.forEach((subcategory) => {
        allVariables.push(...subcategory.variables);
      });
    }
  });

  return allVariables;
};

export const getGameVariableById = (id: string): GameVariable | undefined => {
  return getAllGameVariables().find((variable) => variable.id === id);
};

export const getGameVariablesByCategory = (
  categoryId: string
): GameVariable[] => {
  const category = GAME_VARIABLE_CATEGORIES.find(
    (cat) => cat.id === categoryId
  );
  return category ? category.variables : [];
};

export const getGameVariablesBySubcategory = (
  categoryId: string,
  subcategoryId: string
): GameVariable[] => {
  const category = GAME_VARIABLE_CATEGORIES.find(
    (cat) => cat.id === categoryId
  );
  if (!category?.subcategories) return [];

  const subcategory = category.subcategories.find(
    (sub) => sub.id === subcategoryId
  );
  return subcategory ? subcategory.variables : [];
};

```

### src\components\data\Jokers\Triggers.ts

```
import { TriggerDefinition } from "../../ruleBuilder/types";
import {
  PlayIcon,
  ClockIcon,
  BanknotesIcon,
  RectangleStackIcon,
  ShoppingCartIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";

export interface CategoryDefinition {
  label: string;
  icon: React.ComponentType<{ className?: string }>;
}

export const TRIGGER_CATEGORIES: CategoryDefinition[] = [
  {
    label: "Gameplay",
    icon: PlayIcon,
  },
  {
    label: "Round Events",
    icon: ClockIcon,
  },
  {
    label: "Economy",
    icon: BanknotesIcon,
  },
  {
    label: "Packs & Consumables",
    icon: RectangleStackIcon,
  },
  {
    label: "Shop Events",
    icon: ShoppingCartIcon,
  },
  {
    label: "Special",
    icon: SparklesIcon,
  },
];

export const TRIGGERS: TriggerDefinition[] = [
  {
    id: "hand_played",
    label: "When a Hand is Played",
    description:
      "Triggers when any hand is played. Use conditions to specify whether to check scoring cards, all played cards, or specific hand types.",
    category: "Gameplay",
  },
  {
    id: "card_scored",
    label: "When a Card is Scored",
    description:
      "Triggers for each individual card during scoring. Use this for card-specific properties like suit, rank, or enhancements.",
    category: "Gameplay",
  },
  {
    id: "card_destroyed",
    label: "When a Card is Destroyed",
    description:
      "Triggers when cards are destroyed (e.g. by Glass Cards breaking, being eaten by jokers, sacrificed by consumables).",
    category: "Special",
  },
  {
    id: "hand_discarded",
    label: "When a Hand is Discarded",
    description:
      "Triggers when the player discards a hand of cards (before the discard happens). Different from 'When a Card is Discarded' which triggers per individual card.",
    category: "Gameplay",
  },
  {
    id: "card_discarded",
    label: "When a Card is Discarded",
    description:
      "Triggers whenever a card is discarded. Use conditions to check properties of the discarded card.",
    category: "Gameplay",
  },
  {
    id: "card_held_in_hand",
    label: "When a Card is Held in Hand",
    description:
      "Triggers for each individual card currently held in your hand. Perfect for effects that scale with specific cards you're holding, like gaining money for each Ace or mult for each face card.",
    category: "Gameplay",
  },
  {
    id: "playing_card_added",
    label: "When Playing Card is Added",
    description:
      "Triggers when playing cards are added to your deck. Perfect for effects that scale with deck size or trigger when specific cards are acquired, like Hologram gaining X Mult when cards are added.",
    category: "Packs & Consumables",
  },
  {
    id: "card_held_in_hand_end_of_round",
    label: "When a Card is Held in Hand at End of Round",
    description:
      "Triggers for each individual card currently held in your hand at the end of the round. Good for effects that mimic Gold Cards or Blue Seals.",
    category: "Round Events",
  },
  {
    id: "after_hand_played",
    label: "When Hand Finishes Scoring",
    description:
      "Triggers after a hand has completely finished scoring, after all cards have been scored and all joker effects have been calculated. Perfect for cleanup effects, resetting variables, or effects that should happen once per hand after everything else.",
    category: "Gameplay",
  },
  {
    id: "before_hand_played",
    label: "Before Hand Starts Scoring",
    description:
      "Triggers before a hand starts the scoring sequence or any jokers have been calculated. Perfect for scaling jokers or effects that should happen once per hand before everything else.",
    category: "Gameplay",
  },
  {
    id: "joker_evaluated",
    label: "When Another Joker is Evaluated",
    description: "Triggers when another joker you own is evaluated (triggered after scoring).",
    category: "Gameplay"
  },
  {
    id: "round_end",
    label: "When the Round Ends",
    description:
      "Triggers at the end of each round, after all hands have been played and the blind is completed. Perfect for gaining money, upgrading the joker, or resetting states.",
    category: "Round Events",
  },
  {
    id: "blind_selected",
    label: "When a Blind is Selected",
    description:
      "Triggers when the player selects a new blind at the start of each ante.",
    category: "Round Events",
  },
  {
    id: "blind_skipped",
    label: "When a Blind is Skipped",
    description: "Triggers when the player chooses to skip a blind.",
    category: "Round Events",
  },
  {
    id: "boss_defeated",
    label: "When a Boss is Defeated",
    description: "Triggers after defeating a boss blind.",
    category: "Round Events",
  },
  {
    id: "tag_added",
    label: "When a Tag is Added",
    description: "Triggers when you obtain a Tag.",
    category: "Round Events",
  },
  {
    id: "selling_self",
    label: "When This Card is Sold",
    description: "Triggers when this specific joker is sold.",
    category: "Economy",
  },
  {
    id: "card_sold",
    label: "When a Card is Sold",
    description:
      "Triggers when any card is sold from your collection or the shop.",
    category: "Economy",
  },
  {
    id: "buying_self",
    label: "When This Card is Bought",
    description: "Triggers when this specific joker is bought.",
    category: "Economy",
  },
  {
    id: "card_bought",
    label: "When a Card is Bought",
    description: "Triggers when any card is bought from the shop.",
    category: "Economy",
  },
  {
    id: "booster_opened",
    label: "When a Booster is Opened",
    description: "Triggers when the player opens a booster pack.",
    category: "Packs & Consumables",
  },
  {
    id: "booster_skipped",
    label: "When a Booster is Skipped",
    description: "Triggers when the player chooses to skip a booster pack.",
    category: "Packs & Consumables",
  },
  {
    id: "shop_reroll",
    label: "When Shop is Rerolled",
    description:
      "Triggers whenever the player rerolls the shop to get new items. Perfect for gaining benefits from spending money or building up values through shop interaction.",
    category: "Economy",
  },
  {
    id: "consumable_used",
    label: "When a Consumable is Used",
    description:
      "Triggers when the player uses a Tarot, Planet, or Spectral card.",
    category: "Packs & Consumables",
  },
  {
    id: "hand_drawn",
    label: "When a Hand is Drawn",
    description: "Triggers when the player draws a new hand of cards.",
    category: "Gameplay",
  },
  {
    id: "first_hand_drawn",
    label: "When First Hand is Drawn",
    description: "Triggers only for the first hand drawn in each round.",
    category: "Gameplay",
  },
  {
    id: "shop_entered",
    label: "When Shop is Entered",
    description: "Triggers when the player enters the shop.",
    category: "Round Events",
  },
  {
    id: "shop_exited",
    label: "When Shop is Exited",
    description: "Triggers when the player exits the shop.",
    category: "Round Events",
  },
  {
    id: "game_over",
    label: "When Game Over",
    description:
      "Triggers when the player would lose the run (game over condition). Perfect for implementing 'save on death' mechanics like Mr. Bones, or effects that should happen when a run ends unsuccessfully.",
    category: "Special",
  },
  {
    id: "change_probability",
    label: "Change Probability",
    description:
      "Change Probability in any way",
    category: "Special",
  },
  {
    id: "probability_result",
    label: "Probability Result",
    description:
      "Check if probability succeeds or fails (look at the probability category in conditions)",
    category: "Special",
  },
  {
    id: "passive",
    label: "Passive (Always Active)",
    description:
      "Permanent effects that modify game rules or state while the joker is in play.",
    category: "Special",
  },
];

// Helper function to get a specific trigger by ID
export function getTriggerById(id: string): TriggerDefinition | undefined {
  return TRIGGERS.find((trigger) => trigger.id === id);
}

```

### src\components\generic\Alert.tsx

```
import React, { useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  CheckCircleIcon,
  ExclamationTriangleIcon,
  XCircleIcon,
} from "@heroicons/react/24/solid";

interface AlertProps {
  isVisible: boolean;
  type: "success" | "warning" | "error";
  title: string;
  content: string;
  duration?: number;
  onClose: () => void;
}

const Alert: React.FC<AlertProps> = ({
  isVisible,
  type,
  title,
  content,
  duration = 4000,
  onClose,
}) => {
  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (isVisible) {
      timer = setTimeout(() => {
        onClose();
      }, duration);
    }

    return () => {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [isVisible, duration, onClose]);

  const getTypeStyles = () => {
    switch (type) {
      case "success":
        return {
          bg: "bg-black-dark",
          border: "border-mint/40",
          icon: <CheckCircleIcon className="h-6 w-6 text-mint" />,
          titleColor: "text-mint",
          contentColor: "text-mint/80",
        };
      case "warning":
        return {
          bg: "bg-black-dark",
          border: "border-balatro-orange/40",
          icon: (
            <ExclamationTriangleIcon className="h-6 w-6 text-balatro-orange" />
          ),
          titleColor: "text-balatro-orange",
          contentColor: "text-balatro-orange/80",
        };
      case "error":
        return {
          bg: "bg-black-dark",
          border: "border-balatro-red/40",
          icon: <XCircleIcon className="h-6 w-6 text-balatro-red" />,
          titleColor: "text-balatro-red",
          contentColor: "text-balatro-red/80",
        };
      default:
        return {
          bg: "bg-black-dark",
          border: "border-mint/40",
          icon: <CheckCircleIcon className="h-6 w-6 text-mint" />,
          titleColor: "text-mint",
          contentColor: "text-mint/80",
        };
    }
  };

  const typeStyles = getTypeStyles();

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ y: -100, opacity: 0 }}
          animate={{ y: 20, opacity: 1 }}
          exit={{ y: -100, opacity: 0 }}
          transition={{
            type: "spring",
            stiffness: 300,
            damping: 30,
          }}
          className="fixed top-0 left-1/2 transform -translate-x-1/2 z-[9999] font-lexend"
        >
          <div
            className={`
              ${typeStyles.bg} ${typeStyles.border}
              border-2 rounded-xl shadow-2xl
              p-4 min-w-80 max-w-md
            `}
          >
            <div className="flex items-start gap-3">
              <div className="flex-shrink-0 mt-0.5">{typeStyles.icon}</div>
              <div className="flex-1 min-w-0">
                <h4
                  className={`${typeStyles.titleColor} font-medium text-sm tracking-wide mb-1`}
                >
                  {title}
                </h4>
                <p
                  className={`${typeStyles.contentColor} text-sm leading-relaxed`}
                >
                  {content}
                </p>
              </div>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default Alert;

```

### src\components\generic\balatroTextFormatter.tsx

```
/* eslint-disable react-refresh/only-export-components */
import React from "react";

interface ParsedSegment {
  text: string;
  textColor?: string;
  backgroundColor?: string;
  scale?: number;
  motion?: number;
  tooltip?: string;
  isMultiplier?: boolean;
  stripWhitespace?: boolean;
}

interface StyleState {
  textColor?: string;
  backgroundColor?: string;
  scale?: number;
  motion?: number;
  tooltip?: string;
  isMultiplier?: boolean;
  stripWhitespace?: boolean;
}

const COLOR_MAP: Record<string, string> = {
  white: "text-balatro-white",
  blue: "text-balatro-blue",
  red: "text-balatro-red",
  orange: "text-balatro-attention",
  green: "text-balatro-green",
  purple: "text-balatro-purple",
  attention: "text-balatro-attention",
  chips: "text-balatro-chips",
  mult: "text-balatro-mult",
  money: "text-balatro-money",
  gold: "text-balatro-gold-new",
  black: "text-balatro-black",
  inactive: "text-balatro-grey",
  spades: "text-balatro-spades",
  spade: "text-balatro-spades",
  hearts: "text-balatro-hearts",
  heart: "text-balatro-hearts",
  clubs: "text-balatro-clubs",
  club: "text-balatro-clubs",
  diamonds: "text-balatro-diamonds",
  diamond: "text-balatro-diamonds",
  tarot: "text-balatro-purple",
  planet: "text-balatro-planet",
  spectral: "text-balatro-spectral",
  common: "text-balatro-common",
  uncommon: "text-balatro-uncommon",
  rare: "text-balatro-rare",
  legendary: "text-balatro-legendary",
  enhanced: "text-balatro-enhanced-new",
  default: "text-balatro-default",
  edition: "text-rainbow",
  dark_edition: "text-balatro-dark-edition",
};

const BG_COLOR_MAP: Record<string, string> = {
  white: "bg-white-lighter",
  blue: "bg-balatro-blue",
  red: "bg-balatro-red",
  orange: "bg-balatro-attention",
  green: "bg-balatro-green",
  purple: "bg-balatro-purple",
  attention: "bg-balatro-attention",
  chips: "bg-balatro-chips",
  mult: "bg-balatro-mult",
  money: "bg-balatro-money",
  gold: "bg-balatro-gold-new",
  black: "bg-balatro-black",
  spades: "text-balatro-spades",
  spade: "text-balatro-spades",
  hearts: "text-balatro-hearts",
  heart: "text-balatro-hearts",
  clubs: "text-balatro-clubs",
  club: "text-balatro-clubs",
  diamonds: "text-balatro-diamonds",
  diamond: "text-balatro-diamonds",
  tarot: "bg-balatro-purple",
  planet: "bg-balatro-planet",
  spectral: "bg-balatro-spectral",
  common: "bg-balatro-common",
  uncommon: "bg-balatro-uncommon",
  rare: "bg-balatro-rare",
  legendary: "bg-balatro-legendary",
  enhanced: "bg-balatro-enhanced-new",
  default: "bg-balatro-default",
  edition: "bg-rainbow",
  dark_edition: "bg-dark-rainbow",
};

export const parseBalatroText = (
  text: string,
  locVars?: { colours?: string[]; vars?: (string | number)[] }
): ParsedSegment[] => {
  const segments: ParsedSegment[] = [];

  if (locVars && locVars.vars) {
    text = text.replace(/#(\d+)#/g, (match, varIndex) => {
      const index = parseInt(varIndex, 10) - 1;
      if (locVars.vars && index >= 0 && index < locVars.vars.length) {
        return String(locVars.vars[index]);
      }
      return match;
    });
  }

  text = text.replace(/\[s\]/g, "\n");

  const parts = text.split(/(\{[^}]*\})/);
  let currentStyle: StyleState = {};

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    if (part.startsWith("{") && part.endsWith("}")) {
      const modifiers = part.slice(1, -1);

      if (modifiers === "") {
        currentStyle = {};
        continue;
      }

      const newStyle: StyleState = {};
      const modifierList = modifiers.split(",");

      for (const mod of modifierList) {
        const [type, value] = mod.split(":");

        switch (type) {
          case "C":
            newStyle.textColor = COLOR_MAP[value] || "text-white-lighter";
            break;
          case "X":
            newStyle.backgroundColor = BG_COLOR_MAP[value] || "bg-black";
            newStyle.stripWhitespace = true;
            if (value === "mult" || value === "chips") {
              newStyle.isMultiplier = true;
            }
            break;
          case "V":
            if (locVars?.colours && locVars.colours[parseInt(value) - 1]) {
              const color = locVars.colours[parseInt(value) - 1];
              if (typeof color === "string" && color.startsWith("#")) {
                newStyle.textColor = `text-[${color}]`;
              }
            }
            break;
          case "B":
            if (locVars?.colours && locVars.colours[parseInt(value) - 1]) {
              const color = locVars.colours[parseInt(value) - 1];
              if (typeof color === "string" && color.startsWith("#")) {
                newStyle.backgroundColor = `bg-[${color}]`;
              }
            }
            break;
          case "E":
            newStyle.motion = parseInt(value);
            break;
          case "T":
            newStyle.tooltip = value;
            break;
          case "s":
            newStyle.scale = parseFloat(value);
            break;
        }
      }

      currentStyle = newStyle;
    } else if (part) {
      let processedText = part;

      if (currentStyle.stripWhitespace) {
        processedText = processedText.replace(/\s/g, "");
      }

      if (processedText) {
        segments.push({
          text: processedText,
          ...currentStyle,
        });
      }
    }
  }

  return segments;
};

interface BalatroTextProps {
  text: string;
  locVars?: { colours?: string[] };
  className?: string;
  noWrap?: boolean;
}

export const BalatroText: React.FC<BalatroTextProps> = ({
  text,
  locVars,
  className = "",
  noWrap = false,
}) => {
  const segments = parseBalatroText(text, locVars);

  const wrapperClass = noWrap ? "whitespace-nowrap" : "";

  return (
    <span className={`${className} ${wrapperClass}`}>
      {segments.map((segment, index) => {
        let classes = segment.textColor || "";

        if (segment.backgroundColor) {
          classes += ` ${segment.backgroundColor} px-1 rounded`;
        }

        if (segment.motion === 1) {
          classes += " animate-float";
        } else if (segment.motion === 2) {
          classes += " animate-bump";
        }

        const inlineStyle: React.CSSProperties = {};
        if (segment.scale && segment.scale !== 1) {
          inlineStyle.fontSize = `${segment.scale}em`;
        }

        let displayText = segment.text;
        if (segment.isMultiplier && segment.text.match(/^[X]?\d/)) {
          displayText = segment.text.replace(/^X?/, "");
        }

        if (displayText.includes("\n")) {
          return (
            <span key={index}>
              {displayText.split("\n").map((line, lineIndex) => (
                <React.Fragment key={lineIndex}>
                  {lineIndex > 0 && <br />}
                  <span className={classes.trim()} style={inlineStyle}>
                    {line}
                  </span>
                </React.Fragment>
              ))}
            </span>
          );
        }

        const content = (
          <span className={classes.trim()} style={inlineStyle}>
            {displayText}
          </span>
        );

        if (segment.tooltip) {
          return (
            <span key={index} className="relative group cursor-help">
              {content}
              <span className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-black-darker border border-black-lighter rounded text-xs text-white-light whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-50">
                {segment.tooltip}
              </span>
            </span>
          );
        }

        return <span key={index}>{content}</span>;
      })}
    </span>
  );
};

export const formatBalatroText = (
  text: string,
  locVars?: { colours?: string[] }
): string => {
  const segments = parseBalatroText(text, locVars);

  return segments
    .map((segment) => {
      let html = segment.text;

      if (segment.textColor) {
        html = `<span class="${segment.textColor}">${html}</span>`;
      }

      if (segment.backgroundColor) {
        const bgClass = segment.backgroundColor;
        const textClass = segment.textColor || "text-white-lighter";
        html = `<span class="${bgClass} ${textClass} px-1 rounded">${html}</span>`;
      }

      if (segment.scale && segment.scale !== 1) {
        html = `<span style="font-size: ${segment.scale}em;">${html}</span>`;
      }

      if (segment.isMultiplier && html.match(/^[X]?\d/)) {
        html = html.replace(/^X?/, "");
      }

      return html;
    })
    .join("");
};

export const applyAutoFormatting = (
  text: string,
  lastFormattedText: string,
  autoFormatEnabled: boolean = true,
  includeRarityFormatting: boolean = false
): { formatted: string; hasChanges: boolean } => {
  if (!autoFormatEnabled || text === lastFormattedText) {
    return { formatted: text, hasChanges: false };
  }

  let formatted = text;
  const words = text.split(/(\s+)/);
  let hasChanges = false;

  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    if (!word || word.match(/^\s+$/)) continue;

    const lowerWord = word.toLowerCase();

    if (lowerWord.match(/^(wild|steel|glass|gold|lucky|stone|bonus)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:attention}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(chips?|dollars?|mult)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = capitalizedWord;
      hasChanges = true;
    } else if (includeRarityFormatting && lowerWord.match(/^(common)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:common}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (includeRarityFormatting && lowerWord.match(/^(uncommon)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:uncommon}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (includeRarityFormatting && lowerWord.match(/^(rare)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:rare}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (includeRarityFormatting && lowerWord.match(/^(legendary)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:legendary}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(tarot)$/)) {
      words[i] = `{C:tarot}${word}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(spectral)$/)) {
      words[i] = `{C:spectral}${word}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(planet)$/)) {
      words[i] = `{C:planet}${word}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(enhanced?|enhancement)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:enhanced}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (lowerWord.match(/^(edition)$/)) {
      const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
      words[i] = `{C:dark_edition}${capitalizedWord}{}`;
      hasChanges = true;
    } else if (word.match(/^-\d+(\.\d+)?$/)) {
      words[i] = `{C:red}${word}{}`;
      hasChanges = true;
    }

    if (i < words.length - 2) {
      const nextSpace = words[i + 1];
      const nextWord = words[i + 2];

      if (
        nextSpace &&
        nextSpace.match(/^\s+$/) &&
        nextWord &&
        nextWord.toLowerCase() === "seal"
      ) {
        if (lowerWord.match(/^(red|blue|purple|gold)$/)) {
          const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1);
          const capitalizedSeal =
            nextWord.charAt(0).toUpperCase() + nextWord.slice(1);
          words[i] = `{C:attention}${capitalizedWord}{}`;
          words[i + 2] = capitalizedSeal;
          hasChanges = true;
        }
      }
    }

    if (i >= 2) {
      const prevSuit = words[i - 2];
      const prevSpace = words[i - 1];

      if (prevSuit && prevSpace && prevSpace.match(/^\s+$/)) {
        const lowerSuit = prevSuit.toLowerCase();
        if (lowerSuit.match(/^(hearts?|spades?|clubs?|diamonds?)$/)) {
          let suitName: string;
          if (lowerSuit.match(/^hearts?$/)) suitName = "hearts";
          else if (lowerSuit.match(/^spades?$/)) suitName = "spades";
          else if (lowerSuit.match(/^clubs?$/)) suitName = "clubs";
          else if (lowerSuit.match(/^diamonds?$/)) suitName = "diamonds";
          else suitName = lowerSuit;

          const capitalizedSuit =
            prevSuit.charAt(0).toUpperCase() + prevSuit.slice(1);
          words[i - 2] = `{C:${suitName}}${capitalizedSuit}{}`;
          hasChanges = true;
        }
      }
    }

    if (i >= 4) {
      const prevNumber = words[i - 4];
      const prevSpace = words[i - 3];
      const contextWord = words[i - 2];
      const currentSpace = words[i - 1];

      if (
        prevNumber &&
        prevNumber.match(/^\+\d+(\.\d+)?$/) &&
        prevSpace &&
        prevSpace.match(/^\s+$/) &&
        contextWord &&
        currentSpace &&
        currentSpace.match(/^\s+$/)
      ) {
        const contextLower = contextWord.toLowerCase();

        if (contextLower.includes("chip")) {
          words[i - 4] = `{C:blue}${prevNumber}{}`;
          hasChanges = true;
        } else if (contextLower.includes("mult")) {
          words[i - 4] = `{C:red}${prevNumber}{}`;
          hasChanges = true;
        } else if (contextLower.includes("dollar")) {
          words[i - 4] = `{C:money}${prevNumber}{}`;
          hasChanges = true;
        } else {
          words[i - 4] = `{C:attention}${prevNumber}{}`;
          hasChanges = true;
        }
      }
    }

    if (i >= 4) {
      const prevXNumber = words[i - 4];
      const prevSpace = words[i - 3];
      const contextWord = words[i - 2];
      const currentSpace = words[i - 1];

      if (
        prevXNumber &&
        prevXNumber.match(/^x(\d*\.?\d*)$/i) &&
        prevSpace &&
        prevSpace.match(/^\s+$/) &&
        contextWord &&
        contextWord.toLowerCase().includes("mult") &&
        currentSpace &&
        currentSpace.match(/^\s+$/)
      ) {
        const match = prevXNumber.match(/^x(\d*\.?\d*)$/i);
        if (match) {
          words[i - 4] = `{X:red,C:white}X${match[1]}{}`;
          hasChanges = true;
        }
      }
    }
  }

  if (hasChanges) {
    formatted = words.join("");
  }

  return { formatted, hasChanges };
};

```

### src\components\generic\Button.tsx

```
import React, { ButtonHTMLAttributes } from "react";

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "danger";
  size?: "sm" | "md" | "lg";
  fullWidth?: boolean;
  className?: string;
  icon?: React.ReactNode;
  height?: string;
  width?: string;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = "primary",
  size = "md",
  fullWidth = false,
  className = "",
  disabled = false,
  icon,
  height,
  width,
  ...props
}) => {
  const baseStyles =
    "relative tracking-widest focus:outline-none transition-colors duration-200 font-lexend rounded-lg";

  // Check if it's an icon-only button
  const isIconOnly = icon && !children;

  // Adjust size styles for icon-only buttons
  const sizeStyles = {
    sm: isIconOnly ? "p-1 text-sm border-2" : "px-3 py-1 text-sm border-2",
    md: isIconOnly ? "p-2 text-base border-3" : "px-4 py-2 text-base border-3",
    lg: isIconOnly ? "p-3 text-lg border-3" : "px-6 py-3 text-lg border-3",
  }[size];

  const variantStyles = {
    primary:
      "bg-black-dark text-mint-light border-mint hover:text-mint-lighter hover:border-mint-lighter transition-colors",
    secondary:
      "bg-black-dark text-white-light border-black-lighter hover:bg-black-lighter",
    danger:
      "bg-black-darker text-balatro-red border-balatro-redshadow hover:bg-balatro-redshadow hover:border-balatro-red hover:text-white-light",
  }[variant];

  const disabledStyles = disabled
    ? "opacity-50 cursor-not-allowed hover:bg-mint"
    : "cursor-pointer";

  const widthStyle = fullWidth ? "w-full" : width ? "" : "";

  // Custom inline styles for height and width
  const customStyles: React.CSSProperties = {};
  if (height) {
    customStyles["height"] = height;
  }
  if (width && !fullWidth) {
    customStyles["width"] = width;
  }

  return (
    <button
      className={`${baseStyles} ${sizeStyles} ${variantStyles} ${disabledStyles} ${widthStyle} ${className} flex items-center justify-center`}
      style={customStyles}
      disabled={disabled}
      {...props}
    >
      {icon && <span className={isIconOnly ? "" : "mr-2"}>{icon}</span>}
      {children && <span>{children}</span>}
    </button>
  );
};

export default Button;

```

### src\components\generic\Checkbox.tsx

```
import React from "react";

interface CheckboxProps {
  id: string;
  label: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  className?: string;
  labelClassName?: string;
  disabled?: boolean;
}

const Checkbox: React.FC<CheckboxProps> = ({
  id,
  label,
  checked,
  onChange,
  className = "",
  labelClassName = "",
  disabled = false,
}) => {
  return (
    <div className={`flex items-center select-none ${className}`}>
      <input
        type="checkbox"
        id={id}
        checked={checked}
        disabled={disabled}
        onChange={(e) => onChange(e.target.checked)}
        className={`mr-2 h-5 w-5 rounded border-black-lighter accent-mint ${
          disabled ? "cursor-not-allowed opacity-50" : "cursor-pointer"
        }`}
      />
      <label
        htmlFor={id}
        className={`text-white ${
          disabled ? "cursor-not-allowed opacity-50" : "cursor-pointer"
        } ${labelClassName}`}
      >
        {label}
      </label>
    </div>
  );
};

export default Checkbox;

```

### src\components\generic\ConfirmationPopup.tsx

```
import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  CheckCircleIcon,
  ExclamationTriangleIcon,
  TrashIcon,
  QuestionMarkCircleIcon,
} from "@heroicons/react/24/solid";
import Button from "./Button";

interface ConfirmationPopupProps {
  isVisible: boolean;
  type?: "default" | "warning" | "danger" | "success";
  title: string;
  description: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel: () => void;
  confirmVariant?: "primary" | "secondary" | "danger";
  icon?: React.ReactNode;
}

const ConfirmationPopup: React.FC<ConfirmationPopupProps> = ({
  isVisible,
  type = "default",
  title,
  description,
  confirmText = "Confirm",
  cancelText = "Cancel",
  onConfirm,
  onCancel,
  confirmVariant,
  icon,
}) => {
  const getTypeStyles = () => {
    switch (type) {
      case "danger":
        return {
          bg: "bg-black-darker",
          border: "border-black",
          icon: icon || <TrashIcon className="h-6 w-6 text-balatro-red" />,
          titleColor: "text-balatro-red",
          contentColor: "text-white-dark",
          defaultConfirmVariant: "danger" as const,
        };
      case "warning":
        return {
          bg: "bg-black-darker",
          border: "border-black",
          icon: icon || (
            <ExclamationTriangleIcon className="h-6 w-6 text-balatro-orange" />
          ),
          titleColor: "text-balatro-orange",
          contentColor: "text-balatro-orange/80",
          defaultConfirmVariant: "primary" as const,
        };
      case "success":
        return {
          bg: "bg-black-darker",
          border: "border-black",
          icon: icon || <CheckCircleIcon className="h-6 w-6 text-mint" />,
          titleColor: "text-mint",
          contentColor: "text-mint/80",
          defaultConfirmVariant: "primary" as const,
        };
      default:
        return {
          bg: "bg-black-darker",
          border: "border-black",
          icon: icon || (
            <QuestionMarkCircleIcon className="h-6 w-6 text-balatro-blue" />
          ),
          titleColor: "text-balatro-blue",
          contentColor: "text-balatro-blue/80",
          defaultConfirmVariant: "primary" as const,
        };
    }
  };

  const typeStyles = getTypeStyles();
  const finalConfirmVariant =
    confirmVariant || typeStyles.defaultConfirmVariant;

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onCancel();
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
          className="fixed inset-0 bg-black-darker/60 backdrop-blur-sm flex items-center justify-center z-[9999] font-lexend p-4"
          onClick={handleBackdropClick}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.9, opacity: 0, y: 20 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 30,
            }}
            className={`
              ${typeStyles.bg} ${typeStyles.border}
              backdrop-blur-md border-2 rounded-xl shadow-2xl
              p-6 min-w-96 max-w-md w-full
            `}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="gap-4 mb-6">
              <div className="flex justify-center">{typeStyles.icon}</div>
              <div className="mt-6">
                <h3
                  className={`${typeStyles.titleColor} text-xl text-center tracking-widest mb-4`}
                >
                  {title}
                </h3>
                <p
                  className={`${typeStyles.contentColor} text-center font-medium leading-relaxed`}
                >
                  {description}
                </p>
              </div>
            </div>

            <div className="py-2 px-4">
              <Button
                variant="secondary"
                onClick={onCancel}
                size="md"
                className="w-full mb-6"
              >
                {cancelText}
              </Button>
              <Button
                variant={finalConfirmVariant}
                onClick={onConfirm}
                size="md"
                className="w-full"
              >
                {confirmText}
              </Button>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ConfirmationPopup;

```

### src\components\generic\DonationNotification.tsx

```
import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import { HeartIcon } from "@heroicons/react/24/outline";
import Button from "./Button";

interface DonationNotificationProps {
  isVisible: boolean;
  onClose: () => void;
  onDonate: () => void;
  onDismissTemporarily: () => void;
}

const DonationNotification: React.FC<DonationNotificationProps> = ({
  isVisible,
  onDonate,
  onDismissTemporarily,
}) => {
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ x: 400, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          exit={{ x: 400, opacity: 0 }}
          transition={{
            type: "spring",
            stiffness: 300,
            damping: 30,
          }}
          className="fixed top-6 right-6 z-[9998] font-lexend"
        >
          <div className=" max-w-xs">
            <div className="mb-3">
              <h4 className="text-white-light font-medium text-sm text-center tracking-wide">
                Enjoying Joker Forge?
              </h4>
            </div>

            <div className="flex flex-col gap-2">
              <Button
                variant="primary"
                size="sm"
                onClick={onDonate}
                className="w-full"
                icon={<HeartIcon className="h-4 w-4" />}
              >
                Support on Ko-fi
              </Button>

              <button
                onClick={onDismissTemporarily}
                className="text-white-darker hover:text-white-light text-xs text-center py-1 transition-colors cursor-pointer"
              >
                Don't show again
              </button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default DonationNotification;

```

### src\components\generic\ErrorBoundary.tsx

```
import React, { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-black-darker flex items-center justify-center p-4">
          <div className="bg-black-dark border border-red-500 rounded-lg p-6 max-w-md w-full">
            <h2 className="text-red-500 text-xl font-bold mb-4">
              Something went wrong (whoops)
            </h2>
            <p className="text-white-light mb-4">
              An unexpected error occurred. Please refresh the page and try
              again. If the problem persists, please make an issue on the{" "}
              <a
                href="https://github.com/your-repo/issues"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-500 underline"
              >
                GitHub
              </a>{" "}
              with the error details.
            </p>
            <details className="mb-4">
              <summary className="text-white-dark cursor-pointer">
                Error details
              </summary>
              <pre className="text-xs text-white-darker mt-2 overflow-auto">
                {this.state.error?.message}
              </pre>
            </details>
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-red-700 hover:bg-red-600 text-white-lighter cursor-pointer font-medium py-2 px-4 rounded transition-colors"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

```

### src\components\generic\InfoDescriptionBox.tsx

```
import React from "react";
import {
  ArrowPathIcon,
  SparklesIcon,
  BoltIcon,
  DocumentTextIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
} from "@heroicons/react/24/outline";
import Button from "./Button";
import InputField from "./InputField";
import { ValidationResult } from "./validationUtils";
import { getAllVariables } from "../codeGeneration/Jokers/variableUtils";
import {
  JokerData,
  ConsumableData,
  EnhancementData,
  SealData,
  EditionData,
} from "../data/BalatroUtils";

interface InfoDescriptionBoxProps {
  value: string;
  onChange: (value: string, shouldAutoFormat?: boolean) => void;
  onKeyDown: (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => void;
  item: JokerData | ConsumableData | EnhancementData | SealData | EditionData;
  itemType: "joker" | "consumable" | "enhancement" | "seal" | "edition";
  textAreaId: string;
  autoFormatEnabled: boolean;
  onAutoFormatToggle: () => void;
  validationResult?: ValidationResult;
  placeholder?: string;
  onInsertTag: (tag: string, autoClose?: boolean) => void;
}

const InfoDescriptionBox: React.FC<InfoDescriptionBoxProps> = ({
  value,
  onChange,
  onKeyDown,
  item,
  textAreaId,
  autoFormatEnabled,
  onAutoFormatToggle,
  validationResult,
  placeholder = "Describe your item's effects using Balatro formatting...",
  onInsertTag,
}) => {
  const colorButtons = [
    { tag: "{C:red}", color: "bg-balatro-red", name: "Red" },
    { tag: "{C:blue}", color: "bg-balatro-blue", name: "Blue" },
    { tag: "{C:green}", color: "bg-balatro-green", name: "Green" },
    { tag: "{C:purple}", color: "bg-balatro-purple", name: "Purple" },
    { tag: "{C:attention}", color: "bg-balatro-orange", name: "Orange" },
    { tag: "{C:money}", color: "bg-balatro-money", name: "Money" },
    { tag: "{C:gold}", color: "bg-balatro-gold-new", name: "Gold" },
    { tag: "{C:white}", color: "bg-balatro-white", name: "White" },
    { tag: "{C:inactive}", color: "bg-balatro-grey", name: "Inactive" },
    { tag: "{C:default}", color: "bg-balatro-default", name: "Default" },
    { tag: "{C:hearts}", color: "bg-balatro-hearts", name: "Hearts" },
    { tag: "{C:clubs}", color: "bg-balatro-clubs", name: "Clubs" },
    { tag: "{C:diamonds}", color: "bg-balatro-diamonds", name: "Diamonds" },
    { tag: "{C:spades}", color: "bg-balatro-spades", name: "Spades" },
    { tag: "{C:tarot}", color: "bg-balatro-purple", name: "Tarot" },
    { tag: "{C:planet}", color: "bg-balatro-planet", name: "Planet" },
    { tag: "{C:spectral}", color: "bg-balatro-spectral", name: "Spectral" },
    { tag: "{C:enhanced}", color: "bg-balatro-enhanced-new", name: "Enhanced" },
    { tag: "{C:common}", color: "bg-balatro-common", name: "Common" },
    { tag: "{C:uncommon}", color: "bg-balatro-uncommon", name: "Uncommon" },
    { tag: "{C:rare}", color: "bg-balatro-rare", name: "Rare" },
    { tag: "{C:legendary}", color: "bg-balatro-legendary", name: "Legendary" },
    {
      tag: "{C:edition}",
      color: "bg-gradient-to-r from-purple-400 to-pink-400",
      name: "Edition",
    },
    {
      tag: "{C:dark_edition}",
      color: "bg-gray-900 border-2 border-purple-400",
      name: "Dark Edition",
    },
  ];

  const backgroundButtons = [
    { tag: "{X:red,C:white}", color: "bg-balatro-red", name: "Red BG" },
    { tag: "{X:blue,C:white}", color: "bg-balatro-blue", name: "Blue BG" },
    { tag: "{X:mult,C:white}", color: "bg-balatro-mult", name: "Mult BG" },
    { tag: "{X:chips,C:white}", color: "bg-balatro-chips", name: "Chips BG" },
    { tag: "{X:money,C:white}", color: "bg-balatro-money", name: "Money BG" },
    {
      tag: "{X:attention,C:white}",
      color: "bg-balatro-orange",
      name: "Attention BG",
    },
    {
      tag: "{X:tarot,C:white}",
      color: "bg-balatro-purple",
      name: "Tarot BG",
    },
    {
      tag: "{X:planet,C:white}",
      color: "bg-balatro-planet",
      name: "Planet BG",
    },
    {
      tag: "{X:spectral,C:white}",
      color: "bg-balatro-spectral",
      name: "Spectral BG",
    },
    {
      tag: "{X:enhanced,C:white}",
      color: "bg-balatro-enhanced-new",
      name: "Enhanced BG",
    },
    {
      tag: "{X:legendary,C:white}",
      color: "bg-balatro-legendary",
      name: "Legendary BG",
    },
    {
      tag: "{X:edition,C:white}",
      color: "bg-gradient-to-r from-purple-400 to-pink-400",
      name: "Edition BG",
    },
  ];

  const variables = getAllVariables(item);

  const insertVariable = (variableIndex: number) => {
    const placeholder = `#${variableIndex}#`;
    onInsertTag(placeholder, false);
  };

  const getValidationMessage = () => {
    if (!validationResult) return null;

    if (!validationResult.isValid && validationResult.error) {
      return {
        type: "error" as const,
        message: validationResult.error,
        icon: ExclamationTriangleIcon,
      };
    }

    if (validationResult.isValid && validationResult.warning) {
      return {
        type: "warning" as const,
        message: validationResult.warning,
        icon: InformationCircleIcon,
      };
    }

    return null;
  };

  return (
    <div className="p-6 space-y-6">
      <DocumentTextIcon className="absolute top-12 right-16 h-28 w-28 text-black-lighter/20 -rotate-6 pointer-events-none" />

      <div className="bg-black-darker border border-black-lighter rounded-xl p-6">
        <div className="flex items-center justify-between mb-2">
          <h4 className="text-white-light font-medium text-sm flex items-center gap-2">
            <DocumentTextIcon className="h-4 w-4 text-mint" />
            Formatting Tools
          </h4>
          <div className="flex items-center gap-4">
            <span className="text-xs text-white-darker">Ctrl+Z to undo</span>
            <Button
              size="sm"
              variant={autoFormatEnabled ? "primary" : "secondary"}
              onClick={onAutoFormatToggle}
              icon={<SparklesIcon className="h-3 w-3" />}
            >
              Auto Format
            </Button>
          </div>
        </div>

        <div className="space-y-4">
          <div>
            <p className="text-white-light text-sm mb-3 font-medium">
              Text Colors
            </p>
            <div className="flex flex-wrap gap-3">
              {colorButtons.map((item, index) => (
                <button
                  key={index}
                  onClick={() => onInsertTag(item.tag)}
                  title={item.name}
                  className={`w-8 h-8 ${item.color} rounded border border-black-lighter hover:scale-110 transition-transform z-10`}
                />
              ))}
            </div>
          </div>

          <div>
            <p className="text-white-light text-sm mb-3 font-medium">
              Backgrounds
            </p>
            <div className="flex flex-wrap gap-3">
              {backgroundButtons.map((item, index) => (
                <button
                  key={index}
                  onClick={() => onInsertTag(item.tag)}
                  title={item.name}
                  className={`w-8 h-8 ${item.color} rounded border-2 border-white-light hover:scale-110 transition-transform`}
                />
              ))}
            </div>
          </div>

          {variables.length > 0 && (
            <div>
              <p className="text-white-light text-sm mb-3 font-medium">
                Variables
              </p>
              <div className="flex flex-wrap gap-2">
                {variables.map((variable, index) => (
                  <button
                    key={variable.id}
                    onClick={() => insertVariable(index + 1)}
                    className="px-3 py-1 bg-mint/20 border border-mint/40 rounded-md text-mint text-xs font-medium hover:bg-mint/30 transition-colors"
                    title={
                      variable.description || `Insert ${variable.name} variable`
                    }
                  >
                    {variable.name} (#{index + 1}#)
                  </button>
                ))}
              </div>
            </div>
          )}

          <div>
            <p className="text-white-light text-sm mb-3 font-medium">
              Special Effects
            </p>
            <div className="flex gap-3 flex-wrap">
              <Button
                size="sm"
                variant="secondary"
                onClick={() => onInsertTag("[s]", false)}
                icon={<ArrowPathIcon className="h-3 w-3" />}
              >
                New Line
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={() => onInsertTag("{s:1.1}")}
                icon={<SparklesIcon className="h-3 w-3" />}
              >
                Scale
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={() => onInsertTag("{E:1}")}
                icon={<BoltIcon className="h-3 w-3" />}
              >
                Float
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={() => onInsertTag("{}")}
              >
                Reset
              </Button>
            </div>
          </div>
        </div>
      </div>

      <div className="w-full -mt-2">
        <InputField
          id={textAreaId}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={onKeyDown}
          multiline={true}
          height="140px"
          separator={true}
          label="Description Text"
          placeholder={placeholder}
        />
        {(() => {
          const validationMsg = getValidationMessage();
          return validationMsg ? (
            <div
              className={`flex items-center gap-2 mt-1 text-sm ${
                validationMsg.type === "error"
                  ? "text-balatro-orange"
                  : "text-yellow-500"
              }`}
            >
              <validationMsg.icon className="h-4 w-4" />
              <span>{validationMsg.message}</span>
            </div>
          ) : null;
        })()}
      </div>
    </div>
  );
};

export default InfoDescriptionBox;

```

### src\components\generic\InputDropdown.tsx

```
import React, { useState, useRef, useEffect } from "react";
import ReactDOM from "react-dom";
import { ChevronDownIcon } from "@heroicons/react/24/outline";

interface DropdownOption {
  value: string;
  label: string;
}

interface InputDropdownProps {
  label?: string;
  icon?: React.ReactNode;
  error?: string;
  useGameFont?: boolean;
  separator?: boolean;
  className?: string;
  placeholder?: string;
  value: string;
  onChange: (value: string) => void;
  options: DropdownOption[];
  size?: "sm" | "md" | "lg";
  labelPosition?: "left" | "center" | "right";
}

const InputDropdown: React.FC<InputDropdownProps> = ({
  label,
  icon,
  error,
  useGameFont = false,
  separator = false,
  className = "",
  placeholder = "Select an option",
  value,
  onChange,
  options,
  size = "md",
  labelPosition = "center",
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [dropdownPosition, setDropdownPosition] = useState({
    top: 0,
    left: 0,
    width: 0,
  });
  const dropdownRef = useRef<HTMLDivElement>(null);
  const buttonRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node) &&
        buttonRef.current &&
        !buttonRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        setIsFocused(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

useEffect(() => {
  if (isOpen && buttonRef.current && dropdownRef.current) {
    const buttonRect = buttonRef.current.getBoundingClientRect();
    const dropdownRect = dropdownRef.current.getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    const spaceBelow = viewportHeight - buttonRect.bottom;
    const spaceAbove = buttonRect.top;

    let topPosition = buttonRect.bottom + 4;

    if (spaceBelow < dropdownRect.height && spaceAbove > dropdownRect.height) {
      topPosition = buttonRect.top - dropdownRect.height - 4;
    }
    setDropdownPosition({
      top: topPosition,
      left: buttonRect.left,
      width: buttonRect.width,
    });
  } 
}, [isOpen]);

  const renderIcon = () => {
    if (icon) {
      return icon;
    }
    const iconSizeClasses = {
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
    };
    return (
      <ChevronDownIcon
        className={`${
          iconSizeClasses[size]
        } text-mint stroke-2 transition-transform ${
          isOpen ? "rotate-180" : ""
        }`}
      />
    );
  };

  const selectedOption = options.find((option) => option.value === value);
  const displayText = selectedOption ? selectedOption.label : placeholder;

  const getSeparatorColor = () => {
    if (error) return "bg-balatro-red";
    if (isFocused || isOpen) return "bg-mint";
    return "bg-black-lighter";
  };

  const sizeClasses = {
    sm: {
      padding: "px-2 py-1",
      text: "text-sm",
      iconPadding: "left-2",
      separatorPadding: "left-8",
      contentPadding: "pl-10",
    },
    md: {
      padding: "px-3 py-2",
      text: "text-base",
      iconPadding: "left-3",
      separatorPadding: "left-11",
      contentPadding: "pl-14",
    },
    lg: {
      padding: "px-3 py-2",
      text: "text-xl",
      iconPadding: "left-3",
      separatorPadding: "left-11",
      contentPadding: "pl-14",
    },
  };

  const getLabelPositionClass = () => {
    switch (labelPosition) {
      case "left":
        return "justify-start pl-2";
      case "right":
        return "justify-end pr-2";
      default:
        return "justify-center";
    }
  };

  return (
    <div className="flex flex-col w-full select-none">
      {label && (
        <div className={`flex ${getLabelPositionClass()}`}>
          <div className="bg-black border-2 border-black-light rounded-md px-4 pb-2 -mb-2 relative">
            <span className={`text-white-light ${sizeClasses[size].text}`}>
              {label}
            </span>
          </div>
        </div>
      )}

      <div className="relative">
        <div
          ref={buttonRef}
          className={`
            relative flex items-center bg-black-dark text-white-light ${
              sizeClasses[size].padding
            }
            ${
              useGameFont ? "font-game" : "font-lexend"
            } tracking-wide font-light ${sizeClasses[size].text}
            focus:outline-none rounded-lg cursor-pointer
            border-2 ${
              error
                ? "border-balatro-red"
                : isOpen
                ? "border-mint"
                : "border-black-lighter"
            } 
            hover:border-mint transition-colors w-full
            ${className}
          `}
          onClick={() => {
            setIsOpen(!isOpen);
            setIsFocused(!isFocused);
          }}
        >
          <div
            className={`absolute ${sizeClasses[size].iconPadding} flex items-center justify-center z-10`}
          >
            {renderIcon()}
          </div>

          {separator && (
            <div
              className={`
                absolute ${sizeClasses[size].separatorPadding} h-[60%] w-px 
                ${getSeparatorColor()}
                transition-colors
              `}
            />
          )}

          <div
            className={`w-full truncate ${
              separator ? sizeClasses[size].contentPadding : "pl-10"
            }`}
          >
            {displayText}
          </div>
        </div>

        {isOpen &&
          ReactDOM.createPortal(
            <div
              ref={dropdownRef}
              style={{
                position: "fixed",
                top: `${dropdownPosition.top}px`,
                left: `${dropdownPosition.left}px`,
                width: `${dropdownPosition.width}px`,
                zIndex: 9999,
              }}
              className="bg-black-dark border-2 border-black-lighter rounded-lg shadow-lg max-h-60 overflow-y-auto custom-scrollbar"
              onMouseDown={(e) => e.stopPropagation()}
              onClick={(e) => e.stopPropagation()}
            >
              {options.map((option) => (
                <div
                  key={option.value}
                  className={`
                  ${sizeClasses[size].padding} cursor-pointer 
                  ${
                    useGameFont ? "font-game" : "font-lexend"
                  } text-white-light ${sizeClasses[size].text}
                  ${
                    value === option.value
                      ? "bg-mint-dark"
                      : "hover:bg-black-lighter"
                  }
                  ${value === option.value ? "font-medium" : "font-light"}
                `}
                  onClick={(e) => {
                    e.stopPropagation();
                    onChange(option.value);
                    setIsOpen(false);
                  }}
                >
                  {option.label}
                </div>
              ))}
            </div>,
            document.body
          )}
      </div>

      {error && <p className="text-balatro-red text-xs mt-1">{error}</p>}
    </div>
  );
};

export default InputDropdown;

```

### src\components\generic\InputField.tsx

```
import React, {
  InputHTMLAttributes,
  ReactNode,
  useState,
  forwardRef,
  KeyboardEvent,
} from "react";
import { PencilIcon } from "@heroicons/react/24/outline";

interface InputFieldProps
  extends Omit<
    InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement>,
    "size" | "onKeyDown"
  > {
  label?: string;
  icon?: ReactNode;
  error?: string;
  useGameFont?: boolean;
  separator?: boolean;
  multiline?: boolean;
  height?: string;
  size?: "sm" | "md" | "lg";
  darkmode?: boolean;
  value: string;
  onChange: (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => void;
  onKeyDown?: (
    e: KeyboardEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => void;
  labelPosition?: "left" | "center" | "right";
}

const InputField = forwardRef<
  HTMLInputElement | HTMLTextAreaElement,
  InputFieldProps
>(
  (
    {
      label,
      icon,
      error,
      useGameFont = false,
      separator = false,
      multiline = false,
      height = "auto",
      size = "md",
      darkmode = false,
      className = "",
      value,
      onChange,
      onKeyDown,
      labelPosition = "center",
      ...props
    },
    ref
  ) => {
    const [isFocused, setIsFocused] = useState(false);

    const iconSizeClasses = {
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
    };

    const renderIcon = () => {
      if (icon) {
        return icon;
      }
      return (
        <PencilIcon className={`${iconSizeClasses[size]} text-mint stroke-2`} />
      );
    };

    const getSeparatorColor = () => {
      if (error) return "bg-balatro-red";
      if (isFocused) return "bg-mint";
      return "bg-black-lighter";
    };

    const sizeClasses = {
      sm: {
        padding: "px-2 py-1",
        text: "text-sm",
        iconPadding: "left-2",
        separatorPadding: "left-8",
        contentPadding: "pl-8",
      },
      md: {
        padding: "px-3 py-2",
        text: "text-base",
        iconPadding: "left-3",
        separatorPadding: "left-11",
        contentPadding: "pl-14",
      },
      lg: {
        padding: "px-3 py-2",
        text: "text-xl",
        iconPadding: "left-3",
        separatorPadding: "left-11",
        contentPadding: "pl-14",
      },
    };

    const getLabelPositionClass = () => {
      switch (labelPosition) {
        case "left":
          return "justify-start pl-2";
        case "right":
          return "justify-end pr-2";
        default:
          return "justify-center";
      }
    };

    const getBackgroundClasses = () => {
      if (darkmode) {
        return "bg-black-darker border-black-light";
      }
      return "bg-black-dark border-black-lighter";
    };

    const inputClasses = `
    ${getBackgroundClasses()} text-white-light ${
      sizeClasses[size].padding
    } font-light ${sizeClasses[size].text}
    ${useGameFont ? "font-game tracking-widest" : "font-lexend tracking-wide"}
    ${sizeClasses[size].contentPadding}
    focus:outline-none rounded-lg
    border-2 focus:border-mint transition-colors w-full
    ${error ? "border-balatro-red" : ""}
    ${
      props.type === "number"
        ? "[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
        : ""
    }
    ${className}
  `;

    return (
      <div className="w-full">
        {label && (
          <div className={`flex ${getLabelPositionClass()}`}>
            <div className="bg-black border-2 border-black-light rounded-md px-4 pb-2 -mb-2 relative">
              <span className={`text-white-light ${sizeClasses[size].text}`}>
                {label}
              </span>
            </div>
          </div>
        )}

        <div className="relative">
          <div
            className={`absolute ${sizeClasses[size].iconPadding} top-1/2 -translate-y-1/2 z-10`}
          >
            {renderIcon()}
          </div>

          {separator && (
            <div
              className={`
            absolute ${
              sizeClasses[size].separatorPadding
            } top-1/2 -translate-y-1/2 h-[60%] w-px 
            ${getSeparatorColor()}
          `}
            />
          )}

          {multiline ? (
            <textarea
              ref={ref as React.Ref<HTMLTextAreaElement>}
              value={value}
              onChange={onChange}
              onKeyDown={onKeyDown}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
              className={inputClasses}
              style={{ height, resize: "none" }}
              {...(props as React.TextareaHTMLAttributes<HTMLTextAreaElement>)}
            />
          ) : (
            <input
              ref={ref as React.Ref<HTMLInputElement>}
              value={value}
              onChange={onChange}
              onKeyDown={onKeyDown}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setIsFocused(false)}
              className={inputClasses}
              {...(props as React.InputHTMLAttributes<HTMLInputElement>)}
            />
          )}
        </div>

        {error && <p className="text-balatro-red text-xs mt-1">{error}</p>}
      </div>
    );
  }
);

InputField.displayName = "InputField";

export default InputField;

```

### src\components\generic\Modal.tsx

```
import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import { XMarkIcon } from "@heroicons/react/24/outline";

interface ModalButton {
  label: string;
  onClick: () => void;
  variant?: "primary" | "secondary" | "danger";
  icon?: React.ReactNode;
}

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  buttons?: ModalButton[];
  showCloseButton?: boolean;
  closeOnBackdropClick?: boolean;
  maxWidth?: string;
  icon?: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  buttons = [],
  showCloseButton = true,
  maxWidth = "max-w-lg",
  icon,
}) => {
  const getButtonStyles = (variant: string = "primary") => {
    switch (variant) {
      case "primary":
        return "bg-mint text-black-dark hover:bg-mint-light font-medium px-6 py-3 rounded-lg transition-colors cursor-pointer";
      case "secondary":
        return "bg-black-lighter text-white-light hover:bg-black-light px-6 py-3 rounded-lg transition-colors cursor-pointer";
      case "danger":
        return "bg-balatro-red text-white hover:bg-balatro-redshadow px-6 py-3 rounded-lg transition-colors cursor-pointer";
      default:
        return "bg-mint text-black-dark hover:bg-mint-light font-medium px-6 py-3 rounded-lg transition-colors cursor-pointer";
    }
  };

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
          className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-[9999] p-4 font-lexend"
          onClick={handleBackdropClick}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.9, opacity: 0, y: 20 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 30,
            }}
            className={`bg-black-dark border-2 border-black-lighter rounded-xl shadow-2xl ${maxWidth} w-full overflow-hidden`}
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div className="px-6 py-5 border-b bg-black-darker border-black-lighter/50">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  {icon && (
                    <div className="flex-shrink-0 p-2 bg-black-darker rounded-lg">
                      {icon}
                    </div>
                  )}
                  <h2 className="text-xl text-white-light font-medium tracking-wide">
                    {title}
                  </h2>
                </div>
                {showCloseButton && (
                  <button
                    onClick={onClose}
                    className="p-2 text-white-darker hover:text-white-light hover:bg-black-lighter rounded-lg transition-colors cursor-pointer"
                  >
                    <XMarkIcon className="h-5 w-5" />
                  </button>
                )}
              </div>
            </div>

            {/* Body */}
            <div className="px-6 py-5">
              <div className="text-white-light leading-relaxed">{children}</div>
            </div>

            {/* Footer */}
            {buttons.length > 0 && (
              <div className="px-6 py-4 border-t border-black-lighter/50 bg-black-darker/30">
                <div className="flex gap-3 justify-end">
                  {buttons.map((button, index) => (
                    <button
                      key={index}
                      onClick={button.onClick}
                      className={`flex items-center gap-2 ${getButtonStyles(
                        button.variant
                      )}`}
                    >
                      {button.icon && <span>{button.icon}</span>}
                      <span>{button.label}</span>
                    </button>
                  ))}
                </div>
              </div>
            )}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default Modal;

```

### src\components\generic\RestoreProgressModal.tsx

```
import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ClockIcon } from "@heroicons/react/24/outline";
import Button from "./Button";

interface RestoreProgressModalProps {
  isVisible: boolean;
  onRestore: () => void;
  onDiscard: () => void;
  getAutoSaveMetadata: () => { timestamp: number; daysOld: number } | null;
}

const RestoreProgressModal: React.FC<RestoreProgressModalProps> = ({
  isVisible,
  onRestore,
  onDiscard,
  getAutoSaveMetadata,
}) => {
  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onDiscard();
    }
  };

  const getTimeDescription = () => {
    const metadata = getAutoSaveMetadata();
    if (!metadata) return "recently";
    if (metadata.daysOld < 1) return "today";
    if (metadata.daysOld < 2) return "yesterday";
    return `${Math.floor(metadata.daysOld)} days ago`;
  };

  const formatTimestamp = () => {
    const metadata = getAutoSaveMetadata();
    if (!metadata) return "";

    const date = new Date(metadata.timestamp);
    return (
      date.toLocaleDateString() +
      " at " +
      date.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      })
    );
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
          className="fixed inset-0 bg-black-darker/60 backdrop-blur-sm flex items-center justify-center z-[9999] font-lexend p-4"
          onClick={handleBackdropClick}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.9, opacity: 0, y: 20 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 30,
            }}
            className="bg-black-dark border-2 border-black-lighter rounded-xl shadow-2xl min-w-96 max-w-md w-full overflow-hidden"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div className="px-6 py-5 border-b bg-black-darker border-black-lighter/50">
              <div className="flex items-center gap-3">
                <div className="flex-shrink-0 p-2 bg-mint/20 rounded-lg">
                  <ClockIcon className="h-6 w-6 text-mint" />
                </div>
                <div>
                  <h2 className="text-xl text-white-light font-medium tracking-wide">
                    Restore Auto-Saved Project?
                  </h2>
                  <div className="flex items-center gap-2 mt-1">
                    <p className="text-sm text-white-darker">
                      Saved {formatTimestamp()}
                    </p>
                    <span className="px-2 py-0.5 bg-mint/20 border border-mint/30 rounded text-xs text-mint font-medium">
                      {getTimeDescription()}
                    </span>
                  </div>
                </div>
              </div>
            </div>

            {/* Body */}
            <div className="px-6 py-5">
              <div className="space-y-3">
                <Button
                  variant="primary"
                  onClick={onRestore}
                  size="md"
                  className="w-full"
                >
                  Restore Project
                </Button>
                <Button
                  variant="secondary"
                  onClick={onDiscard}
                  size="md"
                  className="w-full"
                >
                  Start Fresh
                </Button>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default RestoreProgressModal;

```

### src\components\generic\RuleBuilderLoading.tsx

```
const RuleBuilderLoading = () => {
  return (
    <div className="flex items-center justify-center">
      <div className="relative w-12 h-12">
        <div
          className="absolute inset-0 border-2 border-mint/20 border-t-mint rounded-full"
          style={{ animation: "spin 0.6s linear infinite" }}
        ></div>
        <div
          className="absolute inset-1 border-2 border-mint/30 border-b-mint rounded-full"
          style={{ animation: "spin 0.8s linear infinite reverse" }}
        ></div>
        <div
          className="absolute inset-2 w-8 h-8 bg-mint/80 rounded-full"
          style={{ animation: "pulse 0.4s ease-in-out infinite alternate" }}
        ></div>
      </div>
    </div>
  );
};

export default RuleBuilderLoading;

```

### src\components\generic\ShowcaseModal.tsx

```
import React, { useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  XMarkIcon,
  ArrowDownTrayIcon,
  CameraIcon,
} from "@heroicons/react/24/outline";
import BalatroCard from "../generic/BalatroCard";
import {
  JokerData,
  getRarityDisplayName,
  getRarityBadgeColor,
  RarityData,
  UserVariable,
} from "../data/BalatroUtils";
import { getAllVariables } from "../codeGeneration/Jokers/variableUtils";
import { toPng } from "html-to-image";

interface ShowcaseModalProps {
  isOpen: boolean;
  joker: JokerData;
  onClose: () => void;
  customRarities?: RarityData[];
}

const isStrInt = function (str: string) {
  const num = Number(str);
  return !isNaN(num) && Number.isInteger(num);
};

const VariableDisplay = (variable: UserVariable) => {
  if (variable.type === "suit") return variable.initialSuit || "Spades";
  if (variable.type === "rank") return variable.initialRank || "Ace";
  if (variable.type === "pokerhand")
    return variable.initialPokerHand || "High Card";
  return variable.initialValue?.toString() || "0";
};

const getVars = function (joker: JokerData): string[] {
  const Varlist: UserVariable[] = getAllVariables(joker);
  const varValues = Varlist.map(VariableDisplay);
  return varValues;
};

const parse_string = function (joker: JokerData) {
  const line = joker.description;
  const listofVars = getVars(joker);
  let parsed_line: string = "";
  let inVar = false;

  for (let i = 0; i < line.length; i++) {
    const char1: string = line.substring(i, i + 1) || "";
    const char2: string = line.substring(i + 1, i + 2) || "";
    const char3: string = line.substring(i + 2, i + 3) || "";

    if (inVar && isStrInt(char1)) {
      // Skip numeric characters when inside variable
    } else if (inVar && char1 == "#") {
      inVar = false;
    } else {
      if (char1 == "#" && isStrInt(char2) && char3 == "#") {
        parsed_line += listofVars[Number(char2) - 1];
        inVar = true;
      } else {
        parsed_line += char1;
      }
    }
  }
  return parsed_line;
};

const ShowcaseModal: React.FC<ShowcaseModalProps> = ({
  isOpen,
  joker,
  onClose,
  customRarities = [],
}) => {
  const showcaseRef = useRef<HTMLDivElement>(null);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  const handleDownload = async () => {
    if (!showcaseRef.current) return;
    try {
      const dataUrl = await toPng(showcaseRef.current, {
        quality: 1,
        pixelRatio: 2,
        backgroundColor: "#1a1a2e",
        cacheBust: true,
      });

      const link = document.createElement("a");
      link.download = `${joker.name.replace(/[^a-z0-9]/gi, "_")}_showcase.png`;
      link.href = dataUrl;
      link.click();
    } catch (error) {
      console.error("Failed to download showcase:", error);
      alert(
        "Screenshot failed. Please use your browser's screenshot feature instead."
      );
    }
  };

  const allVariables = getAllVariables(joker);
  const VariableDisplay = (variable: UserVariable) => {
    if (variable.type === "suit") return variable.initialSuit || "Spades";
    if (variable.type === "rank") return variable.initialRank || "Ace";
    if (variable.type === "pokerhand")
      return variable.initialPokerHand || "High Card";
    return variable.initialValue?.toString() || "0";
  };
  const VariableValues = allVariables.map(VariableDisplay);

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
          className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-[9999] p-4 font-lexend"
          onClick={handleBackdropClick}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.9, opacity: 0, y: 20 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 30,
            }}
            className="bg-black-dark border-2 border-black-lighter rounded-xl shadow-2xl overflow-hidden w-1/3 h-3/4"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="px-6 py-5 border-b bg-black-darker border-black-lighter/50">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="flex-shrink-0 p-2 bg-black-darker rounded-lg">
                    <CameraIcon className="h-5 w-5 text-mint" />
                  </div>
                  <h2 className="text-xl text-white-light font-medium tracking-wide">
                    {joker.name}
                  </h2>
                </div>
                <div className="flex items-center gap-2">
                  <button
                    onClick={handleDownload}
                    className="flex items-center gap-2 bg-mint text-black-dark hover:bg-mint-light font-medium px-4 py-2 rounded-lg transition-colors cursor-pointer"
                  >
                    <ArrowDownTrayIcon className="h-4 w-4" />
                    Download
                  </button>
                  <button
                    onClick={onClose}
                    className="p-2 text-white-darker hover:text-white-light hover:bg-black-lighter rounded-lg transition-colors cursor-pointer"
                  >
                    <XMarkIcon className="h-5 w-5" />
                  </button>
                </div>
              </div>
            </div>

            <div
              ref={showcaseRef}
              className="relative flex flex-col justify-center items-center p-8"
              style={{
                backgroundImage: "url('/images/background.jpg')",
                backgroundSize: "cover",
                backgroundPosition: "center",
                backgroundRepeat: "no-repeat",
                backgroundColor: "#1a1a2e",
                height: "calc(100% - 73px)",
                width: "100%",
              }}
            >
              <div className="absolute top-4 left-4 z-20">
                <p className="text-[#fff] text-xs font-mono font-bold">
                  made with jokerforge.jaydchw.com
                </p>
              </div>

              <div className="flex justify-center items-center h-full -mt-32">
                <BalatroCard
                  type="joker"
                  data={{
                    id: joker.id,
                    name: joker.name,
                    description: parse_string(joker),
                    imagePreview: joker.imagePreview,
                    overlayImagePreview: joker.overlayImagePreview,
                    cost: joker.cost,
                    rarity: joker.rarity,
                    locVars: {
                      vars: VariableValues,
                    },
                  }}
                  size="lg"
                  rarityName={getRarityDisplayName(
                    joker.rarity,
                    customRarities
                  )}
                  rarityColor={getRarityBadgeColor(
                    joker.rarity,
                    customRarities
                  )}
                  showCost={false}
                />
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default ShowcaseModal;

```

### src\components\generic\Tooltip.tsx

```
import React, { ReactNode, useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";

interface TooltipProps {
  children: ReactNode;
  content: string;
  position?: "top" | "bottom" | "left" | "right";
  className?: string;
  contentClassName?: string;
  show?: boolean;
}

const Tooltip: React.FC<TooltipProps> = ({
  children,
  content,
  position = "top",
  className = "",
  contentClassName = "",
  show = false,
}) => {
  const childRef = useRef<HTMLDivElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);
  const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });

  useEffect(() => {
    if (show && childRef.current && tooltipRef.current) {
      const childRect = childRef.current.getBoundingClientRect();
      const tooltipRect = tooltipRef.current.getBoundingClientRect();
      const gap = 8;

      let top = 0;
      let left = 0;

      switch (position) {
        case "top":
          top = childRect.top - tooltipRect.height - gap;
          left = childRect.left + childRect.width / 2 - tooltipRect.width / 2;
          break;
        case "bottom":
          top = childRect.bottom + gap;
          left = childRect.left + childRect.width / 2 - tooltipRect.width / 2;
          break;
        case "left":
          top = childRect.top + childRect.height / 2 - tooltipRect.height / 2;
          left = childRect.left - tooltipRect.width - gap;
          break;
        case "right":
          top = childRect.top + childRect.height / 2 - tooltipRect.height / 2;
          left = childRect.right + gap;
          break;
      }

      const padding = 16;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      if (left < padding) left = padding;
      if (left + tooltipRect.width > viewportWidth - padding) {
        left = viewportWidth - tooltipRect.width - padding;
      }
      if (top < padding) top = padding;
      if (top + tooltipRect.height > viewportHeight - padding) {
        top = viewportHeight - tooltipRect.height - padding;
      }

      setTooltipPosition({ top, left });
    }
  }, [show, position]);

  return (
    <>
      <div ref={childRef} className={`relative ${className}`}>
        {children}
      </div>
      {show &&
        createPortal(
          <div
            ref={tooltipRef}
            className={`fixed px-3 py-2 bg-black-darker border border-black-lighter rounded-lg text-sm text-white-light whitespace-nowrap z-[9999] shadow-lg pointer-events-none ${contentClassName}`}
            style={{
              top: `${tooltipPosition.top}px`,
              left: `${tooltipPosition.left}px`,
            }}
          >
            {content}
          </div>,
          document.body
        )}
    </>
  );
};

export default Tooltip;

```

### src\components\generic\validationUtils.ts

```
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  warning?: string;
}

export const validateJokerName = (name: string): ValidationResult => {
  if (!name.trim()) {
    return { isValid: false, error: "Name cannot be empty" };
  }

  if (name.includes('"') || name.includes("'")) {
    return { isValid: false, error: "Name cannot contain quotation marks" };
  }

  if (name.includes("\\")) {
    return { isValid: false, error: "Name cannot contain backslashes" };
  }

  if (name.includes("\n") || name.includes("\r")) {
    return { isValid: false, error: "Name cannot contain line breaks" };
  }

  if (name.includes("`")) {
    return { isValid: false, error: "Name cannot contain backticks" };
  }

  return { isValid: true };
};

export const validateVariableName = (name: string): ValidationResult => {
  if (!name.trim()) {
    return { isValid: false, error: "Variable name cannot be empty" };
  }

  if (name.includes(" ")) {
    return { isValid: false, error: "Variable name cannot contain spaces" };
  }

  if (name.includes('"') || name.includes("'")) {
    return {
      isValid: false,
      error: "Variable name cannot contain quotation marks",
    };
  }

  if (name.includes("\\")) {
    return {
      isValid: false,
      error: "Variable name cannot contain backslashes",
    };
  }

  if (name.includes("`")) {
    return { isValid: false, error: "Variable name cannot contain backticks" };
  }

  if (/^\d/.test(name)) {
    return {
      isValid: false,
      error: "Variable name cannot start with a number",
    };
  }

  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    return {
      isValid: false,
      error: "Variable name can only contain letters, numbers, and underscores",
    };
  }

  const reservedWords = [
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "export",
    "extends",
    "finally",
    "for",
    "function",
    "if",
    "import",
    "in",
    "instanceof",
    "let",
    "new",
    "return",
    "super",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield",
    "true",
    "false",
    "null",
    "undefined",
  ];

  if (reservedWords.includes(name.toLowerCase())) {
    return { isValid: false, error: "Variable name cannot be a reserved word" };
  }

  if (name.length > 30) {
    return {
      isValid: false,
      error: "Variable name must be 30 characters or less",
    };
  }

  return { isValid: true };
};

export const validateDescription = (description: string): ValidationResult => {
  const warnings: string[] = [];
  const errors: string[] = [];

  // Check for unescaped backslashes
  // if (description.includes("\\") && !description.includes("\\\\")) {
  //   errors.push("Unescaped backslashes may cause code generation issues");
  // }

  // // Check for quotation marks
  // if (description.includes('"')) {
  //   errors.push('Double quotes (") may cause code generation issues');
  // }

  // if (description.includes("'")) {
  //   errors.push("Single quotes (') may cause code generation issues");
  // }

  // Check for raw newlines (not [s] tags)
  const rawNewlinePattern = /(?<!\[s\])\n|(?<!\[s\])\r/;
  if (rawNewlinePattern.test(description)) {
    warnings.push(
      "Raw line breaks detected. Use [s] for line breaks in Balatro text"
    );
  }

  // // Check for backticks
  // if (description.includes("`")) {
  //   errors.push("Backticks (`) may cause code generation issues");
  // }

  // Check for unclosed formatting tags
  const openTags = (description.match(/\{[^}]*$/g) || []).length;
  const closeTags = (description.match(/\{\}/g) || []).length;
  const formatTags = (description.match(/\{[^}]+\}/g) || []).length;

  if (openTags > 0) {
    errors.push("Unclosed formatting tag detected");
  }

  // Check for mismatched formatting
  if (formatTags > closeTags && openTags === 0) {
    warnings.push("Some formatting tags may not be properly closed with {}");
  }

  // Check for invalid characters in tags
  const tagPattern = /\{([^}]+)\}/g;
  let tagMatch;
  while ((tagMatch = tagPattern.exec(description)) !== null) {
    const tagContent = tagMatch[1];

    // Skip empty tags and [s] which is valid
    if (tagContent === "" || tagContent === "s") continue;

    // Check for valid tag patterns (C:color, X:type, s:scale, E:effect, V:variable)
    const validTagPattern = /^(C|X|s|E|V):[a-zA-Z0-9_,.\s]/;
    if (!validTagPattern.test(tagContent)) {
      warnings.push(`Potentially invalid formatting tag: {${tagContent}}`);
    }
  }

  // Check length (reasonable limit)
  if (description.length > 500) {
    warnings.push("Description is quite long and may not display properly");
  }

  // Check for common mistakes
  if (description.includes("#{") && !description.includes("#}")) {
    warnings.push("Variable reference may be malformed. Use #1#, #2#, etc.");
  }

  // Return result
  if (errors.length > 0) {
    return {
      isValid: false,
      error: errors.join("; "),
    };
  }

  if (warnings.length > 0) {
    return {
      isValid: true,
      warning: warnings.join("; "),
    };
  }

  return { isValid: true };
};

export const validateCustomMessage = (message: string): ValidationResult => {
  if (message.includes('"') || message.includes("'")) {
    return { isValid: false, error: "Message cannot contain quotation marks" };
  }

  if (message.includes("\\") && !message.includes("\\\\")) {
    return { isValid: false, error: "Unescaped backslashes may cause issues" };
  }

  if (message.includes("`")) {
    return { isValid: false, error: "Message cannot contain backticks" };
  }

  if (message.includes("\n") || message.includes("\r")) {
    return { isValid: false, error: "Message cannot contain line breaks" };
  }

  if (message.length > 100) {
    return { isValid: false, error: "Message must be 100 characters or less" };
  }

  return { isValid: true };
};

```

### src\components\JSONImportExport.ts

```
import {
  JokerData,
  ConsumableData,
  ConsumableSetData,
  BoosterData,
  EnhancementData,
  SealData,
  EditionData,
  ModMetadata,
  SoundData,
} from "./data/BalatroUtils";
import { RarityData } from "./data/BalatroUtils";

// some of this is pretty bad
export interface ExportedMod {
  metadata: ModMetadata;
  jokers: JokerData[];
  sounds: SoundData[];
  consumables: ConsumableData[];
  customRarities: RarityData[];
  consumableSets: ConsumableSetData[];
  boosters: BoosterData[];
  enhancements: EnhancementData[];
  seals: SealData[];
  editions: EditionData[];
  version: string;
  exportedAt: string;
}
interface ImportableModData {
  metadata: ModMetadata;
  jokers: JokerData[];
  sounds: SoundData[];
  consumables?: ConsumableData[];
  customRarities?: RarityData[];
  consumableSets?: ConsumableSetData[];
  boosters?: BoosterData[];
  enhancements?: EnhancementData[];
  seals?: SealData[];
  editions?: EditionData[];
}

export const normalizeImportedModData = (data: ImportableModData) => {
  if (!data.metadata) {
    throw new Error("Invalid mod data - missing metadata");
  }

  if (!data.jokers || !Array.isArray(data.jokers)) {
    throw new Error("Invalid mod data - missing or invalid jokers data");
  }

  const normalizedJokers = data.jokers.map(normalizeJokerData);
  const normalizedSounds = (data.sounds || []).map(normalizeSoundData);
  const normalizedConsumables = (data.consumables || []).map(
    normalizeConsumableData
  );
  const normalizedRarities = (data.customRarities || []).map(
    normalizeRarityData
  );
  const normalizedConsumableSets = (data.consumableSets || []).map(
    normalizeConsumableSetData
  );
  const normalizedBoosters = (data.boosters || []).map(normalizeBoosterData);
  const normalizedEnhancements = (data.enhancements || []).map(
    normalizeEnhancementData
  );
  const normalizedSeals = (data.seals || []).map(normalizeSealData);
  const normalizedEditions = (data.editions || []).map(normalizeEditionData);

  console.log(
    `Successfully processed mod data with ${normalizedJokers.length} jokers, ${normalizedConsumables.length} consumables, ${normalizedBoosters.length} boosters, ${normalizedEnhancements.length} enhancements, ${normalizedSeals.length} seals, ${normalizedEditions.length} editions`
  );

  return {
    metadata: data.metadata,
    jokers: normalizedJokers,
    sounds: normalizedSounds,
    consumables: normalizedConsumables,
    customRarities: normalizedRarities,
    consumableSets: normalizedConsumableSets,
    boosters: normalizedBoosters,
    enhancements: normalizedEnhancements,
    seals: normalizedSeals,
    editions: normalizedEditions,
  };
};

const normalizeJokerData = (joker: Partial<JokerData>): JokerData => {
  return {
    id: joker.id || "",
    name: joker.name || "",
    description: joker.description || "",
    imagePreview: joker.imagePreview || "",
    overlayImagePreview: joker.overlayImagePreview,
    rarity: joker.rarity || 1,
    cost: joker.cost,
    blueprint_compat: joker.blueprint_compat,
    eternal_compat: joker.eternal_compat,
    perishable_compat: joker.perishable_compat,
    unlocked: joker.unlocked,
    discovered: joker.discovered,
    force_eternal: joker.force_eternal,
    force_perishable: joker.force_perishable,
    force_rental: joker.force_rental,
    force_foil: joker.force_foil,
    force_holographic: joker.force_holographic,
    force_polychrome: joker.force_polychrome,
    force_negative: joker.force_negative,
    appears_in_shop: joker.appears_in_shop,
    unlockTrigger: joker.unlockTrigger || undefined,
    unlockProperties: joker.unlockProperties || [],
    unlockOperator: joker.unlockOperator || "",
    unlockCount: joker.unlockCount ?? 1,
    unlockDescription: joker.unlockDescription || "",
    rules: joker.rules || [],
    userVariables: joker.userVariables || [],
    placeholderCreditIndex: joker.placeholderCreditIndex,
    jokerKey: joker.jokerKey || "",
    hasUserUploadedImage: joker.hasUserUploadedImage || false,
    cardAppearance: joker.cardAppearance || {
      buf: true,
      jud: true,
      rif: true,
      rta: true,
      sou: true,
      uta: true,
      wra: true,
    },
    appearFlags: joker.appearFlags || "",
    ignoreSlotLimit: joker.ignoreSlotLimit || false,
    scale_h: joker.scale_h || 100,
    scale_w: joker.scale_w || 100,
    pools: joker.pools || [],
  };
};

const normalizeSoundData = (sound: Partial<SoundData>): SoundData => {
  return {
    id: sound.id || "",
    key: sound.key || "",
    soundString: sound.soundString || "",
    volume: sound.volume || 0.6,
    pitch: sound.pitch || 0.7,
  };
};

const normalizeConsumableData = (
  consumable: ConsumableData
): ConsumableData => {
  return {
    id: consumable.id || "",
    name: consumable.name || "",
    description: consumable.description || "",
    imagePreview: consumable.imagePreview || "",
    overlayImagePreview: consumable.overlayImagePreview,
    set: consumable.set || "Tarot",
    cost: consumable.cost,
    unlocked: consumable.unlocked,
    discovered: consumable.discovered,
    hidden: consumable.hidden,
    can_repeat_soul: consumable.can_repeat_soul,
    rules: consumable.rules || [],
    placeholderCreditIndex: consumable.placeholderCreditIndex,
    consumableKey: consumable.consumableKey || "",
    hasUserUploadedImage: consumable.hasUserUploadedImage || false,
  };
};

const normalizeBoosterData = (booster: BoosterData): BoosterData => {
  return {
    id: booster.id || "",
    name: booster.name || "",
    description: booster.description || "",
    imagePreview: booster.imagePreview || "",
    cost: booster.cost ?? 4,
    weight: booster.weight ?? 1,
    draw_hand: booster.draw_hand || false,
    instant_use: booster.instant_use || false,
    booster_type: booster.booster_type || "joker",
    kind: booster.kind,
    group_key: booster.group_key,
    atlas: booster.atlas,
    pos: booster.pos || { x: 0, y: 0 },
    config: booster.config || { extra: 3, choose: 1 },
    card_rules: booster.card_rules || [],
    background_colour: booster.background_colour,
    special_colour: booster.special_colour,
    discovered: booster.discovered,
    hidden: booster.hidden,
    placeholderCreditIndex: booster.placeholderCreditIndex,
    boosterKey: booster.boosterKey || "",
    hasUserUploadedImage: booster.hasUserUploadedImage || false,
  };
};

const normalizeEnhancementData = (
  enhancement: EnhancementData
): EnhancementData => {
  return {
    id: enhancement.id || "",
    name: enhancement.name || "",
    description: enhancement.description || "",
    imagePreview: enhancement.imagePreview || "",
    enhancementKey: enhancement.enhancementKey || "",
    atlas: enhancement.atlas,
    pos: enhancement.pos || { x: 0, y: 0 },
    any_suit: enhancement.any_suit,
    replace_base_card: enhancement.replace_base_card,
    no_rank: enhancement.no_rank,
    no_suit: enhancement.no_suit,
    always_scores: enhancement.always_scores,
    unlocked: enhancement.unlocked,
    discovered: enhancement.discovered,
    no_collection: enhancement.no_collection,
    rules: enhancement.rules || [],
    userVariables: enhancement.userVariables || [],
    placeholderCreditIndex: enhancement.placeholderCreditIndex,
    hasUserUploadedImage: enhancement.hasUserUploadedImage || false,
    weight: enhancement.weight ?? 5,
  };
};

const normalizeSealData = (seal: SealData): SealData => {
  return {
    id: seal.id || "",
    name: seal.name || "",
    description: seal.description || "",
    imagePreview: seal.imagePreview || "",
    sealKey: seal.sealKey || "",
    atlas: seal.atlas,
    pos: seal.pos || { x: 0, y: 0 },
    badge_colour: seal.badge_colour || "#FFFFFF",
    unlocked: seal.unlocked,
    discovered: seal.discovered,
    no_collection: seal.no_collection,
    rules: seal.rules || [],
    userVariables: seal.userVariables || [],
    placeholderCreditIndex: seal.placeholderCreditIndex,
    hasUserUploadedImage: seal.hasUserUploadedImage || false,
  };
};

const normalizeEditionData = (edition: EditionData): EditionData => {
  return {
    id: edition.id || "",
    name: edition.name || "",
    description: edition.description || "",
    editionKey: edition.editionKey || "",
    shader: edition.shader || false,
    unlocked: edition.unlocked,
    discovered: edition.discovered,
    no_collection: edition.no_collection,
    in_shop: edition.in_shop,
    weight: edition.weight ?? 0,
    extra_cost: edition.extra_cost,
    apply_to_float: edition.apply_to_float,
    badge_colour: edition.badge_colour || "#FFAA00",
    sound: edition.sound || "foil1",
    disable_shadow: edition.disable_shadow,
    disable_base_shader: edition.disable_base_shader,
    rules: edition.rules || [],
  };
};

const normalizeRarityData = (rarity: RarityData): RarityData => {
  return {
    id: rarity.id || "",
    key: rarity.key || "",
    name: rarity.name || "",
    badge_colour: rarity.badge_colour || "#666665",
    default_weight: rarity.default_weight ?? 1,
  };
};

const normalizeConsumableSetData = (
  set: ConsumableSetData
): ConsumableSetData => {
  return {
    id: set.id || "",
    key: set.key || "",
    name: set.name || "",
    primary_colour: set.primary_colour || "#ffffff",
    secondary_colour: set.secondary_colour || "#000000",
    collection_rows: set.collection_rows || [5, 5],
    default_card: set.default_card,
    shop_rate: set.shop_rate ?? 1,
    collection_name: set.collection_name,
  };
};

export const modToJson = (
  metadata: ModMetadata,
  jokers: JokerData[],
  sounds: SoundData[],
  customRarities: RarityData[] = [],
  consumables: ConsumableData[] = [],
  consumableSets: ConsumableSetData[] = [],
  boosters: BoosterData[] = [],
  enhancements: EnhancementData[] = [],
  seals: SealData[] = [],
  editions: EditionData[] = []
): { filename: string; jsonString: string } => {
  const exportData: ExportedMod = {
    metadata,
    jokers,
    sounds,
    consumables,
    customRarities,
    consumableSets,
    boosters,
    enhancements,
    seals,
    editions,
    version: "1.0.0",
    exportedAt: new Date().toISOString(),
  };

  const jsonString = JSON.stringify(exportData, null, 2);
  const filename = `${metadata.id || "custom-mod"}-${new Date()
    .toISOString()
    .slice(0, 10)}.jokerforge`;

  return { filename, jsonString };
};

export const exportModAsJSON = (
  metadata: ModMetadata,
  jokers: JokerData[],
  sounds: SoundData[],
  customRarities: RarityData[] = [],
  consumables: ConsumableData[] = [],
  consumableSets: ConsumableSetData[] = [],
  boosters: BoosterData[] = [],
  enhancements: EnhancementData[] = [],
  seals: SealData[] = [],
  editions: EditionData[] = []
): void => {
  const ret = modToJson(
    metadata,
    jokers,
    sounds,
    customRarities,
    consumables,
    consumableSets,
    boosters,
    enhancements,
    seals,
    editions
  );
  const blob = new Blob([ret.jsonString], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = ret.filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

export const importModFromJSON = (): Promise<{
  metadata: ModMetadata;
  jokers: JokerData[];
  sounds: SoundData[];
  consumables: ConsumableData[];
  customRarities: RarityData[];
  consumableSets: ConsumableSetData[];
  boosters: BoosterData[];
  enhancements: EnhancementData[];
  seals: SealData[];
  editions: EditionData[];
} | null> => {
  return new Promise((resolve, reject) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json,.jokerforge";

    input.onchange = (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) {
        resolve(null);
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const jsonString = e.target?.result as string;
          const importData: ExportedMod = JSON.parse(jsonString);

          if (!importData.metadata) {
            throw new Error("Invalid mod file format - missing metadata");
          }

          if (!importData.jokers || !Array.isArray(importData.jokers)) {
            throw new Error(
              "Invalid mod file format - missing or invalid jokers data"
            );
          }

          const normalizedJokers = importData.jokers.map(normalizeJokerData);
          const normalizedSounds =
            importData.sounds?.map(normalizeSoundData) || [];
          const normalizedConsumables = (importData.consumables || []).map(
            normalizeConsumableData
          );
          const normalizedRarities = (importData.customRarities || []).map(
            normalizeRarityData
          );
          const normalizedConsumableSets = (
            importData.consumableSets || []
          ).map(normalizeConsumableSetData);
          const normalizedBoosters = (importData.boosters || []).map(
            normalizeBoosterData
          );
          const normalizedEnhancements = (importData.enhancements || []).map(
            normalizeEnhancementData
          );
          const normalizedSeals = (importData.seals || []).map(
            normalizeSealData
          );
          const normalizedEditions = (importData.editions || []).map(
            normalizeEditionData
          );

          console.log(
            `Successfully imported mod with ${normalizedJokers.length} jokers, ${normalizedConsumables.length} consumables, ${normalizedBoosters.length} boosters, ${normalizedEnhancements.length} enhancements, ${normalizedSeals.length} seals, ${normalizedEditions.length} editions`
          );

          resolve({
            metadata: importData.metadata,
            jokers: normalizedJokers,
            sounds: normalizedSounds,
            consumables: normalizedConsumables,
            customRarities: normalizedRarities,
            consumableSets: normalizedConsumableSets,
            boosters: normalizedBoosters,
            enhancements: normalizedEnhancements,
            seals: normalizedSeals,
            editions: normalizedEditions,
          });
        } catch (error) {
          console.error("Error parsing mod file:", error);
          reject(
            new Error(
              `Invalid mod file format: ${
                error instanceof Error
                  ? error.message
                  : "Please check the file and try again."
              }`
            )
          );
        }
      };

      reader.onerror = () => {
        console.error("Error reading file");
        reject(new Error("Failed to read the selected file."));
      };

      reader.readAsText(file);
    };

    input.oncancel = () => {
      resolve(null);
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
  });
};

```

### src\components\pages\AcknowledgementsPage.tsx

```
import { HeartIcon } from "@heroicons/react/24/solid";

const AcknowledgementsPage: React.FC = () => {
  return (
    <div className="min-h-screen">
      <div className="p-8 font-lexend max-w-7xl mx-auto">
        <h1 className="text-3xl text-white-light mb-4 tracking-widest text-center">
          Acknowledgements
        </h1>
        <HeartIcon className="h-12 w-12 text-mint mx-auto mb-4" />
        <p className="text-white text-lg mt-6">
          Core Technologies behind this site:
        </p>
        <ul className="list-disc list-inside text-white mt-4">
          <li>
            <a
              href="https://reactjs.org/"
              className="text-mint hover:underline"
            >
              React
            </a>
          </li>
          <li>
            <a
              href="https://tailwindcss.com/"
              className="text-mint hover:underline"
            >
              Tailwind CSS
            </a>
          </li>
          <li>
            <a
              href="https://heroicons.com/"
              className="text-mint hover:underline"
            >
              Heroicons
            </a>
          </li>
          <li>
            <a href="https://motion.dev/" className="text-mint hover:underline">
              Framer-Motion
            </a>
          </li>
        </ul>
        <p className="text-white text-lg text-center  mt-10">
          Huge thanks to the guys over at the{" "}
          <a
            href="https://discord.com/invite/balatro"
            className="text-mint hover:underline"
          >
            Balatro discord server
          </a>{" "}
          for their help and support during development.
        </p>
        <p className="text-white-dark text-lg mt-6">
          Particularly great resoruces for learning SMODS:
        </p>
        <p className="text-white-darker font-light text-sm">
          (And just some mods I like in general)
        </p>
        <ul className="list-disc list-inside text-white-dark mt-4">
          <li>
            <a
              href="https://github.com/Steamodded/smods/wiki"
              className="text-mint hover:underline"
            >
              SMODS Documentation
            </a>
          </li>
          <li>
            <a
              href="https://github.com/nh6574/VanillaRemade"
              className="text-mint hover:underline"
            >
              Vanilla Remade
            </a>
          </li>
          <li>
            <a
              href="https://github.com/GuilloryCraft/ExtraCredit"
              className="text-mint hover:underline"
            >
              Extra Credit
            </a>
          </li>
          <li>
            <a
              href="https://github.com/thefaketh30ne/grab-bag"
              className="text-mint hover:underline"
            >
              Grab Bag
            </a>
          </li>
          <li>
            <a
              href="https://github.com/WilsontheWolf/DebugPlus"
              className="text-mint hover:underline"
            >
              Debug Plus
            </a>
          </li>
          <li>
            <a
              href="https://github.com/SleepyG11/HandyBalatro"
              className="text-mint hover:underline"
            >
              Handy
            </a>
          </li>
        </ul>

        <p className="text-white-dark text-lg mt-6 text-center">
          Joker Forge would not be possible without Balatro itself, so thanks to{" "}
          <a
            href="https://localthunk.com/"
            className="text-mint hover:underline"
          >
            LocalThunk
          </a>
          .
        </p>
        <p className="text-white-dark text-center text-sm mt-8">
          Icon from FlatIcon
        </p>
        <p className="text-white-dark text-center text-sm">
          This project is licensed under the{" "}
          <a
            href="https://opensource.org/license/mit/"
            className="text-mint hover:underline"
          >
            MIT License
          </a>
          . Go wild with it!
        </p>
      </div>
    </div>
  );
};

export default AcknowledgementsPage;

```

### src\components\pages\boosters\BoosterCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  TrashIcon,
  DocumentDuplicateIcon,
  GiftIcon,
  PlayIcon,
  EyeIcon,
  EyeSlashIcon,
  CubeIcon,
  RectangleStackIcon,
  UserGroupIcon,
  SparklesIcon as SparklesIconSolid,
  Cog6ToothIcon,
} from "@heroicons/react/24/outline";
import Tooltip from "../../generic/Tooltip";
import { validateJokerName } from "../../generic/validationUtils";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { BoosterData, slugify } from "../../data/BalatroUtils";

interface BoosterCardProps {
  booster: BoosterData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onQuickUpdate: (updates: Partial<BoosterData>) => void;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const BoosterCard: React.FC<BoosterCardProps> = ({
  booster,
  onEditInfo,
  onEditRules,
  onDelete,
  onDuplicate,
  onQuickUpdate,
  showConfirmation,
}) => {
  const [editingName, setEditingName] = useState(false);
  const [editingCost, setEditingCost] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(booster.name);
  const [tempCost, setTempCost] = useState(booster.cost);
  const [tempDescription, setTempDescription] = useState(booster.description);
  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);
    if (validation.isValid) {
      onQuickUpdate({ name: tempName, boosterKey: slugify(tempName) });
      setEditingName(false);
    }
  };

  const handleCostSave = () => {
    onQuickUpdate({ cost: tempCost });
    setEditingCost(false);
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleDeleteClick = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Booster Pack",
      description: `Are you sure you want to delete "${booster.name}"? This action cannot be undone.`,
      confirmText: "Delete Booster",
      cancelText: "Keep Booster",
      confirmVariant: "danger",
      onConfirm: onDelete,
    });
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const getBoosterTypeIcon = () => {
    switch (booster.booster_type) {
      case "joker":
        return <UserGroupIcon className="w-full h-full" />;
      case "consumable":
        return <SparklesIconSolid className="w-full h-full" />;
      case "playing_card":
        return <RectangleStackIcon className="w-full h-full" />;
      default:
        return <CubeIcon className="w-full h-full" />;
    }
  };

  const getBoosterTypeLabel = () => {
    switch (booster.booster_type) {
      case "joker":
        return "Joker Pack";
      case "consumable":
        return "Consumable Pack";
      case "playing_card":
        return "Playing Card Pack";
      default:
        return "Unknown Pack";
    }
  };

  const getBoosterTypeColor = () => {
    switch (booster.booster_type) {
      case "joker":
        return "text-balatro-purple border-balatro-purple";
      case "consumable":
        return "text-mint border-mint";
      case "playing_card":
        return "text-balatro-blue border-balatro-blue";
      default:
        return "text-balatro-gold-new border-balatro-gold-new";
    }
  };

  const rulesCount = booster.card_rules?.length || 0;
  const isDiscovered = booster.discovered ?? true;
  const drawToHand = booster.draw_hand === true;
  const instantUse = booster.instant_use === false;

  const propertyIcons = [
    {
      icon: getBoosterTypeIcon(),
      tooltip: getBoosterTypeLabel(),
      variant: "info" as const,
      isEnabled: true,
      onClick: () => {},
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
    {
      icon: <PlayIcon className="w-full h-full" />,
      tooltip: drawToHand ? "Draws to Hand" : "Opens Normally",
      variant: "success" as const,
      isEnabled: drawToHand,
      onClick: () => onQuickUpdate({ draw_hand: !drawToHand }),
    },
    {
      icon: <PlayIcon className="w-full h-full" />,
      tooltip: instantUse ? "Adds to Hand" : "Instant Use",
      variant: "success" as const,
      isEnabled: !instantUse,
      onClick: () => onQuickUpdate({ instant_use: !instantUse }),
    },
  ];

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="px-4 -mb-6 z-20 py-1 rounded-md border-2 font-bold transition-all bg-black tracking-widest border-balatro-money text-balatro-money w-18 text-center">
          {editingCost ? (
            <input
              type="number"
              value={tempCost}
              onChange={(e) => setTempCost(parseInt(e.target.value))}
              onBlur={handleCostSave}
              onKeyDown={(e) => {
                if (e.key === "Enter") handleCostSave();
                if (e.key === "Escape") {
                  setTempCost(booster.cost);
                  setEditingCost(false);
                }
              }}
              className="w-full bg-transparent text-center outline-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
              autoFocus
            />
          ) : (
            <span
              onClick={() => {
                setTempCost(booster.cost);
                setEditingCost(true);
              }}
            >
              ${booster.cost}
            </span>
          )}
        </div>

        <div className="w-42 z-10 relative">
          <div className="relative rounded-lg overflow-hidden">
            {booster.imagePreview && !imageLoadError ? (
              <img
                src={booster.imagePreview}
                alt={booster.name}
                className="w-full h-full object-contain"
                draggable="false"
                onError={() => setImageLoadError(true)}
              />
            ) : (
              <div className="w-full h-48 flex items-center justify-center border-2 border-mint/30 rounded-lg">
                <GiftIcon className="h-16 w-16 text-mint opacity-60" />
              </div>
            )}
          </div>
        </div>

        <div className="relative z-30">
          <div
            className={`px-4 py-1 -mt-6 rounded-md border-2 text-sm tracking-wide font-medium bg-black ${getBoosterTypeColor()}`}
          >
            {getBoosterTypeLabel()}
          </div>
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Booster" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleDeleteClick();
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <input
                  type="text"
                  value={tempName}
                  onChange={(e) => setTempName(e.target.value)}
                  onBlur={handleNameSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") handleNameSave();
                    if (e.key === "Escape") {
                      setTempName(booster.name);
                      setEditingName(false);
                    }
                  }}
                  className="text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text"
                  autoFocus
                />
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(booster.name);
                    setEditingName(true);
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {booster.name}
                </h3>
              )}
            </div>

            <div className="mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(booster.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(booster.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(booster.description),
                  }}
                />
              )}
            </div>

            <div className="mb-4">
              <div className="text-xs text-white-darker mb-1">
                Configuration:
              </div>
              <div className="text-white-light text-sm">
                {booster.config.extra} cards, choose {booster.config.choose}
              </div>
            </div>

            <div className="flex items-center justify-between mb-4 px-8 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center px-8 justify-between overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <Cog6ToothIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BoosterCard;

```

### src\components\pages\boosters\EditBoosterInfo.tsx

```
import React, { useState, useEffect, useRef, useContext } from "react";
import {
  DocumentTextIcon,
  PhotoIcon,
  ArrowPathIcon,
  SparklesIcon,
  BoltIcon,
  Cog6ToothIcon,
  GiftIcon,
} from "@heroicons/react/24/outline";
import { SketchPicker, ColorResult } from "react-color";
import Button from "../../generic/Button";
import InputField from "../../generic/InputField";
import InputDropdown from "../../generic/InputDropdown";
import BalatroCard from "../../generic/BalatroCard";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import { BoosterData, BoosterType } from "../../data/BalatroUtils";
import { UserConfigContext } from "../../Contexts";

interface EditBoosterInfoProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: () => void;
  editingBooster: BoosterData | null;
  formData: BoosterData;
  onFormDataChange: (updates: Partial<BoosterData>) => void;
}

const EditBoosterInfo: React.FC<EditBoosterInfoProps> = ({
  isOpen,
  onClose,
  onSave,
  editingBooster,
  formData,
  onFormDataChange,
}) => {
  const {userConfig, setUserConfig} = useContext(UserConfigContext)
  const [activeTab, setActiveTab] = useState<
    "visual" | "description" | "settings"
  >("visual");
  const modalRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(userConfig.defaultAutoFormat ?? true);
  const [lastFormattedText, setLastFormattedText] = useState<string>("");
  const [placeholderCredits, setPlaceholderCredits] = useState<
    Record<number, string>
  >({});

  useEffect(() => {
    const loadCredits = async () => {
      try {
        const response = await fetch("/images/placeholderboosters/credit.txt");
        const text = await response.text();

        const credits: Record<number, string> = {};
        text.split("\n").forEach((line) => {
          const trimmed = line.trim();
          if (trimmed && trimmed.includes(":")) {
            const [indexStr, nameStr] = trimmed.split(":");
            const index = indexStr?.trim();
            const name = nameStr?.trim();

            if (index && name) {
              const indexNum = parseInt(index);
              if (!isNaN(indexNum)) {
                credits[indexNum] = name;
              }
            }
          }
        });

        setPlaceholderCredits(credits);
      } catch (error) {
        console.error("Failed to load placeholder credits:", error);
      }
    };

    loadCredits();
  }, []);

  const generateKeyFromName = (name: string): string => {
    return (
      name
        .toLowerCase()
        .replace(/[^a-zA-Z0-9\s]/g, "")
        .replace(/\s+/g, "_")
        .replace(/^[0-9]+/, "") || "custom_booster"
    );
  };

  const boosterTypeOptions = [
    { value: "joker", label: "Joker Pack (Add to Jokers)" },
    { value: "consumable", label: "Consumable Pack (Add to Consumables)" },
    { value: "playing_card", label: "Playing Card Pack (Add to Hand)" },
  ];

  const handleColorChange =
    (field: "background_colour" | "special_colour") => (color: ColorResult) => {
      onFormDataChange({
        [field]: color.hex.replace("#", ""),
      });
    };

  const getPreviewColor = (field: "background_colour" | "special_colour") => {
    const color = formData[field] || "666666";
    return color.startsWith("#") ? color : `#${color}`;
  };

  const upscaleImage = (img: HTMLImageElement): string => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = 142;
    canvas.height = 190;

    if (ctx) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, 142, 190);
    }

    return canvas.toDataURL("image/png");
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            onFormDataChange({
              imagePreview: finalImageData,
              hasUserUploadedImage: true,
            });
          } else {
            alert(
              `Image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const getImageCredit = (booster: BoosterData): string | null => {
    if (booster.hasUserUploadedImage) {
      return null;
    }

    if (
      booster.placeholderCreditIndex &&
      placeholderCredits[booster.placeholderCreditIndex]
    ) {
      return placeholderCredits[booster.placeholderCreditIndex];
    }
    return null;
  };

  const toggleUndo = () => {
    const currentDesc = formData.description;
    handleInputChange("description", lastDescription, false);
    setLastDescription(currentDesc);
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        true
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }
    }

    if (field === "name") {
      onFormDataChange({
        [field]: finalValue,
        boosterKey: generateKeyFromName(finalValue),
      });
    } else {
      onFormDataChange({
        [field]: finalValue,
      });
    }
  };

  const handleNumberChange = (field: string, value: number) => {
    if (field === "extra" || field === "choose") {
      onFormDataChange({
        config: {
          ...formData.config,
          [field]: isNaN(value) ? undefined : value,
        },
      });
    } else {
      onFormDataChange({
        [field]: isNaN(value) ? undefined : value,
      });
    }
  };

  const colorButtons = [
    { tag: "{C:red}", color: "bg-balatro-red", name: "Red" },
    { tag: "{C:blue}", color: "bg-balatro-blue", name: "Blue" },
    { tag: "{C:green}", color: "bg-balatro-green", name: "Green" },
    { tag: "{C:purple}", color: "bg-balatro-purple", name: "Purple" },
    { tag: "{C:attention}", color: "bg-balatro-orange", name: "Orange" },
    { tag: "{C:money}", color: "bg-balatro-money", name: "Money" },
    { tag: "{C:gold}", color: "bg-balatro-gold-new", name: "Gold" },
    { tag: "{C:white}", color: "bg-balatro-white", name: "White" },
    { tag: "{C:inactive}", color: "bg-balatro-grey", name: "Inactive" },
    { tag: "{C:default}", color: "bg-balatro-default", name: "Default" },
  ];

  const backgroundButtons = [
    { tag: "{X:red,C:white}", color: "bg-balatro-red", name: "Red BG" },
    { tag: "{X:blue,C:white}", color: "bg-balatro-blue", name: "Blue BG" },
    { tag: "{X:mult,C:white}", color: "bg-balatro-mult", name: "Mult BG" },
    { tag: "{X:chips,C:white}", color: "bg-balatro-chips", name: "Chips BG" },
    { tag: "{X:money,C:white}", color: "bg-balatro-money", name: "Money BG" },
    {
      tag: "{X:attention,C:white}",
      color: "bg-balatro-orange",
      name: "Attention BG",
    },
  ];

  const insertTag = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "booster-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        toggleUndo();
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      setLastDescription(value);
      setLastFormattedText(value);
      handleInputChange("description", newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  const isEditingExistingBooster =
    editingBooster && formData.id === editingBooster.id;

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        onSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, onSave]);

  if (!isOpen) return null;

  const tabs = [
    { id: "visual", label: "Visual & Settings", icon: PhotoIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
    { id: "settings", label: "Advanced Settings", icon: Cog6ToothIcon },
  ];

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div className="flex items-start gap-8 max-h-[90vh]">
        <div
          ref={modalRef}
          className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden"
        >
          <div className="flex">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(
                      tab.id as "visual" | "description" | "settings"
                    )
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "visual" && (
                <div className="p-6 space-y-6">
                  <GiftIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <PhotoIcon className="h-5 w-5 text-mint" />
                        Visual Assets
                      </h4>
                      <div className="flex gap-6">
                        <div className="flex-shrink-0">
                          <div className="aspect-[142/190] w-60 rounded-lg overflow-hidden relative">
                            {formData.imagePreview ? (
                              <img
                                src={formData.imagePreview}
                                alt={formData.name}
                                className="w-full h-full object-cover"
                                draggable="false"
                              />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center border-2 border-mint/30 rounded-lg">
                                <GiftIcon className="h-16 w-16 text-mint opacity-60" />
                              </div>
                            )}
                          </div>
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            ref={fileInputRef}
                          />
                          <div className="space-y-2 mt-3">
                            <Button
                              onClick={() => fileInputRef.current?.click()}
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<PhotoIcon className="h-4 w-4" />}
                            >
                              {formData.imagePreview
                                ? "Change Image"
                                : "Upload Image"}
                            </Button>
                          </div>
                          <div className="text-center mt-2">
                            <p className="text-xs text-white-darker">
                              Accepted: 7195px or 142190px
                            </p>
                            {(() => {
                              const credit = getImageCredit(formData);
                              return credit ? (
                                <p className="text-xs text-white-darker mt-1">
                                  Credit: {credit}
                                </p>
                              ) : null;
                            })()}
                          </div>
                        </div>

                        <div className="flex-1 space-y-4">
                          <div>
                            <InputField
                              value={formData.name || ""}
                              onChange={(e) => {
                                handleInputChange(
                                  "name",
                                  e.target.value,
                                  false
                                );
                              }}
                              placeholder="Enter booster name"
                              separator={true}
                              label="Booster Name"
                              size="md"
                            />
                          </div>
                          <InputField
                            value={formData.boosterKey || ""}
                            onChange={(e) =>
                              onFormDataChange({ boosterKey: e.target.value })
                            }
                            placeholder="Enter booster key"
                            separator={true}
                            label="Booster Key (Code Name)"
                            size="md"
                          />
                          <p className="text-xs text-white-darker -mt-2">
                            Used in code generation. Auto-fills when you type
                            the name.
                          </p>

                          <div className="grid grid-cols-2 gap-4">
                            <InputDropdown
                              label="Booster Type"
                              value={formData.booster_type || "joker"}
                              onChange={(value) =>
                                onFormDataChange({
                                  booster_type: value as BoosterType,
                                  card_rules: [],
                                })
                              }
                              options={boosterTypeOptions}
                              separator={true}
                            />
                            <InputField
                              value={formData.cost?.toString() || ""}
                              onChange={(e) => {
                                const value = e.target.value;
                                handleNumberChange(
                                  "cost",
                                  value === "" ? NaN : parseInt(value)
                                );
                              }}
                              placeholder="Cost"
                              separator={true}
                              type="number"
                              label="Cost ($)"
                            />
                          </div>

                          <div>
                            <label className="block text-white-light text-sm font-medium mb-2">
                              Weight
                            </label>
                            <div className="flex items-center gap-3">
                              <input
                                type="range"
                                min="0"
                                max="10"
                                step="0.05"
                                value={formData.weight ?? 1}
                                onChange={(e) =>
                                  onFormDataChange({
                                    weight: parseFloat(e.target.value),
                                  })
                                }
                                className="flex-1 h-2 bg-black-lighter rounded appearance-none cursor-pointer"
                              />
                              <span className="text-mint font-mono w-16 text-sm">
                                {(formData.weight ?? 1).toFixed(2)}
                              </span>
                            </div>
                          </div>

                          <div className="grid grid-cols-2 gap-4">
                            <InputField
                              label="Cards in Pack"
                              value={formData.config?.extra?.toString() || ""}
                              onChange={(e) => {
                                const value = e.target.value;
                                handleNumberChange(
                                  "extra",
                                  value === "" ? NaN : parseInt(value)
                                );
                              }}
                              type="number"
                            />
                            <InputField
                              label="Cards to Choose"
                              value={formData.config?.choose?.toString() || ""}
                              onChange={(e) => {
                                const value = e.target.value;
                                handleNumberChange(
                                  "choose",
                                  value === "" ? NaN : parseInt(value)
                                );
                              }}
                              type="number"
                            />
                          </div>

                          <div>
                            <h4 className="text-white-light font-medium text-base mb-3 justify-center pt-2 flex tracking-wider items-center gap-2">
                              <BoltIcon className="h-5 w-5 text-mint" />
                              Booster Properties
                            </h4>
                            <div className="space-y-4 rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Default State
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <div className="flex items-center gap-3">
                                    <label
                                      htmlFor="unlocked"
                                      className="text-white-light text-sm"
                                    >
                                      Unlocked by Default
                                    </label>
                                  </div>
                                  <div className="flex items-center gap-3">
                                    <input
                                      type="checkbox"
                                      id="discovered"
                                      checked={formData.discovered ?? true}
                                      onChange={(e) =>
                                        onFormDataChange({
                                          discovered: e.target.checked,
                                        })
                                      }
                                      className="w-4 h-4 text-mint bg-black-darker border-black-lighter rounded focus:ring-mint focus:ring-2"
                                    />
                                    <label
                                      htmlFor="discovered"
                                      className="text-white-light text-sm"
                                    >
                                      Already Discovered
                                    </label>
                                  </div>
                                </div>
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Behavior
                                </p>
                                <div className="grid grid-cols-1 gap-y-2">
                                  <div className="flex items-center gap-3">
                                    <input
                                      type="checkbox"
                                      id="draw_hand"
                                      checked={formData.draw_hand || false}
                                      onChange={(e) =>
                                        onFormDataChange({
                                          draw_hand: e.target.checked,
                                        })
                                      }
                                      className="w-4 h-4 text-mint bg-black-darker border-black-lighter rounded focus:ring-mint focus:ring-2"
                                    />
                                    <label
                                      htmlFor="draw_hand"
                                      className="text-white-light text-sm"
                                    >
                                      Draw to Hand When Opened
                                    </label>
                                  </div>
                                </div>
                                  <div className="flex items-center gap-3">
                                    <input
                                      type="checkbox"
                                      id="instant_use"
                                      checked={formData.instant_use || false}
                                      onChange={(e) =>
                                        onFormDataChange({
                                          instant_use: e.target.checked,
                                        })
                                      }
                                      className="w-4 h-4 text-mint bg-black-darker border-black-lighter rounded focus:ring-mint focus:ring-2"
                                    />
                                    <label
                                      htmlFor="draw_hand"
                                      className="text-white-light text-sm"
                                    >
                                      Use Selected Card Instantly
                                    </label>
                                  </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              {activeTab === "description" && (
                <div className="p-6 space-y-6">
                  <DocumentTextIcon className="absolute top-12 right-16 h-28 w-28 text-black-lighter/20 -rotate-6 pointer-events-none" />

                  <div className="bg-black-darker border border-black-lighter rounded-xl p-6">
                    <div className="flex items-center justify-between mb-2">
                      <h4 className="text-white-light font-medium text-sm flex items-center gap-2">
                        <DocumentTextIcon className="h-4 w-4 text-mint" />
                        Formatting Tools
                      </h4>
                      <div className="flex items-center gap-4">
                        <span className="text-xs text-white-darker">
                          Ctrl+Z to undo
                        </span>
                        <Button
                          size="sm"
                          variant={autoFormatEnabled ? "primary" : "secondary"}
                          onClick={() => {
                            setUserConfig(prevConfig => ({
                              ...prevConfig,
                              defaultAutoFormat: !autoFormatEnabled
                            }))
                            setAutoFormatEnabled(!autoFormatEnabled)
                          }}
                          icon={<SparklesIcon className="h-3 w-3" />}
                        >
                          Auto Format
                        </Button>
                      </div>
                    </div>

                    <div className="space-y-4">
                      <div>
                        <p className="text-white-light text-sm mb-3 font-medium">
                          Text Colors
                        </p>
                        <div className="flex flex-wrap gap-3">
                          {colorButtons.map((item, index) => (
                            <button
                              key={index}
                              onClick={() => insertTag(item.tag)}
                              title={item.name}
                              className={`w-8 h-8 ${item.color} rounded border border-black-lighter hover:scale-110 transition-transform z-10`}
                            />
                          ))}
                        </div>
                      </div>

                      <div>
                        <p className="text-white-light text-sm mb-3 font-medium">
                          Backgrounds
                        </p>
                        <div className="flex flex-wrap gap-3">
                          {backgroundButtons.map((item, index) => (
                            <button
                              key={index}
                              onClick={() => insertTag(item.tag)}
                              title={item.name}
                              className={`w-8 h-8 ${item.color} rounded border-2 border-white-light hover:scale-110 transition-transform`}
                            />
                          ))}
                        </div>
                      </div>

                      <div>
                        <p className="text-white-light text-sm mb-3 font-medium">
                          Special Effects
                        </p>
                        <div className="flex gap-3 flex-wrap">
                          <Button
                            size="sm"
                            variant="secondary"
                            onClick={() => insertTag("[s]", false)}
                            icon={<ArrowPathIcon className="h-3 w-3" />}
                          >
                            New Line
                          </Button>
                          <Button
                            size="sm"
                            variant="secondary"
                            onClick={() => insertTag("{s:1.1}")}
                            icon={<SparklesIcon className="h-3 w-3" />}
                          >
                            Scale
                          </Button>
                          <Button
                            size="sm"
                            variant="secondary"
                            onClick={() => insertTag("{E:1}")}
                            icon={<BoltIcon className="h-3 w-3" />}
                          >
                            Float
                          </Button>
                          <Button
                            size="sm"
                            variant="secondary"
                            onClick={() => insertTag("{}")}
                          >
                            Reset
                          </Button>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="w-full -mt-2">
                    <label className="block text-white-light text-sm font-medium mb-2">
                      Description Text
                    </label>
                    <textarea
                      id="booster-description-edit"
                      value={formData.description || ""}
                      onChange={(e) =>
                        handleInputChange("description", e.target.value)
                      }
                      onKeyDown={handleKeyDown}
                      placeholder="A {C:purple}custom{} booster pack with {C:blue}unique{} cards."
                      className="w-full h-32 px-4 py-3 bg-black-darker border-2 border-black-light rounded-lg text-white-light placeholder-white-darker focus:border-mint focus:outline-none resize-none"
                    />
                  </div>
                </div>
              )}

              {activeTab === "settings" && (
                <div className="p-6 space-y-6">
                  <Cog6ToothIcon className="absolute top-12 right-16 h-28 w-28 text-black-lighter/20 -rotate-6 pointer-events-none" />

                  <div className="space-y-4">
                    <InputField
                      label="Kind"
                      value={formData.kind || ""}
                      onChange={(e) =>
                        onFormDataChange({
                          kind: e.target.value || undefined,
                        })
                      }
                      placeholder="e.g. Ephemeral"
                    />

                    <InputField
                      label="Group Key"
                      value={formData.group_key || ""}
                      onChange={(e) =>
                        onFormDataChange({
                          group_key: e.target.value || undefined,
                        })
                      }
                      placeholder="e.g. k_booster_group_mystical"
                    />

                    <div className="flex items-center gap-3">
                      <input
                        type="checkbox"
                        id="hidden"
                        checked={formData.hidden || false}
                        onChange={(e) =>
                          onFormDataChange({ hidden: e.target.checked })
                        }
                        className="w-4 h-4 text-mint bg-black-darker border-black-lighter rounded focus:ring-mint focus:ring-2"
                      />
                      <label
                        htmlFor="hidden"
                        className="text-white-light text-sm"
                      >
                        Hidden from collection
                      </label>
                    </div>
                  </div>

                  <div>
                    <h3 className="text-white-light font-medium mb-4">
                      Pack Colors (Optional)
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <div>
                        <label className="block text-white-light text-sm font-medium mb-2">
                          Background Color
                        </label>
                        <SketchPicker
                          color={getPreviewColor("background_colour")}
                          onChange={handleColorChange("background_colour")}
                          onChangeComplete={handleColorChange(
                            "background_colour"
                          )}
                          disableAlpha={true}
                          width="100%"
                          styles={{
                            default: {
                              picker: {
                                background: "#1A1A1A",
                                border: "1px solid #333333",
                                borderRadius: "0.5rem",
                                boxShadow: "none",
                                fontFamily: "inherit",
                              },
                            },
                          }}
                        />
                      </div>

                      <div>
                        <label className="block text-white-light text-sm font-medium mb-2">
                          Special Color
                        </label>
                        <SketchPicker
                          color={getPreviewColor("special_colour")}
                          onChange={handleColorChange("special_colour")}
                          onChangeComplete={handleColorChange("special_colour")}
                          disableAlpha={true}
                          width="100%"
                          styles={{
                            default: {
                              picker: {
                                background: "#1A1A1A",
                                border: "1px solid #333333",
                                borderRadius: "0.5rem",
                                boxShadow: "none",
                                fontFamily: "inherit",
                              },
                            },
                          }}
                        />
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button variant="primary" onClick={onSave} className="flex-1">
              {isEditingExistingBooster ? "Save Changes" : "Create Booster"}
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="booster"
              data={{
                id: formData.id || "preview",
                name: formData.name || "New Booster Pack",
                description:
                  formData.description ||
                  "A custom booster pack with unique cards.",
                imagePreview: formData.imagePreview,
                cost: formData.cost,
                config: {
                  extra: formData.config.extra,
                  choose: formData.config.choose,
                },
                booster_type: formData.booster_type,
              }}
              size="lg"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditBoosterInfo;

```

### src\components\pages\consumables\ConsumableCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  PuzzlePieceIcon,
  DocumentDuplicateIcon,
  TrashIcon,
  LockOpenIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  ArrowDownTrayIcon,
} from "@heroicons/react/24/solid";

import Tooltip from "../../generic/Tooltip";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { validateJokerName } from "../../generic/validationUtils";
import { ConsumableData } from "../../data/BalatroUtils";

interface ConsumableCardProps {
  consumable: ConsumableData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onExport: () => void;
  onQuickUpdate: (updates: Partial<ConsumableData>) => void;
  setName: string;
  setColor: string;
  availableSetOptions: { value: string; label: string }[];
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const getConsumableSetColor = (set: string): string => {
  switch (set) {
    case "Tarot":
      return "#b26cbb";
    case "Planet":
      return "#13afce";
    case "Spectral":
      return "#4584fa";
    default:
      return "#666666";
  }
};

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const ConsumableCard: React.FC<ConsumableCardProps> = ({
  consumable,
  onEditInfo,
  onEditRules,
  onDuplicate,
  onExport,
  onQuickUpdate,
  setName,
  setColor,
  availableSetOptions,
  showConfirmation,
  onDelete,
}) => {
  const rulesCount = consumable.rules?.length || 0;

  const [showSetMenu, setShowSetMenu] = useState(false);
  const [editingName, setEditingName] = useState(false);
  const [editingCost, setEditingCost] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(consumable.name);
  const [tempCost, setTempCost] = useState(consumable.cost || 3);
  const [tempDescription, setTempDescription] = useState(
    consumable.description
  );

  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);

  const [imageLoadError, setImageLoadError] = useState(false);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);

  const [nameValidationError, setNameValidationError] = useState<string>("");

  const handleEditRules = () => {
    onEditRules();
  };

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);

    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid name");
      return;
    }

    onQuickUpdate({ name: tempName });
    setEditingName(false);
    setNameValidationError("");
  };

  const handleCostSave = () => {
    onQuickUpdate({ cost: tempCost });
    setEditingCost(false);
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleSetChange = (value: string) => {
    onQuickUpdate({ set: value });
    setShowSetMenu(false);
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const isUnlocked = consumable.unlocked !== false;
  const isDiscovered = consumable.discovered !== false;

  const propertyIcons = [
    {
      icon: isUnlocked ? (
        <LockOpenIcon className="w-full h-full" />
      ) : (
        <LockClosedIcon className="w-full h-full" />
      ),
      tooltip: isUnlocked ? "Unlocked by Default" : "Locked by Default",
      variant: "warning" as const,
      isEnabled: isUnlocked,
      onClick: () => onQuickUpdate({ unlocked: !isUnlocked }),
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
  ];

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="px-4 -mb-6 z-20 py-1 rounded-md border-2 font-bold cursor-pointer transition-all bg-black  tracking-widest border-balatro-money text-balatro-money w-18 text-center">
          {editingCost ? (
            <input
              type="number"
              value={tempCost}
              onChange={(e) => setTempCost(parseInt(e.target.value))}
              onBlur={handleCostSave}
              onKeyDown={(e) => {
                if (e.key === "Enter") handleCostSave();
                if (e.key === "Escape") {
                  setTempCost(consumable.cost || 3);
                  setEditingCost(false);
                }
              }}
              className="w-full bg-transparent text-center outline-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
              autoFocus
            />
          ) : (
            <span
              onClick={() => {
                setTempCost(consumable.cost || 3);
                setEditingCost(true);
              }}
            >
              ${consumable.cost || 3}
            </span>
          )}
        </div>

        <div className="w-42 z-10 relative">
          <div className="relative">
            {consumable.imagePreview && !imageLoadError ? (
              <>
                <img
                  src={consumable.imagePreview}
                  alt={consumable.name}
                  className="w-full h-full object-contain"
                  draggable="false"
                  onError={() => setImageLoadError(true)}
                />
                {consumable.overlayImagePreview && (
                  <img
                    src={consumable.overlayImagePreview}
                    alt={`${consumable.name} overlay`}
                    className="absolute inset-0 w-full h-full object-contain"
                    draggable="false"
                  />
                )}
              </>
            ) : (
              <img
                src={
                  !fallbackAttempted
                    ? "/images/placeholderjokers/placeholder-joker.png"
                    : "/images/placeholder-joker.png"
                }
                alt="Default Consumable"
                className="w-full h-full object-contain"
                draggable="false"
                onError={() => {
                  if (!fallbackAttempted) {
                    setFallbackAttempted(true);
                  }
                }}
              />
            )}
          </div>
        </div>

        <div className="relative z-30">
          <div
            className="px-6 py-1 -mt-6 rounded-md border-2 text-sm tracking-wide font-medium cursor-pointer transition-all bg-black"
            style={{
              borderColor: setColor,
              color: setColor,
            }}
            onClick={() => setShowSetMenu(!showSetMenu)}
          >
            {setName}
          </div>

          {showSetMenu && (
            <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1 border-2 border-black-lighter rounded-lg shadow-lg z-50 overflow-hidden">
              {availableSetOptions.map((set) => (
                <div
                  key={set.value}
                  className="px-3 py-1 text-xs font-medium cursor-pointer transition-all hover:bg-opacity-20 bg-black border-b border-black-lighter last:border-b-0"
                  style={{
                    color: getConsumableSetColor(set.value),
                  }}
                  onClick={() => handleSetChange(set.value)}
                >
                  {set.label}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Consumable" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                showConfirmation({
                  type: "danger",
                  title: "Delete Consumable",
                  description: `Are you sure you want to delete "${consumable.name}"? This action cannot be undone.`,
                  confirmText: "Delete Forever",
                  cancelText: "Keep It",
                  confirmVariant: "danger",
                  onConfirm: () => onDelete(),
                });
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <div className="w-full">
                  <input
                    type="text"
                    value={tempName}
                    onChange={(e) => {
                      setTempName(e.target.value);
                      if (nameValidationError) {
                        const validation = validateJokerName(e.target.value);
                        if (validation.isValid) {
                          setNameValidationError("");
                        }
                      }
                    }}
                    onBlur={() => {
                      if (!nameValidationError) {
                        handleNameSave();
                      }
                    }}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleNameSave();
                      }
                      if (e.key === "Escape") {
                        setTempName(consumable.name);
                        setEditingName(false);
                        setNameValidationError("");
                      }
                    }}
                    className={`text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text ${
                      nameValidationError ? "border-b-2 border-balatro-red" : ""
                    }`}
                    autoFocus
                  />
                </div>
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(consumable.name);
                    setEditingName(true);
                    setNameValidationError("");
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {consumable.name}
                </h3>
              )}
            </div>

            <div className=" mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(consumable.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(consumable.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(consumable.description),
                  }}
                />
              )}
            </div>

            <div className="flex items-center justify-between mb-4 px-12 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center justify-between px-8 overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 hover:text-mint-light transition-colors cursor-pointer group"
                onClick={handleEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <PuzzlePieceIcon className="h-6 w-6 group-hover:text-mint-lighter text-white transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            
            <Tooltip content="Export Consumable" show={hoveredButton === "export"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onExport}
                onMouseEnter={() => handleButtonHover("export")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <ArrowDownTrayIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ConsumableCard;

```

### src\components\pages\consumables\EditConsumableInfo.tsx

```
import React, { useState, useRef, useEffect, useCallback, useContext } from "react";
import {
  PhotoIcon,
  SparklesIcon,
  BoltIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
} from "@heroicons/react/24/outline";
import InputField from "../../generic/InputField";
import InputDropdown from "../../generic/InputDropdown";
import Checkbox from "../../generic/Checkbox";
import Button from "../../generic/Button";
import BalatroCard from "../../generic/BalatroCard";
import InfoDescriptionBox from "../../generic/InfoDescriptionBox";
import { ConsumableData, slugify } from "../../data/BalatroUtils";
import {
  validateJokerName,
  validateDescription,
  ValidationResult,
} from "../../generic/validationUtils";
import { ConsumableSetData } from "../../data/BalatroUtils";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import { UserConfigContext } from "../../Contexts";

interface EditConsumableInfoProps {
  isOpen: boolean;
  consumable: ConsumableData;
  onClose: () => void;
  onSave: (consumable: ConsumableData) => void;
  onDelete: (consumableId: string) => void;
  modPrefix: string;
  availableSets: ConsumableSetData[];
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const EditConsumableInfo: React.FC<EditConsumableInfoProps> = ({
  isOpen,
  consumable,
  onClose,
  onSave,
  onDelete,
  availableSets,
  showConfirmation,
}) => {
  const {userConfig, setUserConfig} = useContext(UserConfigContext)
  const [formData, setFormData] = useState<ConsumableData>(consumable);
  const [activeTab, setActiveTab] = useState<"visual" | "description">(
    "visual"
  );
  const [placeholderError, setPlaceholderError] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const overlayFileInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(userConfig.defaultAutoFormat ?? true);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);
  const [lastFormattedText, setLastFormattedText] = useState<string>("");

  const [placeholderCredits, setPlaceholderCredits] = useState<
    Record<number, string>
  >({});

  const [validationResults, setValidationResults] = useState<{
    name?: ValidationResult;
    description?: ValidationResult;
  }>({});

  const setOptions = [
    { value: "Tarot", label: "Tarot" },
    { value: "Planet", label: "Planet" },
    { value: "Spectral", label: "Spectral" },
    ...availableSets.map((set) => ({
      value: set.key,
      label: set.name,
    })),
  ];

  const validateField = (field: string, value: string) => {
    let result: ValidationResult;
    switch (field) {
      case "name":
        result = validateJokerName(value);
        break;
      case "description":
        result = validateDescription(value);
        break;
      default:
        return;
    }

    setValidationResults((prev) => ({
      ...prev,
      [field]: result,
    }));
  };

  const getCurrentSetName = (setKey: string): string => {
    const customSet = availableSets.find((s) => s.key === setKey);
    return customSet?.name || setKey;
  };

  const getCurrentSetColor = (setKey: string): string => {
    const customSet = availableSets.find((s) => s.key === setKey);
    return customSet
      ? customSet.primary_colour.startsWith("#")
        ? customSet.primary_colour
        : `#${customSet.primary_colour}`
      : setKey === "Tarot"
      ? "#b26cbb"
      : setKey === "Planet"
      ? "#13afce"
      : setKey === "Spectral"
      ? "#4584fa"
      : "#666666";
  };

  useEffect(() => {
    const loadCredits = async () => {
      try {
        const response = await fetch(
          "/images/placeholderconsumables/credit.txt"
        );
        const text = await response.text();
        console.log("Raw credit file content:", JSON.stringify(text));

        const credits: Record<number, string> = {};

        text.split("\n").forEach((line, lineIndex) => {
          const trimmed = line.trim();
          console.log(`Line ${lineIndex}: "${trimmed}"`);

          if (trimmed && trimmed.includes(":")) {
            const [indexStr, nameStr] = trimmed.split(":");
            const index = indexStr?.trim();
            const name = nameStr?.trim();

            if (index && name) {
              const indexNum = parseInt(index);
              if (!isNaN(indexNum)) {
                credits[indexNum] = name;
              }
            }
          }
        });

        setPlaceholderCredits(credits);
      } catch (error) {
        console.error("Failed to load placeholder credits:", error);
      }
    };

    loadCredits();
  }, []);

  const handleSave = useCallback(() => {
    const nameValidation = validateJokerName(formData.name);
    const descValidation = validateDescription(formData.description);

    if (!nameValidation.isValid || !descValidation.isValid) {
      setValidationResults({
        name: nameValidation,
        description: descValidation,
      });
      return;
    }

    onSave(formData);
    onClose();
  }, [formData, onSave, onClose]);

  useEffect(() => {
    if (isOpen) {
      setFormData({
        ...consumable,
        unlocked: consumable.unlocked !== false,
        discovered: consumable.discovered !== false,
        hidden: consumable.hidden === true,
        can_repeat_soul: consumable.can_repeat_soul === true,
        consumableKey: consumable.consumableKey || slugify(consumable.name),
        hasUserUploadedImage: consumable.hasUserUploadedImage || false,
      });
      setPlaceholderError(false);
      setLastDescription(consumable.description || "");
      setLastFormattedText("");
      setValidationResults({});
    }
  }, [isOpen, consumable]);

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        handleSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, handleSave]);

  if (!isOpen) return null;

  const parseTag = (tag: string): Record<string, string> => {
    const content = tag.slice(1, -1);
    if (!content) return {};

    const modifiers: Record<string, string> = {};
    const parts = content.split(",");

    for (const part of parts) {
      const [key, value] = part.split(":");
      if (key && value) {
        modifiers[key.trim()] = value.trim();
      }
    }

    return modifiers;
  };

  const buildTag = (modifiers: Record<string, string>): string => {
    if (Object.keys(modifiers).length === 0) return "{}";

    const parts = Object.entries(modifiers).map(
      ([key, value]) => `${key}:${value}`
    );
    return `{${parts.join(",")}}`;
  };

  const handleOverlayImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              overlayImagePreview: finalImageData,
            });
          } else {
            alert(
              `Overlay image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        false
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }

      setFormData({
        ...formData,
        [field]: finalValue,
      });
    } else if (field === "name") {
      setFormData({
        ...formData,
        [field]: value,
        consumableKey: slugify(value),
      });
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    validateField(field, finalValue);
  };

  const handleNumberChange = (field: string, value: number) => {
    setFormData({
      ...formData,
      [field]: isNaN(value) ? 0 : value,
    });
  };

  const handleCheckboxChange = (field: string, checked: boolean) => {
    setFormData({
      ...formData,
      [field]: checked,
    });
  };

  const handleSetChange = (value: string) => {
    setFormData({
      ...formData,
      set: value,
    });
  };

  const upscaleImage = (img: HTMLImageElement): string => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = 142;
    canvas.height = 190;

    if (ctx) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, 142, 190);
    }

    return canvas.toDataURL("image/png");
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              imagePreview: finalImageData,
              hasUserUploadedImage: true,
            });
            setPlaceholderError(false);
          } else {
            alert(
              `Image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const getImageCredit = (consumable: ConsumableData): string | null => {
    if (consumable.hasUserUploadedImage) {
      return null;
    }

    if (
      consumable.placeholderCreditIndex &&
      placeholderCredits[consumable.placeholderCreditIndex]
    ) {
      return placeholderCredits[consumable.placeholderCreditIndex];
    }
    return null;
  };

  const handleDelete = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Consumable",
      description: `Are you sure you want to delete "${formData.name}"? This action cannot be undone.`,
      confirmText: "Delete Forever",
      cancelText: "Keep It",
      onConfirm: () => {
        onDelete(consumable.id);
        onClose();
      },
    });
  };

  const insertTagSmart = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "consumable-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    const tagMatch = selectedText.match(/^(\{[^}]*\})(.*?)(\{\})$/);

    if (tagMatch) {
      const [, openTag, content, closeTag] = tagMatch;
      const modifiers = parseTag(openTag);

      const newTagContent = tag.slice(1, -1);
      const [newKey, newValue] = newTagContent.split(":");

      if (newKey && newValue) {
        modifiers[newKey] = newValue;
      }

      const newOpenTag = buildTag(modifiers);
      const newSelectedText = `${newOpenTag}${content}${closeTag}`;

      newText =
        currentValue.substring(0, startPos) +
        newSelectedText +
        currentValue.substring(endPos);
      newCursorPos = startPos + newOpenTag.length + content.length + 2;
    } else if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const tabs = [
    { id: "visual", label: "Visual & Properties", icon: PhotoIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
  ];

  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        const currentDesc = formData.description;
        handleInputChange("description", lastDescription, false);
        setLastDescription(currentDesc);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      setLastDescription(value);
      setLastFormattedText(value);
      handleInputChange("description", newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div className="flex items-start gap-8 max-h-[90vh]">
        <div
          ref={modalRef}
          className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden"
        >
          <div className="flex ">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(tab.id as "visual" | "description")
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "visual" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <PhotoIcon className="h-5 w-5 text-mint" />
                        Visual Assets
                      </h4>
                      <div className="flex gap-6">
                        <div className="flex-shrink-0">
                          <div className="aspect-[142/190] w-60 rounded-lg overflow-hidden relative">
                            {formData.imagePreview ? (
                              <>
                                <img
                                  src={formData.imagePreview}
                                  alt={formData.name}
                                  className="w-full h-full object-cover"
                                  draggable="false"
                                  onError={() => setPlaceholderError(true)}
                                />
                                {formData.overlayImagePreview && (
                                  <img
                                    src={formData.overlayImagePreview}
                                    alt={`${formData.name} overlay`}
                                    className="absolute inset-0 w-full h-full object-cover"
                                    draggable="false"
                                  />
                                )}
                              </>
                            ) : !placeholderError ? (
                              <img
                                src={
                                  !fallbackAttempted
                                    ? "/images/placeholderjokers/placeholder-joker.png"
                                    : "/images/placeholder-joker.png"
                                }
                                alt="Placeholder Consumable"
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => {
                                  if (!fallbackAttempted) {
                                    setFallbackAttempted(true);
                                  } else {
                                    setPlaceholderError(true);
                                  }
                                }}
                              />
                            ) : (
                              <PhotoIcon className="h-16 w-16 text-white-darker opacity-50 mx-auto my-auto" />
                            )}
                          </div>
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            ref={fileInputRef}
                          />
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleOverlayImageUpload}
                            className="hidden"
                            ref={overlayFileInputRef}
                          />
                          <div className="space-y-2 mt-3">
                            <Button
                              onClick={() => fileInputRef.current?.click()}
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<PhotoIcon className="h-4 w-4" />}
                            >
                              {formData.imagePreview
                                ? "Change Main Image"
                                : "Upload Main Image"}
                            </Button>
                            <Button
                              onClick={() =>
                                overlayFileInputRef.current?.click()
                              }
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<SparklesIcon className="h-4 w-4" />}
                            >
                              {formData.overlayImagePreview
                                ? "Change Overlay"
                                : "Add Overlay"}
                            </Button>
                            {formData.overlayImagePreview && (
                              <Button
                                onClick={() =>
                                  handleInputChange(
                                    "overlayImagePreview",
                                    "",
                                    false
                                  )
                                }
                                variant="danger"
                                className="w-full"
                                size="sm"
                              >
                                Remove Overlay
                              </Button>
                            )}
                          </div>
                          <div className="text-center mt-2">
                            <p className="text-xs text-white-darker">
                              Accepted: 7195px or 142190px each
                            </p>
                            {(() => {
                              const credit = getImageCredit(formData);
                              return credit ? (
                                <p className="text-xs text-white-darker mt-1">
                                  Credit: {credit}
                                </p>
                              ) : null;
                            })()}
                          </div>
                        </div>

                        <div className="flex-1 space-y-4">
                          <div>
                            <InputField
                              value={formData.name}
                              onChange={(e) =>
                                handleInputChange("name", e.target.value, false)
                              }
                              placeholder="Enter consumable name"
                              separator={true}
                              label="Consumable Name"
                              size="md"
                              error={
                                validationResults.name &&
                                !validationResults.name.isValid
                                  ? validationResults.name.error
                                  : undefined
                              }
                            />
                          </div>
                          <InputField
                            value={formData.consumableKey || ""}
                            onChange={(e) =>
                              handleInputChange(
                                "consumableKey",
                                e.target.value,
                                false
                              )
                            }
                            placeholder="Enter consumable key"
                            separator={true}
                            label="Consumable Key (Code Name)"
                            size="md"
                          />
                          <p className="text-xs text-white-darker -mt-2">
                            Used in code generation. Auto-fills when you type
                            the name.
                          </p>

                          <div className="grid grid-cols-2 gap-4">
                            <InputDropdown
                              value={formData.set}
                              onChange={handleSetChange}
                              options={setOptions}
                              separator={true}
                              label="Consumable Set"
                            />
                            <InputField
                              value={formData.cost?.toString() || "3"}
                              onChange={(e) =>
                                handleNumberChange(
                                  "cost",
                                  parseInt(e.target.value)
                                )
                              }
                              placeholder="Cost"
                              separator={true}
                              type="number"
                              label="Cost ($)"
                            />
                          </div>

                          <div>
                            <h4 className="text-white-light font-medium text-base mb-3 justify-center pt-2 flex tracking-wider items-center gap-2">
                              <BoltIcon className="h-5 w-5 text-mint" />
                              Consumable Properties
                            </h4>
                            <div className="space-y-4 rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Default State
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="unlocked_edit"
                                    label="Unlocked by Default"
                                    checked={formData.unlocked !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange("unlocked", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="discovered_edit"
                                    label="Already Discovered"
                                    checked={formData.discovered !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "discovered",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "description" && (
                <InfoDescriptionBox
                  value={formData.description}
                  onChange={(value, shouldAutoFormat) =>
                    handleInputChange("description", value, shouldAutoFormat)
                  }
                  onKeyDown={handleKeyDown}
                  item={formData}
                  itemType="consumable"
                  textAreaId="consumable-description-edit"
                  autoFormatEnabled={autoFormatEnabled}
                  onAutoFormatToggle={() => {
                    setUserConfig(prevConfig => ({
                      ...prevConfig,
                      defaultAutoFormat: !autoFormatEnabled
                    }))
                    setAutoFormatEnabled(!autoFormatEnabled)
                  }}
                  validationResult={validationResults.description}
                  placeholder="Describe your consumable's effects using Balatro formatting..."
                  onInsertTag={insertTagSmart}
                />
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button variant="primary" onClick={handleSave} className="flex-1">
              Save Changes
            </Button>
            <Button
              onClick={handleDelete}
              onTouchEnd={handleDelete}
              variant="danger"
              className="px-8"
            >
              Delete
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto pb-40">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="consumable"
              data={{
                id: formData.id,
                name: formData.name,
                description: formData.description,
                imagePreview: formData.imagePreview,
                overlayImagePreview: formData.overlayImagePreview,
                cost: formData.cost,
                set: formData.set,
              }}
              size="lg"
              setName={getCurrentSetName(formData.set)}
              setColor={getCurrentSetColor(formData.set)}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditConsumableInfo;

```

### src\components\pages\DecksPage.tsx

```
const DecksPage: React.FC = () => {
  return (
    <div className="min-h-screen">
      <div className="p-8 font-lexend max-w-7xl mx-auto">
        <h1 className="text-3xl text-white-light tracking-widest text-center">
          Decks
        </h1>
      </div>
    </div>
  );
};

export default DecksPage;

```

### src\components\pages\editions\EditEditionInfo.tsx

```
import React, {
  useState,
  useRef,
  useEffect,
  useCallback,
  useContext,
} from "react";
import {
  BoltIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
  CogIcon,
} from "@heroicons/react/24/outline";
import InputField from "../../generic/InputField";
import InputDropdown from "../../generic/InputDropdown";
import Checkbox from "../../generic/Checkbox";
import Button from "../../generic/Button";
import BalatroCard from "../../generic/BalatroCard";
import InfoDescriptionBox from "../../generic/InfoDescriptionBox";
import {
  CUSTOM_SHADERS,
  EditionData,
  slugify,
  VANILLA_SHADERS,
} from "../../data/BalatroUtils";
import {
  validateJokerName,
  validateDescription,
  ValidationResult,
} from "../../generic/validationUtils";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import { UserConfigContext } from "../../Contexts";

interface EditEditionInfoProps {
  isOpen: boolean;
  edition: EditionData;
  onClose: () => void;
  onSave: (edition: EditionData) => void;
  onDelete: (editionId: string) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const vanillaSounds = [
  { value: "foil1", label: "Foil 1" },
  { value: "holo1", label: "Holo 1" },
  { value: "polychrome1", label: "Polychrome 1" },
  { value: "negative1", label: "Negative 1" },
  { value: "card1", label: "Card 1" },
  { value: "chips1", label: "Chips 1" },
  { value: "generic1", label: "Generic 1" },
];

const shaderOptions = [
  { value: "", label: "None" },
  ...VANILLA_SHADERS.map((shader) => ({
    value: shader.key,
    label: shader.label,
  })),
  ...CUSTOM_SHADERS.map((shader) => ({
    value: shader.key,
    label: shader.label,
  })),
];

const EditEditionInfo: React.FC<EditEditionInfoProps> = ({
  isOpen,
  edition,
  onClose,
  onSave,
  onDelete,
  showConfirmation,
}) => {
  const { userConfig, setUserConfig } = useContext(UserConfigContext);
  const [formData, setFormData] = useState<EditionData>(edition);
  const [activeTab, setActiveTab] = useState<
    "properties" | "description" | "advanced"
  >("properties");
  const modalRef = useRef<HTMLDivElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(
    userConfig.defaultAutoFormat ?? true
  );
  const [lastFormattedText, setLastFormattedText] = useState<string>("");

  const [validationResults, setValidationResults] = useState<{
    name?: ValidationResult;
    description?: ValidationResult;
  }>({});

  const [isEditingWeight, setIsEditingWeight] = useState(false);
  const [weightInputValue, setWeightInputValue] = useState("");

  const handleWeightClick = () => {
    setWeightInputValue((formData.weight ?? 0).toString());
    setIsEditingWeight(true);
  };

  const handleWeightInputBlur = () => {
    const numValue = parseFloat(weightInputValue);
    if (!isNaN(numValue) && numValue >= 0 && numValue <= 25) {
      setFormData((prev) => ({
        ...prev,
        weight: numValue,
      }));
    }
    setIsEditingWeight(false);
  };

  const handleWeightInputKeyDown = (
    e: React.KeyboardEvent<HTMLInputElement>
  ) => {
    if (e.key === "Enter") {
      handleWeightInputBlur();
    } else if (e.key === "Escape") {
      setIsEditingWeight(false);
    }
  };

  const validateField = (field: string, value: string) => {
    let result: ValidationResult;
    switch (field) {
      case "name":
        result = validateJokerName(value);
        break;
      case "description":
        result = validateDescription(value);
        break;
      default:
        return;
    }

    setValidationResults((prev) => ({
      ...prev,
      [field]: result,
    }));
  };

  const handleSave = useCallback(() => {
    const nameValidation = validateJokerName(formData.name);
    const descValidation = validateDescription(formData.description);

    if (!nameValidation.isValid || !descValidation.isValid) {
      setValidationResults({
        name: nameValidation,
        description: descValidation,
      });
      return;
    }

    onSave(formData);
    onClose();
  }, [formData, onSave, onClose]);

  useEffect(() => {
    if (isOpen) {
      setFormData({
        ...edition,
        unlocked: edition.unlocked !== false,
        discovered: edition.discovered !== false,
        no_collection: edition.no_collection === true,
        in_shop: edition.in_shop === true,
        apply_to_float: edition.apply_to_float === true,
        disable_shadow: edition.disable_shadow === true,
        disable_base_shader: edition.disable_base_shader === true,
        badge_colour: edition.badge_colour || "#FFAA00",
        editionKey: edition.editionKey || slugify(edition.name),
        sound: edition.sound || "foil1",
      });
      setLastDescription(edition.description || "");
      setLastFormattedText("");
      setValidationResults({});
    }
  }, [isOpen, edition]);

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        handleSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, handleSave]);

  if (!isOpen) return null;

  const parseTag = (tag: string): Record<string, string> => {
    const content = tag.slice(1, -1);
    if (!content) return {};

    const modifiers: Record<string, string> = {};
    const parts = content.split(",");

    for (const part of parts) {
      const [key, value] = part.split(":");
      if (key && value) {
        modifiers[key.trim()] = value.trim();
      }
    }

    return modifiers;
  };

  const buildTag = (modifiers: Record<string, string>): string => {
    if (Object.keys(modifiers).length === 0) return "{}";

    const parts = Object.entries(modifiers).map(
      ([key, value]) => `${key}:${value}`
    );
    return `{${parts.join(",")}}`;
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        false
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }

      setFormData({
        ...formData,
        [field]: finalValue,
      });
    } else if (field === "name") {
      setFormData({
        ...formData,
        [field]: value,
        editionKey: slugify(value),
      });
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    validateField(field, finalValue);
  };

  const handleCheckboxChange = (field: string, checked: boolean) => {
    setFormData({
      ...formData,
      [field]: checked,
    });
  };

  const handleShaderChange = (value: string) => {
    setFormData((prev) => ({
      ...prev,
      shader: value === "" ? false : value,
    }));
  };

  const handleDelete = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Edition",
      description: `Are you sure you want to delete "${formData.name}"? This action cannot be undone.`,
      confirmText: "Delete Forever",
      cancelText: "Keep It",
      onConfirm: () => {
        onDelete(edition.id);
        onClose();
      },
    });
  };

  const insertTagSmart = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "edition-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    const tagMatch = selectedText.match(/^(\{[^}]*\})(.*?)(\{\})$/);

    if (tagMatch) {
      const [, openTag, content, closeTag] = tagMatch;
      const modifiers = parseTag(openTag);

      const newTagContent = tag.slice(1, -1);
      const [newKey, newValue] = newTagContent.split(":");

      if (newKey && newValue) {
        modifiers[newKey] = newValue;
      }

      const newOpenTag = buildTag(modifiers);
      const newSelectedText = `${newOpenTag}${content}${closeTag}`;

      newText =
        currentValue.substring(0, startPos) +
        newSelectedText +
        currentValue.substring(endPos);
      newCursorPos = startPos + newOpenTag.length + content.length + 2;
    } else if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const tabs = [
    { id: "properties", label: "Properties", icon: BoltIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
    { id: "advanced", label: "Advanced", icon: CogIcon },
  ];

  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        const currentDesc = formData.description;
        handleInputChange("description", lastDescription, false);
        setLastDescription(currentDesc);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      setLastDescription(value);
      setLastFormattedText(value);
      handleInputChange("description", newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div ref={modalRef} className="flex items-start gap-8 max-h-[90vh]">
        <div className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden">
          <div className="flex ">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(
                      tab.id as "properties" | "description" | "advanced"
                    )
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "properties" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6 max-w-2xl mx-auto">
                    <div>
                      <h4 className="text-white-light font-medium text-lg mb-6 text-center">
                        Edition Configuration
                      </h4>

                      <div className="space-y-6">
                        <div>
                          <InputField
                            value={formData.name}
                            onChange={(e) =>
                              handleInputChange("name", e.target.value, false)
                            }
                            placeholder="Enter edition name"
                            separator={true}
                            label="Edition Name"
                            size="md"
                            error={
                              validationResults.name &&
                              !validationResults.name.isValid
                                ? validationResults.name.error
                                : undefined
                            }
                          />
                        </div>

                        <InputField
                          value={formData.editionKey || ""}
                          onChange={(e) =>
                            handleInputChange(
                              "editionKey",
                              e.target.value,
                              false
                            )
                          }
                          placeholder="Enter edition key"
                          separator={true}
                          label="Edition Key (Code Name)"
                          size="md"
                        />
                        <p className="text-xs text-white-darker -mt-2">
                          Used in code generation. Auto-fills when you type the
                          name.
                        </p>

                        <InputDropdown
                          label="Shader"
                          value={
                            formData.shader === false
                              ? ""
                              : formData.shader || ""
                          }
                          onChange={handleShaderChange}
                          options={shaderOptions}
                          placeholder="Select a shader"
                          size="md"
                        />

                        <InputField
                          type="number"
                          label="Extra Cost"
                          value={(formData.extra_cost ?? 0).toString()}
                          onChange={(e) =>
                            setFormData((prev) => ({
                              ...prev,
                              extra_cost: parseInt(e.target.value) || 0,
                            }))
                          }
                          size="md"
                        />

                        <div className="p-4 rounded-lg border border-black-lighter bg-black-darker/30">
                          <h3 className="text-white-light font-medium mb-4">
                            Appearance Weight
                          </h3>
                          <div className="space-y-3">
                            <div className="flex items-center gap-3">
                              <input
                                type="range"
                                min="0"
                                max="20"
                                step="0.25"
                                value={formData.weight ?? 0}
                                onChange={(e) =>
                                  setFormData((prev) => ({
                                    ...prev,
                                    weight: parseFloat(e.target.value) ?? 0,
                                  }))
                                }
                                className="flex-1 h-2 bg-black-lighter rounded appearance-none cursor-pointer"
                              />
                              {isEditingWeight ? (
                                <input
                                  type="number"
                                  min="0"
                                  max="20"
                                  step="0.25"
                                  value={weightInputValue}
                                  onChange={(e) =>
                                    setWeightInputValue(e.target.value)
                                  }
                                  onBlur={handleWeightInputBlur}
                                  onKeyDown={handleWeightInputKeyDown}
                                  autoFocus
                                  className="text-mint font-mono w-16 text-sm rounded px-1 py-0.5 text-center border-0 outline-none focus:ring-1 focus:ring-mint/30 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                />
                              ) : (
                                <span
                                  className="text-mint font-mono w-16 text-sm cursor-pointer hover:bg-black-lighter rounded px-1 py-0.5 text-center"
                                  onClick={handleWeightClick}
                                >
                                  {(formData.weight || 0).toFixed(3)}
                                </span>
                              )}
                            </div>
                            <p className="text-xs text-white-darker">
                              Higher values appear more frequently. Click the
                              value to edit directly.
                            </p>
                          </div>
                        </div>

                        <div className="rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                          <h4 className="text-white-light font-medium text-base mb-3">
                            Basic Properties
                          </h4>
                          <div className="grid grid-cols-2 gap-x-4 gap-y-2">
                            <Checkbox
                              id="unlocked_edit"
                              label="Unlocked by Default"
                              checked={formData.unlocked !== false}
                              onChange={(checked) =>
                                handleCheckboxChange("unlocked", checked)
                              }
                            />
                            <Checkbox
                              id="discovered_edit"
                              label="Already Discovered"
                              checked={formData.discovered !== false}
                              onChange={(checked) =>
                                handleCheckboxChange("discovered", checked)
                              }
                            />
                            <Checkbox
                              id="no_collection_edit"
                              label="Hidden from Collection"
                              checked={formData.no_collection === true}
                              onChange={(checked) =>
                                handleCheckboxChange("no_collection", checked)
                              }
                            />
                            <Checkbox
                              id="in_shop_edit"
                              label="Appears in Shop"
                              checked={formData.in_shop === true}
                              onChange={(checked) =>
                                handleCheckboxChange("in_shop", checked)
                              }
                            />
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "description" && (
                <InfoDescriptionBox
                  value={formData.description}
                  onChange={(value, shouldAutoFormat) =>
                    handleInputChange("description", value, shouldAutoFormat)
                  }
                  onKeyDown={handleKeyDown}
                  item={formData}
                  itemType="edition"
                  textAreaId="edition-description-edit"
                  autoFormatEnabled={autoFormatEnabled}
                  onAutoFormatToggle={() => {
                    setUserConfig((prevConfig) => ({
                      ...prevConfig,
                      defaultAutoFormat: !autoFormatEnabled,
                    }));
                    setAutoFormatEnabled(!autoFormatEnabled);
                  }}
                  validationResult={validationResults.description}
                  placeholder="Describe your edition's effects using Balatro formatting..."
                  onInsertTag={insertTagSmart}
                />
              )}

              {activeTab === "advanced" && (
                <div className="p-6 space-y-6">
                  <CogIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6 max-w-2xl mx-auto">
                    <div>
                      <h4 className="text-white-light font-medium text-lg mb-6 text-center">
                        Advanced Properties
                      </h4>

                      <div className="space-y-6">
                        <div className="rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                          <h5 className="text-white-light font-medium text-sm mb-3">
                            Shader Options
                          </h5>
                          <div className="space-y-2">
                            <Checkbox
                              id="apply_to_float_edit"
                              label="Apply to Floating Sprites"
                              checked={formData.apply_to_float === true}
                              onChange={(checked) =>
                                handleCheckboxChange("apply_to_float", checked)
                              }
                            />
                            <Checkbox
                              id="disable_shadow_edit"
                              label="Disable Shadow"
                              checked={formData.disable_shadow === true}
                              onChange={(checked) =>
                                handleCheckboxChange("disable_shadow", checked)
                              }
                            />
                            <Checkbox
                              id="disable_base_shader_edit"
                              label="Disable Base Shader"
                              checked={formData.disable_base_shader === true}
                              onChange={(checked) =>
                                handleCheckboxChange(
                                  "disable_base_shader",
                                  checked
                                )
                              }
                            />
                          </div>
                        </div>

                        <div className="rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                          <h5 className="text-white-light font-medium text-sm mb-3">
                            Badge Color
                          </h5>
                          <div className="flex items-center gap-4 mb-4">
                            <input
                              type="color"
                              value={formData.badge_colour || "#FFAA00"}
                              onChange={(e) =>
                                handleInputChange(
                                  "badge_colour",
                                  e.target.value,
                                  false
                                )
                              }
                              className="w-16 h-16 rounded-lg border-2 border-black-lighter bg-black-dark cursor-pointer"
                            />
                            <InputField
                              value={formData.badge_colour || "#FFAA00"}
                              onChange={(e) =>
                                handleInputChange(
                                  "badge_colour",
                                  e.target.value,
                                  false
                                )
                              }
                              placeholder="#FFAA00"
                              size="sm"
                              className="flex-1"
                            />
                          </div>
                          <div className="grid grid-cols-8 gap-1"></div>
                        </div>

                        <div className="rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                          <h5 className="text-white-light font-medium text-sm mb-3">
                            Sound Settings
                          </h5>
                          <div>
                            <label className="block text-xs font-medium text-white-darker mb-2">
                              Sound
                            </label>
                            <select
                              value={formData.sound || "foil1"}
                              onChange={(e) =>
                                setFormData((prev) => ({
                                  ...prev,
                                  sound: e.target.value,
                                }))
                              }
                              className="w-full bg-black-darker border border-black-lighter rounded-lg px-3 py-2 text-white-light focus:outline-none focus:border-mint transition-colors text-sm"
                            >
                              {vanillaSounds.map((sound) => (
                                <option key={sound.value} value={sound.value}>
                                  {sound.label}
                                </option>
                              ))}
                            </select>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button variant="primary" onClick={handleSave} className="flex-1">
              Save Changes
            </Button>
            <Button
              onClick={handleDelete}
              onTouchEnd={handleDelete}
              variant="danger"
              className="px-8"
            >
              Delete
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto pb-40">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="edition"
              data={{
                id: formData.id,
                name: formData.name,
                description: formData.description,
                shader: formData.shader === false ? undefined : formData.shader,
              }}
              size="lg"
              editionBadgeColor={formData.badge_colour}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditEditionInfo;

```

### src\components\pages\editions\EditionCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  PuzzlePieceIcon,
  DocumentDuplicateIcon,
  TrashIcon,
  LockOpenIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  ArrowDownTrayIcon,
  EyeSlashIcon as HiddenIcon,
  ShoppingBagIcon,
  StarIcon,
} from "@heroicons/react/24/solid";

import Tooltip from "../../generic/Tooltip";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { validateJokerName } from "../../generic/validationUtils";
import { EditionData, slugify } from "../../data/BalatroUtils";

interface EditionCardProps {
  edition: EditionData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onExport: () => void;
  onQuickUpdate: (updates: Partial<EditionData>) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const EditionCard: React.FC<EditionCardProps> = ({
  edition,
  onEditInfo,
  onEditRules,
  onDuplicate,
  onExport,
  onQuickUpdate,
  showConfirmation,
  onDelete,
}) => {
  const rulesCount = edition.rules?.length || 0;

  const [editingName, setEditingName] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(edition.name);
  const [tempDescription, setTempDescription] = useState(edition.description);

  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);

  const [nameValidationError, setNameValidationError] = useState<string>("");

  const getShaderDisplayName = (shader?: string | false) => {
    if (!shader) return "";

    const shaderNames: Record<string, string> = {
      foil: "Foil",
      holo: "Holographic",
      polychrome: "Polychrome",
      booster: "Booster",
      debuff: "Debuff",
      voucher: "Voucher",
      negative: "Negative",
      negative_shine: "Negative Shine",
    };

    return (
      shaderNames[shader] || shader.charAt(0).toUpperCase() + shader.slice(1)
    );
  };

  const handleEditRules = () => {
    onEditRules();
  };

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);

    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid name");
      return;
    }

    onQuickUpdate({ name: tempName, editionKey: slugify(tempName) });
    setEditingName(false);
    setNameValidationError("");
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const isUnlocked = edition.unlocked !== false;
  const isDiscovered = edition.discovered !== false;
  const noCollection = edition.no_collection === true;
  const inShop = edition.in_shop === true;

  const propertyIcons = [
    {
      icon: isUnlocked ? (
        <LockOpenIcon className="w-full h-full" />
      ) : (
        <LockClosedIcon className="w-full h-full" />
      ),
      tooltip: isUnlocked ? "Unlocked by Default" : "Locked by Default",
      variant: "warning" as const,
      isEnabled: isUnlocked,
      onClick: () => onQuickUpdate({ unlocked: !isUnlocked }),
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
    {
      icon: <HiddenIcon className="w-full h-full" />,
      tooltip: noCollection ? "Hidden from Collection" : "Shows in Collection",
      variant: "disabled" as const,
      isEnabled: noCollection,
      onClick: () => onQuickUpdate({ no_collection: !noCollection }),
    },
    {
      icon: <ShoppingBagIcon className="w-full h-full" />,
      tooltip: inShop ? "Appears in Shop" : "Doesn't Appear in Shop",
      variant: "success" as const,
      isEnabled: inShop,
      onClick: () => onQuickUpdate({ in_shop: !inShop }),
    },
    {
      icon: <StarIcon className="w-full h-full" />,
      tooltip: edition.shader ? "Has Shader" : "No Shader",
      variant: "special" as const,
      isEnabled: !!edition.shader,
      onClick: () => {},
    },
  ];

  const shaderName = getShaderDisplayName(edition.shader);

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="w-42 z-10 relative">
          <div className="relative">
            <img
              src="/images/acesbg/HC_A_hearts.png"
              alt="Base Edition Card"
              className="w-full h-full object-contain"
              draggable="false"
            />
            {shaderName && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="bg-black/80 text-white px-3 py-1 rounded-lg text-sm font-bold border-2 border-white/50">
                  {shaderName}
                </div>
              </div>
            )}
          </div>
        </div>

        <div className="relative z-30">
          <div className="px-6 py-1 -mt-6 rounded-md border-2 text-sm tracking-wide font-medium bg-black border-balatro-gold text-balatro-gold">
            Edition
          </div>
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Edition" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                showConfirmation({
                  type: "danger",
                  title: "Delete Edition",
                  description: `Are you sure you want to delete "${edition.name}"? This action cannot be undone.`,
                  confirmText: "Delete Forever",
                  cancelText: "Keep It",
                  confirmVariant: "danger",
                  onConfirm: () => onDelete(),
                });
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <div className="w-full">
                  <input
                    type="text"
                    value={tempName}
                    onChange={(e) => {
                      setTempName(e.target.value);
                      if (nameValidationError) {
                        const validation = validateJokerName(e.target.value);
                        if (validation.isValid) {
                          setNameValidationError("");
                        }
                      }
                    }}
                    onBlur={() => {
                      if (!nameValidationError) {
                        handleNameSave();
                      }
                    }}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleNameSave();
                      }
                      if (e.key === "Escape") {
                        setTempName(edition.name);
                        setEditingName(false);
                        setNameValidationError("");
                      }
                    }}
                    className={`text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text ${
                      nameValidationError ? "border-b-2 border-balatro-red" : ""
                    }`}
                    autoFocus
                  />
                </div>
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(edition.name);
                    setEditingName(true);
                    setNameValidationError("");
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {edition.name}
                </h3>
              )}
            </div>

            <div className=" mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(edition.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(edition.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(edition.description),
                  }}
                />
              )}
            </div>

            <div className="flex items-center justify-between mb-4 px-4 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center justify-between px-8 overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 hover:text-mint-light transition-colors cursor-pointer group"
                onClick={handleEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <PuzzlePieceIcon className="h-6 w-6 group-hover:text-mint-lighter text-white transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Export Edition" show={hoveredButton === "export"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onExport}
                onMouseEnter={() => handleButtonHover("export")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <ArrowDownTrayIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditionCard;

```

### src\components\pages\enhancements\EditEnhancementInfo.tsx

```
import React, { useState, useRef, useEffect, useCallback, useContext } from "react";
import {
  PhotoIcon,
  BoltIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
} from "@heroicons/react/24/outline";
import InputField from "../../generic/InputField";
import Checkbox from "../../generic/Checkbox";
import Button from "../../generic/Button";
import BalatroCard from "../../generic/BalatroCard";
import InfoDescriptionBox from "../../generic/InfoDescriptionBox";
import { EnhancementData, slugify } from "../../data/BalatroUtils";
import {
  validateJokerName,
  validateDescription,
  ValidationResult,
} from "../../generic/validationUtils";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import { UserConfigContext } from "../../Contexts";

interface EditEnhancementInfoProps {
  isOpen: boolean;
  enhancement: EnhancementData;
  onClose: () => void;
  onSave: (enhancement: EnhancementData) => void;
  onDelete: (enhancementId: string) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const EditEnhancementInfo: React.FC<EditEnhancementInfoProps> = ({
  isOpen,
  enhancement,
  onClose,
  onSave,
  onDelete,
  showConfirmation,
}) => {
  const {userConfig, setUserConfig} = useContext(UserConfigContext)
  const [formData, setFormData] = useState<EnhancementData>(enhancement);
  const [activeTab, setActiveTab] = useState<"visual" | "description">(
    "visual"
  );
  const [placeholderError, setPlaceholderError] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(userConfig.defaultAutoFormat ?? true);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);
  const [lastFormattedText, setLastFormattedText] = useState<string>("");

  const [placeholderCredits, setPlaceholderCredits] = useState<
    Record<number, string>
  >({});

  const [validationResults, setValidationResults] = useState<{
    name?: ValidationResult;
    description?: ValidationResult;
  }>({});

  const [isEditingWeight, setIsEditingWeight] = useState(false);
  const [weightInputValue, setWeightInputValue] = useState("");

  const handleWeightClick = () => {
    setWeightInputValue((formData.weight ?? 0).toString());
    setIsEditingWeight(true);
  };

  const handleWeightInputBlur = () => {
    const numValue = parseFloat(weightInputValue);
    if (!isNaN(numValue) && numValue >= 0 && numValue <= 25) {
      setFormData((prev) => ({
        ...prev,
        weight: numValue,
      }));
    }
    setIsEditingWeight(false);
  };

  const handleWeightInputKeyDown = (
    e: React.KeyboardEvent<HTMLInputElement>
  ) => {
    if (e.key === "Enter") {
      handleWeightInputBlur();
    } else if (e.key === "Escape") {
      setIsEditingWeight(false);
    }
  };

  const validateField = (field: string, value: string) => {
    let result: ValidationResult;
    switch (field) {
      case "name":
        result = validateJokerName(value);
        break;
      case "description":
        result = validateDescription(value);
        break;
      default:
        return;
    }

    setValidationResults((prev) => ({
      ...prev,
      [field]: result,
    }));
  };

  useEffect(() => {
    const loadCredits = async () => {
      try {
        const response = await fetch(
          "/images/placeholderenhancements/credit.txt"
        );
        const text = await response.text();
        console.log("Raw credit file content:", JSON.stringify(text));

        const credits: Record<number, string> = {};

        text.split("\n").forEach((line, lineIndex) => {
          const trimmed = line.trim();
          console.log(`Line ${lineIndex}: "${trimmed}"`);

          if (trimmed && trimmed.includes(":")) {
            const [indexStr, nameStr] = trimmed.split(":");
            const index = indexStr?.trim();
            const name = nameStr?.trim();

            if (index && name) {
              const indexNum = parseInt(index);
              if (!isNaN(indexNum)) {
                credits[indexNum] = name;
              }
            }
          }
        });

        setPlaceholderCredits(credits);
      } catch (error) {
        console.error("Failed to load placeholder credits:", error);
      }
    };

    loadCredits();
  }, []);

  const handleSave = useCallback(() => {
    const nameValidation = validateJokerName(formData.name);
    const descValidation = validateDescription(formData.description);

    if (!nameValidation.isValid || !descValidation.isValid) {
      setValidationResults({
        name: nameValidation,
        description: descValidation,
      });
      return;
    }

    onSave(formData);
    onClose();
  }, [formData, onSave, onClose]);

  useEffect(() => {
    if (isOpen) {
      setFormData({
        ...enhancement,
        unlocked: enhancement.unlocked !== false,
        discovered: enhancement.discovered !== false,
        no_collection: enhancement.no_collection === true,
        any_suit: enhancement.any_suit === true,
        replace_base_card: enhancement.replace_base_card === true,
        no_rank: enhancement.no_rank === true,
        no_suit: enhancement.no_suit === true,
        always_scores: enhancement.always_scores === true,
        enhancementKey: enhancement.enhancementKey || slugify(enhancement.name),
        hasUserUploadedImage: enhancement.hasUserUploadedImage || false,
      });
      setPlaceholderError(false);
      setLastDescription(enhancement.description || "");
      setLastFormattedText("");
      setValidationResults({});
    }
  }, [isOpen, enhancement]);

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        handleSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, handleSave]);

  if (!isOpen) return null;

  const parseTag = (tag: string): Record<string, string> => {
    const content = tag.slice(1, -1);
    if (!content) return {};

    const modifiers: Record<string, string> = {};
    const parts = content.split(",");

    for (const part of parts) {
      const [key, value] = part.split(":");
      if (key && value) {
        modifiers[key.trim()] = value.trim();
      }
    }

    return modifiers;
  };

  const buildTag = (modifiers: Record<string, string>): string => {
    if (Object.keys(modifiers).length === 0) return "{}";

    const parts = Object.entries(modifiers).map(
      ([key, value]) => `${key}:${value}`
    );
    return `{${parts.join(",")}}`;
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        false
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }

      setFormData({
        ...formData,
        [field]: finalValue,
      });
    } else if (field === "name") {
      setFormData({
        ...formData,
        [field]: value,
        enhancementKey: slugify(value),
      });
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    validateField(field, finalValue);
  };

  const handleCheckboxChange = (field: string, checked: boolean) => {
    setFormData({
      ...formData,
      [field]: checked,
    });
  };

  const upscaleImage = (img: HTMLImageElement): string => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = 142;
    canvas.height = 190;

    if (ctx) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, 142, 190);
    }

    return canvas.toDataURL("image/png");
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              imagePreview: finalImageData,
              hasUserUploadedImage: true,
            });
            setPlaceholderError(false);
          } else {
            alert(
              `Image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const getImageCredit = (enhancement: EnhancementData): string | null => {
    if (enhancement.hasUserUploadedImage) {
      return null;
    }

    if (
      enhancement.placeholderCreditIndex &&
      placeholderCredits[enhancement.placeholderCreditIndex]
    ) {
      return placeholderCredits[enhancement.placeholderCreditIndex];
    }
    return null;
  };

  const handleDelete = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Enhancement",
      description: `Are you sure you want to delete "${formData.name}"? This action cannot be undone.`,
      confirmText: "Delete Forever",
      cancelText: "Keep It",
      onConfirm: () => {
        onDelete(enhancement.id);
        onClose();
      },
    });
  };

  const insertTagSmart = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "enhancement-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    const tagMatch = selectedText.match(/^(\{[^}]*\})(.*?)(\{\})$/);

    if (tagMatch) {
      const [, openTag, content, closeTag] = tagMatch;
      const modifiers = parseTag(openTag);

      const newTagContent = tag.slice(1, -1);
      const [newKey, newValue] = newTagContent.split(":");

      if (newKey && newValue) {
        modifiers[newKey] = newValue;
      }

      const newOpenTag = buildTag(modifiers);
      const newSelectedText = `${newOpenTag}${content}${closeTag}`;

      newText =
        currentValue.substring(0, startPos) +
        newSelectedText +
        currentValue.substring(endPos);
      newCursorPos = startPos + newOpenTag.length + content.length + 2;
    } else if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const tabs = [
    { id: "visual", label: "Visual & Properties", icon: PhotoIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
  ];

  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        const currentDesc = formData.description;
        handleInputChange("description", lastDescription, false);
        setLastDescription(currentDesc);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      setLastDescription(value);
      setLastFormattedText(value);
      handleInputChange("description", newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div ref={modalRef} className="flex items-start gap-8 max-h-[90vh]">
        <div className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden">
          <div className="flex ">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(tab.id as "visual" | "description")
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "visual" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <PhotoIcon className="h-5 w-5 text-mint" />
                        Visual Assets
                      </h4>
                      <div className="flex gap-6">
                        <div className="flex-shrink-0">
                          <div className="aspect-[142/190] w-60 rounded-lg overflow-hidden relative">
                            {formData.imagePreview ? (
                              <img
                                src={formData.imagePreview}
                                alt={formData.name}
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => setPlaceholderError(true)}
                              />
                            ) : !placeholderError ? (
                              <img
                                src={
                                  !fallbackAttempted
                                    ? "/images/placeholderenhancements/placeholder-enhancement.png"
                                    : "/images/placeholder-enhancement.png"
                                }
                                alt="Placeholder Enhancement"
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => {
                                  if (!fallbackAttempted) {
                                    setFallbackAttempted(true);
                                  } else {
                                    setPlaceholderError(true);
                                  }
                                }}
                              />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center">
                                <PhotoIcon className="h-16 w-16 text-white-darker opacity-50" />
                              </div>
                            )}
                          </div>
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            ref={fileInputRef}
                          />
                          <div className="space-y-2 mt-3">
                            <Button
                              onClick={() => fileInputRef.current?.click()}
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<PhotoIcon className="h-4 w-4" />}
                            >
                              {formData.imagePreview
                                ? "Change Image"
                                : "Upload Image"}
                            </Button>
                          </div>
                          <div className="text-center mt-2">
                            <p className="text-xs text-white-darker">
                              Accepted: 7195px or 142190px
                            </p>
                            {(() => {
                              const credit = getImageCredit(formData);
                              return credit ? (
                                <p className="text-xs text-white-darker mt-1">
                                  Credit: {credit}
                                </p>
                              ) : null;
                            })()}
                          </div>
                        </div>

                        <div className="flex-1 space-y-4">
                          <div>
                            <InputField
                              value={formData.name}
                              onChange={(e) =>
                                handleInputChange("name", e.target.value, false)
                              }
                              placeholder="Enter enhancement name"
                              separator={true}
                              label="Enhancement Name"
                              size="md"
                              error={
                                validationResults.name &&
                                !validationResults.name.isValid
                                  ? validationResults.name.error
                                  : undefined
                              }
                            />
                          </div>
                          <InputField
                            value={formData.enhancementKey || ""}
                            onChange={(e) =>
                              handleInputChange(
                                "enhancementKey",
                                e.target.value,
                                false
                              )
                            }
                            placeholder="Enter enhancement key"
                            separator={true}
                            label="Enhancement Key (Code Name)"
                            size="md"
                          />
                          <p className="text-xs text-white-darker -mt-2">
                            Used in code generation. Auto-fills when you type
                            the name.
                          </p>
                          <div className=" p-4">
                            <h3 className="text-white-light font-medium mb-4">
                              Appearance Weight
                            </h3>
                            <div className="space-y-3">
                              <div className="flex items-center gap-3">
                                <input
                                  type="range"
                                  min="0"
                                  max="20"
                                  step="0.25"
                                  value={formData.weight ?? 0}
                                  onChange={(e) =>
                                    setFormData((prev) => ({
                                      ...prev,
                                      weight: parseFloat(e.target.value) ?? 0,
                                    }))
                                  }
                                  className="flex-1 h-2 bg-black-lighter rounded appearance-none cursor-pointer"
                                />
                                {isEditingWeight ? (
                                  <input
                                    type="number"
                                    min="0"
                                    max="20"
                                    step="0.25"
                                    value={weightInputValue}
                                    onChange={(e) =>
                                      setWeightInputValue(e.target.value)
                                    }
                                    onBlur={handleWeightInputBlur}
                                    onKeyDown={handleWeightInputKeyDown}
                                    autoFocus
                                    className="text-mint font-mono w-16 text-sm rounded px-1 py-0.5 text-center border-0 outline-none focus:ring-1 focus:ring-mint/30 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                  />
                                ) : (
                                  <span
                                    className="text-mint font-mono w-16 text-sm cursor-pointer hover:bg-black-lighter rounded px-1 py-0.5 text-center"
                                    onClick={handleWeightClick}
                                  >
                                    {(formData.weight || 0).toFixed(3)}
                                  </span>
                                )}
                              </div>
                              <p className="text-xs text-white-darker">
                                Higher values appear more frequently. Click the value
                                to edit directly.
                              </p>
                            </div>
                          </div>

                          <div>
                            <h4 className="text-white-light font-medium text-base mb-3 justify-center pt-2 flex tracking-wider items-center gap-2">
                              <BoltIcon className="h-5 w-5 text-mint" />
                              Enhancement Properties
                            </h4>
                            <div className="space-y-4 rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Default State
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="unlocked_edit"
                                    label="Unlocked by Default"
                                    checked={formData.unlocked !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange("unlocked", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="discovered_edit"
                                    label="Already Discovered"
                                    checked={formData.discovered !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "discovered",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="no_collection_edit"
                                    label="Hidden from Collection"
                                    checked={formData.no_collection === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "no_collection",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Card Properties
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="any_suit_edit"
                                    label="Works with Any Suit"
                                    checked={formData.any_suit === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange("any_suit", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="replace_base_card_edit"
                                    label="Replaces Base Card"
                                    checked={
                                      formData.replace_base_card === true
                                    }
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "replace_base_card",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="always_scores_edit"
                                    label="Always Scores"
                                    checked={formData.always_scores === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "always_scores",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Rank & Suit Behavior
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="no_rank_edit"
                                    label="Remove Rank"
                                    checked={formData.no_rank === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange("no_rank", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="no_suit_edit"
                                    label="Remove Suit"
                                    checked={formData.no_suit === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange("no_suit", checked)
                                    }
                                  />
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "description" && (
                <InfoDescriptionBox
                  value={formData.description}
                  onChange={(value, shouldAutoFormat) =>
                    handleInputChange("description", value, shouldAutoFormat)
                  }
                  onKeyDown={handleKeyDown}
                  item={formData}
                  itemType="enhancement"
                  textAreaId="enhancement-description-edit"
                  autoFormatEnabled={autoFormatEnabled}
                  onAutoFormatToggle={() => {
                    setUserConfig(prevConfig => ({
                      ...prevConfig,
                      defaultAutoFormat: !autoFormatEnabled
                    }))
                    setAutoFormatEnabled(!autoFormatEnabled)
                  }}
                  validationResult={validationResults.description}
                  placeholder="Describe your enhancement's effects using Balatro formatting..."
                  onInsertTag={insertTagSmart}
                />
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button variant="primary" onClick={handleSave} className="flex-1">
              Save Changes
            </Button>
            <Button
              onClick={handleDelete}
              onTouchEnd={handleDelete}
              variant="danger"
              className="px-8"
            >
              Delete
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto pb-40">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="card"
              data={{
                id: formData.id,
                name: formData.name,
                description: formData.description,
                imagePreview: formData.imagePreview,
              }}
              size="lg"
              enhancementReplaceBase={formData.replace_base_card === true}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditEnhancementInfo;

```

### src\components\pages\enhancements\EnhancementCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  PuzzlePieceIcon,
  DocumentDuplicateIcon,
  TrashIcon,
  LockOpenIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  ArrowDownTrayIcon,
  HeartIcon,
  ShieldCheckIcon,
  XMarkIcon,
  HashtagIcon,
  StarIcon,
  EyeSlashIcon as HiddenIcon,
} from "@heroicons/react/24/solid";

import Tooltip from "../../generic/Tooltip";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { validateJokerName } from "../../generic/validationUtils";
import { EnhancementData, slugify } from "../../data/BalatroUtils";

interface EnhancementCardProps {
  enhancement: EnhancementData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onExport: () => void;
  onQuickUpdate: (updates: Partial<EnhancementData>) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const EnhancementCard: React.FC<EnhancementCardProps> = ({
  enhancement,
  onEditInfo,
  onEditRules,
  onDuplicate,
  onExport,
  onQuickUpdate,
  showConfirmation,
  onDelete,
}) => {
  const rulesCount = enhancement.rules?.length || 0;

  const [editingName, setEditingName] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(enhancement.name);
  const [tempDescription, setTempDescription] = useState(
    enhancement.description
  );

  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);

  const [imageLoadError, setImageLoadError] = useState(false);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);

  const [nameValidationError, setNameValidationError] = useState<string>("");

  const handleEditRules = () => {
    onEditRules();
  };

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);

    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid name");
      return;
    }

    onQuickUpdate({ name: tempName, enhancementKey: slugify(tempName) });
    setEditingName(false);
    setNameValidationError("");
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const isUnlocked = enhancement.unlocked !== false;
  const isDiscovered = enhancement.discovered !== false;
  const noCollection = enhancement.no_collection === true;
  const anySuit = enhancement.any_suit === true;
  const replaceBaseCard = enhancement.replace_base_card === true;
  const noRank = enhancement.no_rank === true;
  const noSuit = enhancement.no_suit === true;
  const alwaysScores = enhancement.always_scores === true;

  const propertyIcons = [
    {
      icon: isUnlocked ? (
        <LockOpenIcon className="w-full h-full" />
      ) : (
        <LockClosedIcon className="w-full h-full" />
      ),
      tooltip: isUnlocked ? "Unlocked by Default" : "Locked by Default",
      variant: "warning" as const,
      isEnabled: isUnlocked,
      onClick: () => onQuickUpdate({ unlocked: !isUnlocked }),
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
    {
      icon: <HiddenIcon className="w-full h-full" />,
      tooltip: noCollection ? "Hidden from Collection" : "Shows in Collection",
      variant: "disabled" as const,
      isEnabled: noCollection,
      onClick: () => onQuickUpdate({ no_collection: !noCollection }),
    },
    {
      icon: <HeartIcon className="w-full h-full" />,
      tooltip: anySuit ? "Works with Any Suit" : "Suit-Specific",
      variant: "special" as const,
      isEnabled: anySuit,
      onClick: () => onQuickUpdate({ any_suit: !anySuit }),
    },
    {
      icon: <ShieldCheckIcon className="w-full h-full" />,
      tooltip: replaceBaseCard ? "Replaces Base Card" : "Normal Card",
      variant: "info" as const,
      isEnabled: replaceBaseCard,
      onClick: () => onQuickUpdate({ replace_base_card: !replaceBaseCard }),
    },
    {
      icon: <HashtagIcon className="w-full h-full" />,
      tooltip: noRank ? "No Rank" : "Has Rank",
      variant: "disabled" as const,
      isEnabled: noRank,
      onClick: () => onQuickUpdate({ no_rank: !noRank }),
    },
    {
      icon: <XMarkIcon className="w-full h-full" />,
      tooltip: noSuit ? "No Suit" : "Has Suit",
      variant: "disabled" as const,
      isEnabled: noSuit,
      onClick: () => onQuickUpdate({ no_suit: !noSuit }),
    },
    {
      icon: <StarIcon className="w-full h-full" />,
      tooltip: alwaysScores ? "Always Scores" : "Normal Scoring",
      variant: "success" as const,
      isEnabled: alwaysScores,
      onClick: () => onQuickUpdate({ always_scores: !alwaysScores }),
    },
  ];

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="w-42 z-10 relative">
          <div className="relative">
            {enhancement.imagePreview && !imageLoadError ? (
              <div className="relative w-full h-full">
                <img
                  src={enhancement.imagePreview}
                  alt={enhancement.name}
                  className="w-full h-full object-contain"
                  draggable="false"
                  onError={() => setImageLoadError(true)}
                />
                { !enhancement.replace_base_card &&
                <img
                  src="/images/aces/HC_A_hearts.png"
                  alt=""
                  className="absolute inset-0 w-full h-full object-contain pointer-events-none"
                  draggable="false"
                />
                }
              </div>
            ) : (
              <div className="relative w-full h-full">
                <img
                  src={
                    !fallbackAttempted
                      ? "/images/placeholderenhancements/placeholder-enhancement.png"
                      : "/images/placeholder-enhancement.png"
                  }
                  alt="Default Enhancement"
                  className="w-full h-full object-contain"
                  draggable="false"
                  onError={() => {
                    if (!fallbackAttempted) {
                      setFallbackAttempted(true);
                    }
                  }}
                />
                <img
                  src="/images/aces/HC_A_clubs.png"
                  alt=""
                  className="absolute inset-0 w-full h-full object-contain pointer-events-none"
                  draggable="false"
                />
              </div>
            )}
          </div>
        </div>

        <div className="relative z-30">
          <div className="px-6 py-1 -mt-6 rounded-md border-2 text-sm tracking-wide font-medium bg-black border-balatro-enhanced text-balatro-enhanced">
            Enhancement
          </div>
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Enhancement" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                showConfirmation({
                  type: "danger",
                  title: "Delete Enhancement",
                  description: `Are you sure you want to delete "${enhancement.name}"? This action cannot be undone.`,
                  confirmText: "Delete Forever",
                  cancelText: "Keep It",
                  confirmVariant: "danger",
                  onConfirm: () => onDelete(),
                });
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <div className="w-full">
                  <input
                    type="text"
                    value={tempName}
                    onChange={(e) => {
                      setTempName(e.target.value);
                      if (nameValidationError) {
                        const validation = validateJokerName(e.target.value);
                        if (validation.isValid) {
                          setNameValidationError("");
                        }
                      }
                    }}
                    onBlur={() => {
                      if (!nameValidationError) {
                        handleNameSave();
                      }
                    }}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleNameSave();
                      }
                      if (e.key === "Escape") {
                        setTempName(enhancement.name);
                        setEditingName(false);
                        setNameValidationError("");
                      }
                    }}
                    className={`text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text ${
                      nameValidationError ? "border-b-2 border-balatro-red" : ""
                    }`}
                    autoFocus
                  />
                </div>
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(enhancement.name);
                    setEditingName(true);
                    setNameValidationError("");
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {enhancement.name}
                </h3>
              )}
            </div>

            <div className=" mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(enhancement.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(enhancement.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(enhancement.description),
                  }}
                />
              )}
            </div>

            <div className="flex items-center justify-between mb-4 px-4 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center justify-between px-8 overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 hover:text-mint-light transition-colors cursor-pointer group"
                onClick={handleEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <PuzzlePieceIcon className="h-6 w-6 group-hover:text-mint-lighter text-white transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip
              content="Export Enhancement"
              show={hoveredButton === "export"}
            >
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onExport}
                onMouseEnter={() => handleButtonHover("export")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <ArrowDownTrayIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EnhancementCard;

```

### src\components\pages\jokers\EditJokerInfo.tsx

```
import React, {
  useState,
  useRef,
  useEffect,
  useCallback,
  useMemo,
  useContext,
} from "react";
import {
  PhotoIcon,
  SparklesIcon,
  BoltIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
  PlusIcon,
  Cog6ToothIcon,
} from "@heroicons/react/24/outline";
import InputField from "../../generic/InputField";
import InputDropdown from "../../generic/InputDropdown";
import Checkbox from "../../generic/Checkbox";
import Button from "../../generic/Button";
import BalatroCard from "../../generic/BalatroCard";
import InfoDescriptionBox from "../../generic/InfoDescriptionBox";
import { getAllVariables } from "../../codeGeneration/Jokers/variableUtils";
import { JokerData, UserVariable } from "../../data/BalatroUtils";
import {
  validateJokerName,
  validateDescription,
  ValidationResult,
} from "../../generic/validationUtils";
import {
  getRarityDropdownOptions,
  getRarityByValue,
  getRarityDisplayName,
  getRarityBadgeColor,
  RarityData,
  slugify,
} from "../../data/BalatroUtils";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import {
  BuildingStorefrontIcon,
  LockOpenIcon,
  TrashIcon,
} from "@heroicons/react/24/solid";
import {
  unlockOptions,
  unlockTriggerOptions,
} from "../../codeGeneration/Jokers/unlockUtils";
import { UserConfigContext } from "../../Contexts";

interface EditJokerInfoProps {
  isOpen: boolean;
  joker: JokerData;
  onClose: () => void;
  onSave: (joker: JokerData) => void;
  onDelete: (jokerId: string) => void;
  customRarities?: RarityData[];
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

interface PropertyRuleProps {
  formData: JokerData;
  index: number;
}

type UnlockTrigger = keyof typeof unlockOptions;

const EditJokerInfo: React.FC<EditJokerInfoProps> = ({
  isOpen,
  joker,
  onClose,
  onSave,
  onDelete,
  customRarities = [],
  showConfirmation,
}) => {
  const { userConfig, setUserConfig } = useContext(UserConfigContext);
  const [formData, setFormData] = useState<JokerData>(joker);
  const [activeTab, setActiveTab] = useState<
    "visual" | "description" | "settings"
  >("visual");
  const [placeholderError, setPlaceholderError] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const overlayFileInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(
    userConfig.defaultAutoFormat ?? true
  );
  const [fallbackAttempted, setFallbackAttempted] = useState(false);
  const [lastFormattedText, setLastFormattedText] = useState<string>("");

  const [placeholderCredits, setPlaceholderCredits] = useState<
    Record<number, string>
  >({});

  const [validationResults, setValidationResults] = useState<{
    name?: ValidationResult;
    description?: ValidationResult;
  }>({});

  const [poolsInput, setPoolsInput] = useState("");

  const rarityOptions = getRarityDropdownOptions(customRarities);

  const unlockOperatorOptions = [
    { value: "equals", label: "equals" },
    { value: "greater_than", label: "greater than" },
    { value: "less_than", label: "less than" },
    { value: "greater_equals", label: "greater than or equal" },
    { value: "less_equals", label: "less than or equal" },
  ];

  const forcedEditionOptions = [
    { value: "", label: "None" },
    { value: "foil", label: "Always Spawn Foil" },
    { value: "holographic", label: "Always Spawn Holographic" },
    { value: "polychrome", label: "Always Spawn Polychrome" },
    { value: "negative", label: "Always Spawn Negative" },
  ];

  const handleForcedEditionChange = (value: string) => {
    setFormData({
      ...formData,
      force_foil: value === "foil",
      force_holographic: value === "holographic",
      force_polychrome: value === "polychrome",
      force_negative: value === "negative",
    });
  };

  const getForcedEditionValue = (): string => {
    if (formData.force_foil) return "foil";
    if (formData.force_holographic) return "holographic";
    if (formData.force_polychrome) return "polychrome";
    if (formData.force_negative) return "negative";
    return "";
  };

  const PropertyRule: React.FC<PropertyRuleProps> = ({ formData, index }) => {
    const propertyCategoryOptions = useMemo(() => {
      if (!formData.unlockTrigger) return [];
      return unlockOptions[formData.unlockTrigger]?.categories ?? [];
    }, [formData.unlockTrigger]);

    const selectedPropertyCategory =
      formData.unlockProperties?.[index]?.category;
    const propertyOptions = useMemo(() => {
      if (!formData.unlockTrigger) return [];
      const category = unlockOptions[formData.unlockTrigger]?.categories?.find(
        (c) => c.value === selectedPropertyCategory
      );

      return category?.options ?? [];
    }, [formData.unlockTrigger, selectedPropertyCategory]);

    return (
      <div key={index} className="grid grid-cols-19 gap-4">
        <div className="col-span-9">
          <InputDropdown
            value={formData.unlockProperties?.[index].category || ""}
            onChange={(value) => handleUnlockPropertyCategory(value, index)}
            options={propertyCategoryOptions || []}
            separator={true}
            label="Category"
          />
        </div>
        <div className="col-span-9">
          <InputDropdown
            value={formData.unlockProperties?.[index].property || ""}
            onChange={(value) => handleUnlockProperty(value, index)}
            options={propertyOptions || []}
            separator={true}
            label="Property"
            className="col-span-5"
          />
        </div>
        <div className="w-11 h-11 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10 self-end place-self-center">
          <button
            onClick={() => handleDeleteProperty(index)}
            className="w-full h-full flex items-center cursor-pointer justify-center"
          >
            <TrashIcon className="h-5 w-5 text-balatro-red" />
          </button>
        </div>
      </div>
    );
  };

  const validateField = (field: string, value: string) => {
    let result: ValidationResult;
    switch (field) {
      case "name":
        result = validateJokerName(value);
        break;
      case "description":
        result = validateDescription(value);
        break;
      default:
        return;
    }

    setValidationResults((prev) => ({
      ...prev,
      [field]: result,
    }));
  };

  useEffect(() => {
    const loadCredits = async () => {
      try {
        const response = await fetch("/images/placeholderjokers/credit.txt");
        const text = await response.text();
        console.log("Raw credit file content:", JSON.stringify(text));

        const credits: Record<number, string> = {};

        text.split("\n").forEach((line, lineIndex) => {
          const trimmed = line.trim();
          console.log(`Line ${lineIndex}: "${trimmed}"`);

          if (trimmed && trimmed.includes(":")) {
            const [indexStr, nameStr] = trimmed.split(":");
            const index = indexStr?.trim();
            const name = nameStr?.trim();

            if (index && name) {
              const indexNum = parseInt(index);
              if (!isNaN(indexNum)) {
                credits[indexNum] = name;
              }
            }
          }
        });

        setPlaceholderCredits(credits);
      } catch (error) {
        console.error("Failed to load placeholder credits:", error);
      }
    };

    loadCredits();
  }, []);

  const handleSave = useCallback(() => {
    const nameValidation = validateJokerName(formData.name);
    const descValidation = validateDescription(formData.description);

    if (!nameValidation.isValid || !descValidation.isValid) {
      setValidationResults({
        name: nameValidation,
        description: descValidation,
      });
      return;
    }

    onSave(formData);
    onClose();
  }, [formData, onSave, onClose]);

  useEffect(() => {
    if (isOpen) {
      setFormData({
        ...joker,
        blueprint_compat: joker.blueprint_compat !== false,
        eternal_compat: joker.eternal_compat !== false,
        unlocked: joker.unlocked !== false,
        discovered: joker.discovered !== false,
        jokerKey: joker.jokerKey || slugify(joker.name),
        hasUserUploadedImage: joker.hasUserUploadedImage || false,
      });
      setPlaceholderError(false);
      setLastDescription(joker.description || "");
      setLastFormattedText("");
      setValidationResults({});
      setPoolsInput((joker.pools || []).join(", "));
    }
  }, [isOpen, joker]);

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        handleSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, handleSave]);

  if (!isOpen) return null;

  const parseTag = (tag: string): Record<string, string> => {
    const content = tag.slice(1, -1);
    if (!content) return {};

    const modifiers: Record<string, string> = {};
    const parts = content.split(",");

    for (const part of parts) {
      const [key, value] = part.split(":");
      if (key && value) {
        modifiers[key.trim()] = value.trim();
      }
    }

    return modifiers;
  };

  const buildTag = (modifiers: Record<string, string>): string => {
    if (Object.keys(modifiers).length === 0) return "{}";

    const parts = Object.entries(modifiers).map(
      ([key, value]) => `${key}:${value}`
    );
    return `{${parts.join(",")}}`;
  };

  const handleOverlayImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              overlayImagePreview: finalImageData,
            });
          } else {
            alert(
              `Overlay image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        true
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }

      setFormData({
        ...formData,
        [field]: finalValue,
      });
    } else if (field === "name") {
      setFormData({
        ...formData,
        [field]: value,
        jokerKey: slugify(value),
      });
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    validateField(field, finalValue);
  };

  const handleNumberChange = (field: string, value: number) => {
    setFormData({
      ...formData,
      [field]: isNaN(value) ? 0 : value,
    });
  };

  const handleCheckboxChange = (field: string, checked: boolean) => {
    if (field === "unlocked") {
      setFormData({
        ...formData,
        unlockTrigger: undefined,
        unlockOperator: "",
        unlockCount: 1,
        unlockDescription: "",
        unlockProperties: [],
        [field]: checked,
      });
    } else {
      setFormData({
        ...formData,
        [field]: checked,
      });
    }
  };

  const handleCardAppearanceCheckboxChange = (
    field: string,
    checked: boolean
  ) => {
    if (field === "shop") {
      setFormData({
        ...formData,
        appears_in_shop: checked,
      });
    } else {
      setFormData({
        ...formData,
        cardAppearance: {
          ...formData.cardAppearance,
          [field]: checked,
        },
      });
    }
  };

  const handleRarityChange = (value: string) => {
    const parsedValue = parseInt(value, 10);
    let newRarity: number | string;

    if (!isNaN(parsedValue) && parsedValue >= 1 && parsedValue <= 4) {
      newRarity = parsedValue;
    } else {
      newRarity = value;
    }

    const previousRarity = formData.rarity;
    const newFormData = {
      ...formData,
      rarity: newRarity,
      cost:
        formData.cost === getCostFromRarity(formData.rarity)
          ? getCostFromRarity(newRarity)
          : formData.cost,
    };

    const isVanillaLegendary = typeof newRarity === "number" && newRarity === 4;
    const wasVanillaLegendary =
      typeof previousRarity === "number" && previousRarity === 4;

    if (previousRarity !== newRarity) {
      if (isVanillaLegendary && !wasVanillaLegendary) {
        newFormData.appears_in_shop = false;
      } else if (wasVanillaLegendary && !isVanillaLegendary) {
        newFormData.appears_in_shop = true;
      }
    }

    setFormData(newFormData);
  };

  const getCostFromRarity = (rarity: number | string): number => {
    if (typeof rarity === "string") {
      return 5;
    }

    const rarityData = getRarityByValue(rarity, customRarities);
    if (rarityData?.isCustom) {
      return 5;
    }

    switch (rarity) {
      case 1:
        return 4;
      case 2:
        return 5;
      case 3:
        return 6;
      case 4:
        return 20;
      default:
        return 5;
    }
  };

  const addPropertyHidden =
    (formData.unlockTrigger === "career_stat" &&
      formData.unlockProperties?.length) ||
    !formData.unlockTrigger ||
    formData.unlockTrigger === "chip_score";

  const handleAddProperty = () => {
    const newProperty: { category: string; property: string } = {
      category: "",
      property: "",
    };
    setFormData((prevFormData) => ({
      ...prevFormData,
      unlockProperties: [...(prevFormData.unlockProperties ?? []), newProperty],
    }));
  };

  const handleDeleteProperty = (index: number) => {
    const updatedProperties = formData.unlockProperties?.filter(
      (_, i) => i !== index
    );
    setFormData((prevFormData) => ({
      ...prevFormData,
      unlockProperties: updatedProperties,
    }));
  };

  const handleUnlockTrigger = (value: string) => {
    setFormData({
      ...formData,
      unlockTrigger: value as UnlockTrigger,
      unlockProperties: [],
    });
  };

  const handleUnlockPropertyCategory = (value: string, index: number) => {
    setFormData({
      ...formData,
      unlockProperties: formData.unlockProperties?.map((propertyRule, i) =>
        i === index ? { ...propertyRule, category: value } : propertyRule
      ),
    });
  };
  const handleUnlockProperty = (value: string, index: number) => {
    setFormData({
      ...formData,
      unlockProperties: formData.unlockProperties?.map((propertyRule, i) =>
        i === index ? { ...propertyRule, property: value } : propertyRule
      ),
    });
  };

  const handleUnlockOperator = (value: string) => {
    setFormData({
      ...formData,
      unlockOperator: value,
    });
  };

  const upscaleImage = (img: HTMLImageElement): string => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = 142;
    canvas.height = 190;

    if (ctx) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, 142, 190);
    }

    return canvas.toDataURL("image/png");
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              imagePreview: finalImageData,
              hasUserUploadedImage: true,
            });
            setPlaceholderError(false);
          } else {
            alert(
              `Image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const getImageCredit = (joker: JokerData): string | null => {
    if (joker.hasUserUploadedImage) {
      return null;
    }

    if (
      joker.placeholderCreditIndex &&
      placeholderCredits[joker.placeholderCreditIndex]
    ) {
      return placeholderCredits[joker.placeholderCreditIndex];
    }
    return null;
  };

  const handleDelete = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Joker",
      description: `Are you sure you want to delete "${formData.name}"? This action cannot be undone.`,
      confirmText: "Delete Forever",
      cancelText: "Keep It",
      onConfirm: () => {
        onDelete(joker.id);
        onClose();
      },
    });
  };

  const allVariables = getAllVariables(formData);

  const VariableDisplay = (variable: UserVariable) => {
    if (variable.type === "suit") return variable.initialSuit || "Spades";
    if (variable.type === "rank") return variable.initialRank || "Ace";
    if (variable.type === "pokerhand")
      return variable.initialPokerHand || "High Card";
    return variable.initialValue?.toString() || "0";
  };

  const VariableValues = allVariables.map(VariableDisplay);

  const insertTagSmart = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "joker-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    const tagMatch = selectedText.match(/^(\{[^}]*\})(.*?)(\{\})$/);

    if (tagMatch) {
      const [, openTag, content, closeTag] = tagMatch;
      const modifiers = parseTag(openTag);

      const newTagContent = tag.slice(1, -1);
      const [newKey, newValue] = newTagContent.split(":");

      if (newKey && newValue) {
        modifiers[newKey] = newValue;
      }

      const newOpenTag = buildTag(modifiers);
      const newSelectedText = `${newOpenTag}${content}${closeTag}`;

      newText =
        currentValue.substring(0, startPos) +
        newSelectedText +
        currentValue.substring(endPos);
      newCursorPos = startPos + newOpenTag.length + content.length + 2;
    } else if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const tabs = [
    { id: "visual", label: "Visual & Properties", icon: PhotoIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
    { id: "settings", label: "Advanced Settings", icon: Cog6ToothIcon },
  ];

  const handleKeyDown = (
    field: string,
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        const currentDesc = formData.description;
        handleInputChange("description", lastDescription, false);
        setLastDescription(currentDesc);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      if (field === "description") {
        setLastDescription(value);
        setLastFormattedText(value);
      }

      handleInputChange(field, newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div className="flex items-start gap-8 max-h-[90vh]">
        <div
          ref={modalRef}
          className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden"
        >
          <div className="flex ">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(tab.id as "visual" | "description")
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "visual" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <PhotoIcon className="h-5 w-5 text-mint" />
                        Visual Assets
                      </h4>
                      <div className="flex gap-6">
                        <div className="flex-shrink-0">
                          <div className="aspect-[142/190] w-60 rounded-lg overflow-hidden relative">
                            {formData.imagePreview ? (
                              <>
                                <img
                                  src={formData.imagePreview}
                                  alt={formData.name}
                                  className="w-full h-full object-cover"
                                  draggable="false"
                                  onError={() => setPlaceholderError(true)}
                                />
                                {formData.overlayImagePreview && (
                                  <img
                                    src={formData.overlayImagePreview}
                                    alt={`${formData.name} overlay`}
                                    className="absolute inset-0 w-full h-full object-cover"
                                    draggable="false"
                                  />
                                )}
                              </>
                            ) : !placeholderError ? (
                              <img
                                src={
                                  !fallbackAttempted
                                    ? "/images/placeholderjokers/placeholder-joker.png"
                                    : "/images/placeholder-joker.png"
                                }
                                alt="Placeholder Joker"
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => {
                                  if (!fallbackAttempted) {
                                    setFallbackAttempted(true);
                                  } else {
                                    setPlaceholderError(true);
                                  }
                                }}
                              />
                            ) : (
                              <PhotoIcon className="h-16 w-16 text-white-darker opacity-50 mx-auto my-auto" />
                            )}
                          </div>
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            ref={fileInputRef}
                          />
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleOverlayImageUpload}
                            className="hidden"
                            ref={overlayFileInputRef}
                          />
                          <div className="space-y-2 mt-3">
                            <Button
                              onClick={() => fileInputRef.current?.click()}
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<PhotoIcon className="h-4 w-4" />}
                            >
                              {formData.imagePreview
                                ? "Change Main Image"
                                : "Upload Main Image"}
                            </Button>
                            <Button
                              onClick={() =>
                                overlayFileInputRef.current?.click()
                              }
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<SparklesIcon className="h-4 w-4" />}
                            >
                              {formData.overlayImagePreview
                                ? "Change Overlay"
                                : "Add Overlay"}
                            </Button>
                            {formData.overlayImagePreview && (
                              <Button
                                onClick={() =>
                                  handleInputChange(
                                    "overlayImagePreview",
                                    "",
                                    false
                                  )
                                }
                                variant="danger"
                                className="w-full"
                                size="sm"
                              >
                                Remove Overlay
                              </Button>
                            )}
                          </div>
                          <div className="text-center mt-2">
                            <p className="text-xs text-white-darker">
                              Accepted: 7195px or 142190px each
                            </p>
                            {(() => {
                              const credit = getImageCredit(formData);
                              return credit ? (
                                <p className="text-xs text-white-darker mt-1">
                                  Credit: {credit}
                                </p>
                              ) : null;
                            })()}
                          </div>
                          <div className="space-y-2 mt-3">
                            <InputField
                              value={formData.scale_w?.toString() || "100"}
                              onChange={(e) =>
                                handleNumberChange(
                                  "scale_w",
                                  parseInt(e.target.value)
                                )
                              }
                              placeholder="100"
                              label="Scale Width (%)"
                              type="number"
                              size="sm"
                            />
                            <InputField
                              value={formData.scale_h?.toString() || "100"}
                              onChange={(e) =>
                                handleNumberChange(
                                  "scale_h",
                                  parseInt(e.target.value)
                                )
                              }
                              placeholder="100"
                              label="Scale Height (%)"
                              type="number"
                              size="sm"
                            />
                          </div>
                        </div>

                        <div className="flex-1 space-y-4">
                          <div>
                            <InputField
                              value={formData.name}
                              onChange={(e) =>
                                handleInputChange("name", e.target.value, false)
                              }
                              placeholder="Enter joker name"
                              separator={true}
                              label="Joker Name"
                              size="md"
                              error={
                                validationResults.name &&
                                !validationResults.name.isValid
                                  ? validationResults.name.error
                                  : undefined
                              }
                            />
                          </div>
                          <InputField
                            value={formData.jokerKey || ""}
                            onChange={(e) =>
                              handleInputChange(
                                "jokerKey",
                                e.target.value,
                                false
                              )
                            }
                            placeholder="Enter joker key"
                            separator={true}
                            label="Joker Key (Code Name)"
                            size="md"
                          />
                          <p className="text-xs text-white-darker -mt-2">
                            Used in code generation. Auto-fills when you type
                            the name.
                          </p>

                          <div className="grid grid-cols-2 gap-4">
                            <InputDropdown
                              value={formData.rarity.toString()}
                              onChange={handleRarityChange}
                              options={rarityOptions}
                              separator={true}
                              label="Rarity"
                            />
                            <InputField
                              value={formData.cost?.toString() || "4"}
                              onChange={(e) =>
                                handleNumberChange(
                                  "cost",
                                  parseInt(e.target.value)
                                )
                              }
                              placeholder="Cost"
                              separator={true}
                              type="number"
                              min={1}
                              label="Cost ($)"
                            />
                          </div>

                          <div>
                            <h4 className="text-white-light font-medium text-base mb-3 justify-center pt-2 flex tracking-wider items-center gap-2">
                              <BoltIcon className="h-5 w-5 text-mint" />
                              Joker Properties
                            </h4>
                            <div className="space-y-4 rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Compatibility
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="eternal_compat_edit"
                                    label="Eternal Compatible"
                                    checked={formData.eternal_compat !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "eternal_compat",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="perishable_compat_edit"
                                    label="Perishable Compatible"
                                    checked={
                                      formData.perishable_compat !== false
                                    }
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "perishable_compat",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="blueprint_compat_edit"
                                    label="Visually Blueprint Compatible"
                                    checked={
                                      formData.blueprint_compat !== false
                                    }
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "blueprint_compat",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Default State
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="unlocked_edit"
                                    label="Unlocked by Default"
                                    checked={formData.unlocked !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange("unlocked", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="discovered_edit"
                                    label="Already Discovered"
                                    checked={formData.discovered !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "discovered",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Forced Spawning
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="force_eternal_edit"
                                    label="Always Spawn Eternal"
                                    checked={formData.force_eternal === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "force_eternal",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="force_perishable_edit"
                                    label="Always Spawn Perishable"
                                    checked={formData.force_perishable === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "force_perishable",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="force_rental_edit"
                                    label="Always Spawn Rental"
                                    checked={formData.force_rental === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "force_rental",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                              <div>
                                <InputDropdown
                                  value={getForcedEditionValue()}
                                  onChange={handleForcedEditionChange}
                                  options={forcedEditionOptions}
                                  separator={true}
                                  label="Force Edition"
                                  placeholder="Select forced edition"
                                />
                              </div>
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Other
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="ignoreSlotLimit"
                                    label="Ignore Slot Limit When Obtained"
                                    checked={formData.ignoreSlotLimit === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "ignoreSlotLimit",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "description" && (
                <InfoDescriptionBox
                  value={formData.description}
                  onChange={(value, shouldAutoFormat) =>
                    handleInputChange("description", value, shouldAutoFormat)
                  }
                  onKeyDown={(e) => handleKeyDown("description", e)}
                  item={formData}
                  itemType="joker"
                  textAreaId="joker-description-edit"
                  autoFormatEnabled={autoFormatEnabled}
                  onAutoFormatToggle={() => {
                    setUserConfig((prevConfig) => ({
                      ...prevConfig,
                      defaultAutoFormat: !autoFormatEnabled,
                    }));
                    setAutoFormatEnabled(!autoFormatEnabled);
                  }}
                  validationResult={validationResults.description}
                  placeholder="Describe your joker's effects using Balatro formatting..."
                  onInsertTag={insertTagSmart}
                />
              )}

              {/* in the future we can add shop appearence (in_pool) rules to this tab */}
              {activeTab === "settings" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />
                  <div className="space-y-6">
                    <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                      <LockOpenIcon className="h-5 w-5 text-mint" />
                      Unlock Requirements
                    </h4>
                    {!formData.unlocked && (
                      <>
                        <div className="flex gap-6">
                          <div className="flex-1 space-y-4">
                            <div className="grid grid-cols-4 gap-4">
                              <div className="col-span-2">
                                <InputDropdown
                                  value={formData.unlockTrigger || ""}
                                  onChange={handleUnlockTrigger}
                                  options={unlockTriggerOptions}
                                  separator={true}
                                  label="Trigger"
                                />
                              </div>
                              <InputDropdown
                                value={formData.unlockOperator || ""}
                                onChange={handleUnlockOperator}
                                options={unlockOperatorOptions}
                                separator={true}
                                label="Operator"
                              />
                              <InputField
                                value={formData.unlockCount?.toString() || "1"}
                                onChange={(e) =>
                                  handleNumberChange(
                                    "unlockCount",
                                    parseInt(e.target.value)
                                  )
                                }
                                placeholder="Amount"
                                separator={true}
                                min={0}
                                type="number"
                                label="Amount"
                              />
                              <div
                                className={
                                  addPropertyHidden ? "hidden" : "col-span-full"
                                }
                              >
                                <Button
                                  variant="secondary"
                                  size="sm"
                                  onClick={handleAddProperty}
                                  icon={<PlusIcon className="h-4 w-4" />}
                                  className="w-full"
                                >
                                  Add Property
                                </Button>
                              </div>
                            </div>

                            <div className="grid grid-cols-1 gap-y-8">
                              {formData.unlockProperties?.map(
                                (_property, index) =>
                                  formData.unlockTrigger !== "chip_score" && (
                                    <PropertyRule
                                      formData={formData}
                                      index={index}
                                    />
                                  )
                              )}
                            </div>
                            {/* not sure if adding formatting tools is needed, makes it really bloated */}
                            <InputField
                              id={"joker-unlock-edit"}
                              value={formData.unlockDescription || ""}
                              onChange={(e) =>
                                handleInputChange(
                                  "unlockDescription",
                                  e.target.value
                                )
                              }
                              onKeyDown={(e) =>
                                handleKeyDown("unlockDescription", e)
                              }
                              multiline={true}
                              height="140px"
                              separator={true}
                              label="Unlock Text"
                              placeholder={
                                "Play a 5 hand card that contains only Gold Cards"
                              }
                            />
                          </div>
                        </div>
                      </>
                    )}
                    {formData.unlocked && (
                      <p className="text-xs text-white-darker -mt-2">
                        Joker is Unlocked by Default
                      </p>
                    )}
                    <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                      <BuildingStorefrontIcon className="h-5 w-5 text-mint" />
                      Card Appearance
                    </h4>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                      <Checkbox
                        id="shop"
                        label="Can appear in Shop"
                        checked={formData.appears_in_shop !== false}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("shop", checked)
                        }
                      />
                      <Checkbox
                        id="judgement"
                        label="Can appear from Judgement"
                        checked={formData.cardAppearance.jud === true}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("jud", checked)
                        }
                      />
                      <Checkbox
                        id="buffoon_pack"
                        label="Can appear in a Buffoon Pack"
                        checked={formData.cardAppearance.buf === true}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("buf", checked)
                        }
                      />
                      <Checkbox
                        id="soul"
                        label="Can appear from The Soul"
                        checked={formData.cardAppearance.sou === true}
                        className={formData.rarity !== 4 ? "hidden" : ""}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("sou", checked)
                        }
                      />
                      <Checkbox
                        id="wraith"
                        label="Can appear from The Wraith"
                        checked={formData.cardAppearance.wra === true}
                        className={formData.rarity !== 3 ? "hidden" : ""}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("wra", checked)
                        }
                      />
                      <Checkbox
                        id="riff_raff"
                        label="Can appear from Riff Raff"
                        checked={formData.cardAppearance.rif === true}
                        className={formData.rarity !== 1 ? "hidden" : ""}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("rif", checked)
                        }
                      />
                      <Checkbox
                        id="rare_tag"
                        label="Can appear from a Rare Tag"
                        checked={formData.cardAppearance.rta === true}
                        className={formData.rarity !== 3 ? "hidden" : ""}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("rta", checked)
                        }
                      />
                      <Checkbox
                        id="uncommon_tag"
                        label="Can appear from an Uncommon Tag"
                        checked={formData.cardAppearance.uta === true}
                        className={formData.rarity !== 2 ? "hidden" : ""}
                        onChange={(checked) =>
                          handleCardAppearanceCheckboxChange("uta", checked)
                        }
                      />
                    </div>
                    <InputField
                      id={"joker-pool-flags"}
                      value={formData.appearFlags || ""}
                      onChange={(e) =>
                        handleInputChange("appearFlags", e.target.value)
                      }
                      className="col-span-full"
                      height="44px"
                      separator={true}
                      label="Flags Required"
                      placeholder={"custom_flag1, not custom_flag2, ..."}
                    />
                    <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                      <PuzzlePieceIcon className="h-5 w-5 text-mint" />
                      Custom Pools
                    </h4>
                    <div className="space-y-4">
                      <InputField
                        value={poolsInput}
                        onChange={(e) => setPoolsInput(e.target.value)}
                        onBlur={() => {
                          // Parse the pools when user finishes editing
                          const pools = poolsInput
                            .split(",")
                            .map((pool) => pool.trim())
                            .filter((pool) => pool.length > 0);

                          setFormData({
                            ...formData,
                            pools: pools.length > 0 ? pools : undefined,
                          });
                        }}
                        onKeyDown={(e) => {
                          if (e.key === "Enter") {
                            // Parse pools on Enter key
                            const pools = poolsInput
                              .split(",")
                              .map((pool) => pool.trim())
                              .filter((pool) => pool.length > 0);

                            setFormData({
                              ...formData,
                              pools: pools.length > 0 ? pools : undefined,
                            });
                            e.currentTarget.blur();
                          }
                        }}
                        placeholder="pool1, pool2, special_jokers"
                        separator={true}
                        label="Pool Names"
                        size="md"
                      />
                      <p className="text-xs text-white-darker -mt-2">
                        Enter pool names separated by commas. This joker will be
                        available for selection in effects that target these
                        pools.
                      </p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button
              variant="primary"
              onClick={handleSave}
              onTouchEnd={handleSave}
              className="flex-1"
            >
              Save Changes
            </Button>
            <Button onClick={handleDelete} variant="danger" className="px-8">
              Delete
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto pb-40">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="joker"
              data={{
                id: formData.id,
                name: formData.name,
                description:
                  activeTab === "settings"
                    ? formData.unlockDescription
                    : formData.description,
                imagePreview: formData.imagePreview,
                overlayImagePreview: formData.overlayImagePreview,
                cost: formData.cost,
                rarity: formData.rarity,
                locVars: {
                  vars: VariableValues,
                },
              }}
              size="lg"
              rarityName={getRarityDisplayName(formData.rarity, customRarities)}
              rarityColor={getRarityBadgeColor(formData.rarity, customRarities)}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditJokerInfo;

```

### src\components\pages\jokers\JokerCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  PuzzlePieceIcon,
  DocumentDuplicateIcon,
  StarIcon,
  TrashIcon,
  ArrowDownTrayIcon,
  LockOpenIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  ExclamationCircleIcon,
  BuildingStorefrontIcon,
  NoSymbolIcon,
  ClockIcon,
  CurrencyDollarIcon,
  WrenchIcon,
  SparklesIcon,
  CameraIcon,
} from "@heroicons/react/24/solid";

import Tooltip from "../../generic/Tooltip";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { validateJokerName } from "../../generic/validationUtils";

import {
  getRarityDisplayName,
  getRarityBadgeColor,
  getAllRarities,
  RarityData,
  type JokerData,
  slugify,
} from "../../data/BalatroUtils";

interface JokerCardProps {
  joker: JokerData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onExport: () => void;
  onShowcase: () => void;
  onQuickUpdate: (updates: Partial<JokerData>) => void;
  customRarities?: RarityData[];
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const JokerCard: React.FC<JokerCardProps> = ({
  joker,
  onEditInfo,
  onEditRules,
  onDelete,
  onDuplicate,
  onExport,
  onQuickUpdate,
  customRarities = [],
  showConfirmation,
  onShowcase,
}) => {
  const [showRarityMenu, setShowRarityMenu] = useState(false);
  const [editingName, setEditingName] = useState(false);
  const [editingCost, setEditingCost] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(joker.name);
  const [tempCost, setTempCost] = useState(joker.cost || 4);
  const [tempDescription, setTempDescription] = useState(joker.description);
  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);

  const [imageLoadError, setImageLoadError] = useState(false);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);

  const safeRarity =
    typeof joker.rarity === "number" && joker.rarity >= 1
      ? joker.rarity
      : typeof joker.rarity === "string"
      ? joker.rarity
      : 1;

  const rarityText = getRarityDisplayName(safeRarity, customRarities);
  const rarityColor = getRarityBadgeColor(safeRarity, customRarities);

  const allRarities = getAllRarities(customRarities);

  const rulesCount = joker.rules?.length || 0;

  const [nameValidationError, setNameValidationError] = useState<string>("");

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);

    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid name");
      return;
    }

    onQuickUpdate({ name: tempName, jokerKey: slugify(tempName) });
    setEditingName(false);
    setNameValidationError("");
  };

  const handleCostSave = () => {
    onQuickUpdate({ cost: tempCost });
    setEditingCost(false);
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleRarityChange = (value: string) => {
    const parsedValue = parseInt(value, 10);

    // If it's a valid vanilla rarity number (1-4), use as number
    if (!isNaN(parsedValue) && parsedValue >= 1 && parsedValue <= 4) {
      onQuickUpdate({ rarity: parsedValue });
    } else {
      // Otherwise it's a custom rarity, use as string
      onQuickUpdate({ rarity: value });
    }

    setShowRarityMenu(false);
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const blueprintCompat = joker.blueprint_compat !== false;
  const eternalCompat = joker.eternal_compat !== false;
  const perishableCompat = joker.perishable_compat !== false;
  const isUnlocked = joker.unlocked !== false;
  const isDiscovered = joker.discovered !== false;
  const forceEternal = joker.force_eternal === true;
  const forcePerishable = joker.force_perishable === true;
  const forceRental = joker.force_rental === true;
  const appearsInShop = joker.appears_in_shop !== false;

  const propertyIcons = [
    {
      icon: <WrenchIcon className="w-full h-full" />,
      tooltip: blueprintCompat
        ? "Visually Blueprint Compatbile"
        : "Visually Blueprint Incompatible",
      variant: "disabled" as const,
      isEnabled: blueprintCompat,
      onClick: () => onQuickUpdate({ blueprint_compat: !blueprintCompat }),
    },
    {
      icon: <StarIcon className="w-full h-full" />,
      tooltip: eternalCompat ? "Eternal Compatible" : "Cannot be made Eternal",
      variant: "disabled" as const,
      isEnabled: eternalCompat,
      onClick: () => onQuickUpdate({ eternal_compat: !eternalCompat }),
    },
    {
      icon: <SparklesIcon className="w-full h-full" />,
      tooltip: perishableCompat
        ? "Perishable Compatibility"
        : "Cannot be made Perishable",
      variant: "disabled" as const,
      isEnabled: perishableCompat,
      onClick: () => onQuickUpdate({ perishable_compat: !perishableCompat }),
    },
    {
      icon: isUnlocked ? (
        <LockOpenIcon className="w-full h-full" />
      ) : (
        <LockClosedIcon className="w-full h-full" />
      ),
      tooltip: isUnlocked ? "Unlocked by Default" : "Locked by Default",
      variant: "warning" as const,
      isEnabled: isUnlocked,
      onClick: () => onQuickUpdate({ unlocked: !isUnlocked }),
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
    {
      icon: <ExclamationCircleIcon className="w-full h-full" />,
      tooltip: forceEternal
        ? "Always Spawns Eternal"
        : "Normal Eternal Spawning",
      variant: "special" as const,
      isEnabled: forceEternal,
      onClick: () => onQuickUpdate({ force_eternal: !forceEternal }),
    },
    {
      icon: <ClockIcon className="w-full h-full" />,
      tooltip: forcePerishable
        ? "Always Spawns Perishable"
        : "Normal Perishable Spawning",
      variant: "warning" as const,
      isEnabled: forcePerishable,
      onClick: () => onQuickUpdate({ force_perishable: !forcePerishable }),
    },
    {
      icon: <CurrencyDollarIcon className="w-full h-full" />,
      tooltip: forceRental ? "Always Spawns Rental" : "Normal Rental Spawning",
      variant: "info" as const,
      isEnabled: forceRental,
      onClick: () => onQuickUpdate({ force_rental: !forceRental }),
    },
    {
      icon: appearsInShop ? (
        <BuildingStorefrontIcon className="w-full h-full" />
      ) : (
        <NoSymbolIcon className="w-full h-full" />
      ),
      tooltip: appearsInShop
        ? joker.rarity === 4
          ? "Forced Shop Appearance"
          : "Appears in Shop"
        : "Doesn't Appear in Shop",
      variant:
        appearsInShop && joker.rarity === 4
          ? ("special" as const)
          : ("success" as const),
      isEnabled: appearsInShop,
      onClick: () => onQuickUpdate({ appears_in_shop: !appearsInShop }),
    },
  ];

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="px-4 -mb-6 z-20 py-1 rounded-md border-2 font-bold cursor-pointer transition-all bg-black  tracking-widest border-balatro-money text-balatro-money w-18 text-center">
          {editingCost ? (
            <input
              type="number"
              value={tempCost}
              onChange={(e) => setTempCost(parseInt(e.target.value))}
              onBlur={handleCostSave}
              onKeyDown={(e) => {
                if (e.key === "Enter") handleCostSave();
                if (e.key === "Escape") {
                  setTempCost(joker.cost || 4);
                  setEditingCost(false);
                }
              }}
              className="w-full bg-transparent text-center outline-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
              autoFocus
            />
          ) : (
            <span
              onClick={() => {
                setTempCost(joker.cost || 4);
                setEditingCost(true);
              }}
            >
              ${joker.cost || 4}
            </span>
          )}
        </div>

        <div className="w-42 z-10 relative">
          <div className="relative">
            {joker.imagePreview && !imageLoadError ? (
              <>
                <img
                  src={joker.imagePreview}
                  alt={joker.name}
                  className="w-full h-full object-contain"
                  draggable="false"
                  onError={() => setImageLoadError(true)}
                />
                {joker.overlayImagePreview && (
                  <img
                    src={joker.overlayImagePreview}
                    alt={`${joker.name} overlay`}
                    className="absolute inset-0 w-full h-full object-contain"
                    draggable="false"
                  />
                )}
              </>
            ) : (
              <img
                src={
                  !fallbackAttempted
                    ? "/images/placeholderjokers/placeholder-joker.png"
                    : "/images/placeholder-joker.png"
                }
                alt="Default Joker"
                className="w-full h-full object-contain"
                draggable="false"
                onError={() => {
                  if (!fallbackAttempted) {
                    setFallbackAttempted(true);
                  }
                }}
              />
            )}
          </div>
        </div>

        <div className="relative z-30">
          <div
            className="px-6 py-1 -mt-6 rounded-md border-2 text-sm tracking-wide font-medium cursor-pointer transition-all bg-black"
            style={{
              borderColor: rarityColor,
              color: rarityColor,
            }}
            onClick={() => setShowRarityMenu(!showRarityMenu)}
          >
            {rarityText}
          </div>

          {showRarityMenu && (
            <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1 border-2 border-black-lighter rounded-lg shadow-lg z-50 overflow-hidden">
              {allRarities.map((rarity) => (
                <div
                  key={rarity.value.toString()}
                  className="px-3 py-1 text-xs font-medium cursor-pointer transition-all hover:bg-opacity-20 bg-black border-b border-black-lighter last:border-b-0"
                  style={{
                    color: getRarityBadgeColor(rarity.value, customRarities),
                  }}
                  onClick={() => handleRarityChange(rarity.value.toString())}
                >
                  {rarity.label}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Joker" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                showConfirmation({
                  type: "danger",
                  title: "Delete Joker",
                  description: `Are you sure you want to delete "${joker.name}"? This action cannot be undone.`,
                  confirmText: "Delete Forever",
                  cancelText: "Keep It",
                  confirmVariant: "danger",
                  onConfirm: () => onDelete(),
                });
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <div className="w-full">
                  <input
                    type="text"
                    value={tempName}
                    onChange={(e) => {
                      setTempName(e.target.value);
                      if (nameValidationError) {
                        const validation = validateJokerName(e.target.value);
                        if (validation.isValid) {
                          setNameValidationError("");
                        }
                      }
                    }}
                    onBlur={() => {
                      if (!nameValidationError) {
                        handleNameSave();
                      }
                    }}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleNameSave();
                      }
                      if (e.key === "Escape") {
                        setTempName(joker.name);
                        setEditingName(false);
                        setNameValidationError("");
                      }
                    }}
                    className={`text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text ${
                      nameValidationError ? "border-b-2 border-balatro-red" : ""
                    }`}
                    autoFocus
                  />
                </div>
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(joker.name);
                    setEditingName(true);
                    setNameValidationError("");
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {joker.name}
                </h3>
              )}
            </div>

            <div className=" mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(joker.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(joker.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(joker.description),
                  }}
                />
              )}
            </div>

            <div className="flex items-center justify-between mb-4 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center justify-between overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 hover:text-mint-light transition-colors cursor-pointer group"
                onClick={onEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <PuzzlePieceIcon className="h-6 w-6 group-hover:text-mint-lighter text-white transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Export Joker" show={hoveredButton === "export"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onExport}
                onMouseEnter={() => handleButtonHover("export")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <ArrowDownTrayIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Showcase" show={hoveredButton === "showcase"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onShowcase}
                onMouseEnter={() => handleButtonHover("showcase")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <CameraIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default JokerCard;

```

### src\components\pages\KeysPage.tsx

```
import React, { useState } from "react";
import { useParams, Navigate, useNavigate } from "react-router-dom";
import {
  KeyIcon,
  DocumentDuplicateIcon,
  CheckIcon,
  MagnifyingGlassIcon,
  PuzzlePieceIcon,
  CakeIcon,
  StarIcon,
  CpuChipIcon,
  TagIcon,
  BeakerIcon,
  BookOpenIcon,
  SparklesIcon,
} from "@heroicons/react/24/outline";
import {
  JOKERS,
  TAROT_CARDS,
  PLANET_CARDS,
  SPECTRAL_CARDS,
  ENHANCEMENTS,
  SEALS,
  EDITIONS,
  BOSS_BLINDS,
  TAGS,
  VOUCHERS,
} from "../data/BalatroUtils";

interface KeyItemProps {
  itemKey: string;
  label: string;
  onCopy: (key: string) => void;
  copiedKey: string | null;
}

const KeyItem: React.FC<KeyItemProps> = ({
  itemKey,
  label,
  onCopy,
  copiedKey,
}) => {
  const isCopied = copiedKey === itemKey;

  return (
    <div
      onClick={() => onCopy(itemKey)}
      className="flex items-center justify-between p-3 border border-black-lighter rounded-lg hover:border-mint/50 transition-all cursor-pointer group hover:bg-gradient-to-r hover:from-black-darker hover:to-mint/5"
    >
      <div className="flex-1 min-w-0">
        <div className="text-white-light font-medium text-sm mb-1 group-hover:text-mint transition-colors">
          {label}
        </div>
        <div className="text-white-darker text-xs font-mono">{itemKey}</div>
      </div>
      <div className="flex-shrink-0 ml-3">
        {isCopied ? (
          <div className="flex items-center gap-2 text-mint text-sm">
            <CheckIcon className="h-4 w-4" />
            <span>Copied!</span>
          </div>
        ) : (
          <DocumentDuplicateIcon className="h-4 w-4 text-white-darker group-hover:text-mint transition-colors" />
        )}
      </div>
    </div>
  );
};

interface KeySectionProps {
  title: string;
  icon: React.ComponentType<{ className?: string }>;
  items: ReadonlyArray<{ key: string; label: string }>;
  searchTerm: string;
  onCopy: (key: string) => void;
  copiedKey: string | null;
  color?: string;
}

const KeySection: React.FC<KeySectionProps> = ({
  title,
  icon: Icon,
  items,
  searchTerm,
  onCopy,
  copiedKey,
  color = "text-mint",
}) => {
  const filteredItems = items.filter(
    (item) =>
      item.label.toLowerCase().includes(searchTerm.toLowerCase()) ||
      item.key.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (filteredItems.length === 0 && searchTerm) {
    return null;
  }

  return (
    <div className="mb-8">
      <div className="flex items-center gap-3 mb-4">
        <Icon className={`h-6 w-6 ${color}`} />
        <h2 className="text-xl text-white-light font-medium">{title}</h2>
        <span className="text-white-darker text-sm">
          ({filteredItems.length} items)
        </span>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
        {filteredItems.map((item) => (
          <KeyItem
            key={item.key}
            itemKey={item.key}
            label={item.label}
            onCopy={onCopy}
            copiedKey={copiedKey}
          />
        ))}
      </div>
    </div>
  );
};

const SECTIONS = {
  jokers: {
    title: "Jokers",
    icon: PuzzlePieceIcon,
    items: JOKERS,
    color: "text-balatro-purple",
  },
  consumables: {
    title: "Consumables",
    icon: CakeIcon,
    items: [...TAROT_CARDS, ...PLANET_CARDS, ...SPECTRAL_CARDS],
    color: "text-mint",
  },
  enhancements: {
    title: "Enhancements",
    icon: StarIcon,
    items: ENHANCEMENTS(),
    color: "text-balatro-enhanced-new",
  },
  seals: {
    title: "Seals",
    icon: CpuChipIcon,
    items: SEALS(),
    color: "text-balatro-blue",
  },
  editions: {
    title: "Editions",
    icon: SparklesIcon,
    items: EDITIONS().map((edition) => ({
      key: edition.key,
      label: edition.label,
    })),
    color: "text-balatro-enhanced",
  },
  boss_blinds: {
    title: "Boss Blinds",
    icon: BeakerIcon,
    items: BOSS_BLINDS.map((blind) => ({
      key: blind.value,
      label: blind.label,
    })),
    color: "text-balatro-red",
  },
  tags: {
    title: "Tags",
    icon: TagIcon,
    items: TAGS.map((tag) => ({ key: tag.value, label: tag.label })),
    color: "text-balatro-orange",
  },
  vouchers: {
    title: "Vouchers",
    icon: BookOpenIcon,
    items: VOUCHERS().map((voucher) => ({
      key: voucher.value,
      label: voucher.label,
    })),
    color: "text-balatro-green",
  },
};

const KeysPage: React.FC = () => {
  const { section } = useParams<{ section?: string }>();
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState("");
  const [copiedKey, setCopiedKey] = useState<string | null>(null);

  const handleCopy = async (key: string) => {
    try {
      await navigator.clipboard.writeText(key);
      setCopiedKey(key);
      setTimeout(() => setCopiedKey(null), 2000);
    } catch (error) {
      console.error("Failed to copy:", error);
    }
  };

  // If no section is specified, show overview
  if (!section) {
    return (
      <div className="min-h-screen">
        <div className="p-8 font-lexend max-w-7xl mx-auto">
          <div className="text-center mb-8">
            <h1 className="text-3xl text-white-light tracking-widest mb-2">
              Balatro Keys Reference
            </h1>
            <p className="text-white-darker text-lg">
              Browse and copy game keys for your mods
            </p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {Object.entries(SECTIONS).map(([key, sectionData]) => {
              const Icon = sectionData.icon;
              return (
                <button
                  key={key}
                  onClick={() => navigate(`/keys/${key}`)}
                  className="group flex items-center gap-4 p-6 border border-black-lighter hover:border-mint/50 rounded-xl transition-all cursor-pointer hover:bg-gradient-to-r hover:from-black-darker hover:to-mint/5"
                >
                  <div
                    className={`p-3 bg-mint/20 rounded-xl group-hover:bg-mint/30 transition-all group-hover:scale-110`}
                  >
                    <Icon className={`h-6 w-6 ${sectionData.color}`} />
                  </div>
                  <div className="text-left flex-1">
                    <div className="text-white-light font-semibold text-lg mb-1 group-hover:text-mint transition-colors">
                      {sectionData.title}
                    </div>
                    <div className="text-white-darker text-sm">
                      {sectionData.items.length} keys
                    </div>
                  </div>
                </button>
              );
            })}
          </div>
        </div>
      </div>
    );
  }

  // If section doesn't exist, redirect to overview
  if (!SECTIONS[section as keyof typeof SECTIONS]) {
    return <Navigate to="/keys" replace />;
  }

  const currentSection = SECTIONS[section as keyof typeof SECTIONS];

  return (
    <div className="min-h-screen">
      <div className="p-8 font-lexend max-w-7xl mx-auto">
        <div className="flex items-center gap-4 mb-6">
          <button
            onClick={() => navigate("/keys")}
            className="text-white-darker hover:text-mint transition-colors cursor-pointer"
          >
            <KeyIcon className="h-6 w-6" />
          </button>
          <div className="text-white-darker">/</div>
          <div className="flex items-center gap-2">
            <currentSection.icon
              className={`h-6 w-6 ${currentSection.color}`}
            />
            <h1 className="text-2xl text-white-light tracking-widest">
              {currentSection.title}
            </h1>
          </div>
        </div>

        <div className="mb-6">
          <div className="relative group max-w-md">
            <MagnifyingGlassIcon className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-white-darker group-focus-within:text-mint transition-colors" />
            <input
              type="text"
              placeholder={`Search ${currentSection.title.toLowerCase()}...`}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-black-darker border-2 border-black-lighter rounded-lg pl-12 pr-4 py-3 text-white-light tracking-wider placeholder-white-darker focus:outline-none focus:border-mint transition-all duration-200"
            />
          </div>
        </div>

        <KeySection
          title={currentSection.title}
          icon={currentSection.icon}
          items={currentSection.items}
          searchTerm={searchTerm}
          onCopy={handleCopy}
          copiedKey={copiedKey}
          color={currentSection.color}
        />
      </div>
    </div>
  );
};

export default KeysPage;

```

### src\components\pages\ModMetadataPage.tsx

```
import { useEffect, useState, useCallback, useRef } from "react";
import {
  DocumentTextIcon,
  TagIcon,
  CodeBracketIcon,
  HashtagIcon,
  ClockIcon,
  ShieldCheckIcon,
  CubeIcon,
  PaintBrushIcon,
  PhotoIcon,
} from "@heroicons/react/24/outline";
import InputField from "../generic/InputField";
import Button from "../generic/Button";
import { ModMetadata } from "../data/BalatroUtils";
import Checkbox from "../generic/Checkbox";

interface ModMetadataValidation {
  isValid: boolean;
  errors: Record<string, string>;
  warnings: Record<string, string>;
}

// eslint-disable-next-line react-refresh/only-export-components
export const DEFAULT_MOD_METADATA: ModMetadata = {
  id: "mycustommod",
  name: "My Custom Mod",
  author: ["Anonymous"],
  description: "Custom jokers created with Joker Forge",
  prefix: "mycustom",
  main_file: "main.lua",
  version: "1.0.0",
  priority: 0,
  badge_colour: "666665",
  badge_text_colour: "FFFFFF",
  display_name: "My Custom Mod",
  dependencies: ["Steamodded (>=1.0.0~BETA-0827c)"],
  conflicts: [],
  provides: [],
  iconImage: "/images/modicon.png",
  hasUserUploadedIcon: false,
};

const validateModMetadata = (metadata: ModMetadata): ModMetadataValidation => {
  const errors: Record<string, string> = {};
  const warnings: Record<string, string> = {};

  if (!metadata.id) {
    errors.id = "Mod ID is required";
  } else if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(metadata.id)) {
    errors.id =
      "Mod ID must start with a letter and contain only letters, numbers, and underscores";
  } else if (["Steamodded", "Lovely", "Balatro"].includes(metadata.id)) {
    errors.id = "Mod ID cannot be 'Steamodded', 'Lovely', or 'Balatro'";
  }

  if (!metadata.name || !metadata.name.trim()) {
    errors.name = "Mod name is required";
  }

  if (
    !metadata.author ||
    metadata.author.length === 0 ||
    !metadata.author[0] ||
    !metadata.author[0].trim()
  ) {
    errors.author = "At least one author is required";
  }

  if (!metadata.description || !metadata.description.trim()) {
    errors.description = "Description is required";
  }

  if (!metadata.prefix) {
    errors.prefix = "Prefix is required";
  } else if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(metadata.prefix)) {
    errors.prefix =
      "Prefix must start with a letter and contain only letters, numbers, and underscores";
  }

  if (!metadata.main_file) {
    errors.main_file = "Main file is required";
  } else if (!metadata.main_file.endsWith(".lua")) {
    errors.main_file = "Main file must end with .lua extension";
  }

  if (metadata.version && !/^\d+\.\d+\.\d+.*$/.test(metadata.version)) {
    warnings.version = "Version should follow format (major).(minor).(patch)";
  }

  if (
    metadata.badge_colour &&
    !/^[0-9A-Fa-f]{6}([0-9A-Fa-f]{2})?$/.test(metadata.badge_colour)
  ) {
    warnings.badge_colour =
      "Badge colour should be a valid hex color (6 or 8 digits)";
  }

  if (
    metadata.badge_text_colour &&
    !/^[0-9A-Fa-f]{6}([0-9A-Fa-f]{2})?$/.test(metadata.badge_text_colour)
  ) {
    warnings.badge_text_colour =
      "Badge text colour should be a valid hex color (6 or 8 digits)";
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
    warnings,
  };
};

const generateModIdFromName = (name: string): string => {
  return (
    name
      .toLowerCase()
      .replace(/[^a-zA-Z0-9\s]/g, "")
      .replace(/\s+/g, "")
      .replace(/^[0-9]+/, "") || "mycustommod"
  );
};

const generatePrefixFromId = (id: string): string => {
  return id.toLowerCase().substring(0, 8);
};

const parseAuthorsString = (authorsString: string): string[] => {
  return authorsString
    .split(",")
    .map((author) => author.trim())
    .filter((author) => author.length > 0);
};

const formatAuthorsString = (authors: string[]): string => {
  return (authors || []).join(", ");
};

const parseDependenciesString = (dependenciesString: string): string[] => {
  return dependenciesString
    .split("\n")
    .map((dep) => dep.trim())
    .filter((dep) => dep.length > 0);
};

const formatDependenciesString = (dependencies: string[]): string => {
  return (dependencies || []).join("\n");
};

interface ModMetadataPageProps {
  metadata: ModMetadata;
  setMetadata: (metadata: ModMetadata) => void;
}

const ModMetadataPage: React.FC<ModMetadataPageProps> = ({
  metadata,
  setMetadata,
}) => {
  const [authorsString, setAuthorsString] = useState(
    formatAuthorsString(metadata.author)
  );
  const [dependenciesString, setDependenciesString] = useState(
    formatDependenciesString(metadata.dependencies)
  );
  const [conflictsString, setConflictsString] = useState(
    formatDependenciesString(metadata.conflicts)
  );
  const [providesString, setProvidesString] = useState(
    formatDependenciesString(metadata.provides)
  );
  const [hasInitialized, setHasInitialized] = useState(false);

  const previousNameRef = useRef(metadata.name);
  const metadataRef = useRef(metadata);

  useEffect(() => {
    metadataRef.current = metadata;
  });

  useEffect(() => {
    if (!hasInitialized) {
      const needsDefaults =
        !metadata.id ||
        !metadata.name ||
        !metadata.author ||
        !Array.isArray(metadata.author) ||
        metadata.author.length === 0 ||
        !metadata.description ||
        !metadata.prefix ||
        !metadata.main_file ||
        !metadata.version ||
        typeof metadata.priority !== "number" ||
        !metadata.badge_colour ||
        !metadata.badge_text_colour ||
        !metadata.display_name ||
        !metadata.dependencies ||
        !Array.isArray(metadata.dependencies) ||
        !metadata.conflicts ||
        !Array.isArray(metadata.conflicts) ||
        !metadata.provides ||
        !Array.isArray(metadata.provides);

      if (needsDefaults) {
        setMetadata({
          id: metadata.id || DEFAULT_MOD_METADATA.id,
          name: metadata.name || DEFAULT_MOD_METADATA.name,
          author:
            Array.isArray(metadata.author) && metadata.author.length > 0
              ? metadata.author
              : DEFAULT_MOD_METADATA.author,
          description: metadata.description || DEFAULT_MOD_METADATA.description,
          prefix: metadata.prefix || DEFAULT_MOD_METADATA.prefix,
          main_file: metadata.main_file || DEFAULT_MOD_METADATA.main_file,
          version: metadata.version || DEFAULT_MOD_METADATA.version,
          priority:
            typeof metadata.priority === "number"
              ? metadata.priority
              : DEFAULT_MOD_METADATA.priority,
          badge_colour:
            metadata.badge_colour || DEFAULT_MOD_METADATA.badge_colour,
          badge_text_colour:
            metadata.badge_text_colour ||
            DEFAULT_MOD_METADATA.badge_text_colour,
          display_name:
            metadata.display_name ||
            metadata.name ||
            DEFAULT_MOD_METADATA.display_name,
          dependencies: Array.isArray(metadata.dependencies)
            ? metadata.dependencies
            : DEFAULT_MOD_METADATA.dependencies,
          conflicts: Array.isArray(metadata.conflicts)
            ? metadata.conflicts
            : DEFAULT_MOD_METADATA.conflicts,
          provides: Array.isArray(metadata.provides)
            ? metadata.provides
            : DEFAULT_MOD_METADATA.provides,
        });
      }
      setHasInitialized(true);
    }
  }, [metadata, setMetadata, hasInitialized]);

  const updateMetadata = useCallback(
    (updates: Partial<ModMetadata>) => {
      setMetadata({ ...metadataRef.current, ...updates });
    },
    [setMetadata]
  );

  useEffect(() => {
    const currentMetadata = metadataRef.current;

    if (
      currentMetadata.name &&
      currentMetadata.name !== DEFAULT_MOD_METADATA.name &&
      currentMetadata.name !== previousNameRef.current
    ) {
      previousNameRef.current = currentMetadata.name;

      const generatedId = generateModIdFromName(currentMetadata.name);
      const generatedPrefix = generatePrefixFromId(generatedId);

      if (
        currentMetadata.id !== generatedId ||
        currentMetadata.prefix !== generatedPrefix ||
        currentMetadata.display_name !== currentMetadata.name
      ) {
        setMetadata({
          ...currentMetadata,
          id: generatedId,
          prefix: generatedPrefix,
          display_name: currentMetadata.name,
        });
      }
    }
  }, [metadata.name, setMetadata]);

  const validation = validateModMetadata(metadata);

  const handleAuthorsChange = (value: string) => {
    setAuthorsString(value);
    updateMetadata({ author: parseAuthorsString(value) });
  };

  const handleDependenciesChange = (value: string) => {
    setDependenciesString(value);
    updateMetadata({ dependencies: parseDependenciesString(value) });
  };

  const handleConflictsChange = (value: string) => {
    setConflictsString(value);
    updateMetadata({ conflicts: parseDependenciesString(value) });
  };

  const handleProvidesChange = (value: string) => {
    setProvidesString(value);
    updateMetadata({ provides: parseDependenciesString(value) });
  };

  const processModIconImage = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      if (!ctx) {
        reject(new Error("Failed to get canvas context"));
        return;
      }

      img.onload = () => {
        canvas.width = 34;
        canvas.height = 34;

        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, 34, 34);

        resolve(canvas.toDataURL("image/png"));
      };

      img.onerror = () => reject(new Error("Failed to load image"));
      img.src = URL.createObjectURL(file);
    });
  };

  const isValidHexColor = (color: string) =>
    /^[0-9A-Fa-f]{6}([0-9A-Fa-f]{2})?$/.test(color);

  return (
    <div className="min-h-screen">
      <div className="p-8 font-lexend max-w-7xl mx-auto">
        <h1 className="text-3xl text-white-light tracking-widest text-center">
          Mod Metadata
        </h1>
        <h1 className="text-xl text-white-dark font-light tracking-widest mb-8 text-center">
          {metadata.name || ""}
        </h1>
      </div>

      <div className="max-w-6xl mx-auto space-y-8">
        <div>
          <h2 className="text-lg text-white-light font-medium mb-6 flex items-center gap-2">
            <DocumentTextIcon className="h-5 w-5 text-mint" />
            Basic Information
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <InputField
                value={metadata.name || ""}
                onChange={(e) => updateMetadata({ name: e.target.value })}
                placeholder="My Custom Mod"
                darkmode={true}
                icon={
                  <DocumentTextIcon className="h-5 w-5 text-mint stroke-2" />
                }
                label="Mod Name"
              />
              {validation.errors.name && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.name}
                </p>
              )}
            </div>

            <div>
              <InputField
                value={metadata.id || ""}
                onChange={(e) => updateMetadata({ id: e.target.value })}
                placeholder="mycustommod"
                darkmode={true}
                icon={<HashtagIcon className="h-5 w-5 text-mint stroke-2" />}
                label="Mod ID"
              />
              {validation.errors.id && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.id}
                </p>
              )}
              <p className="text-white-darker text-xs mt-1">
                Must be unique, start with letter, alphanumeric + underscore
                only
              </p>
            </div>

            <div>
              <InputField
                value={authorsString}
                onChange={(e) => handleAuthorsChange(e.target.value)}
                placeholder="Anonymous"
                darkmode={true}
                label="Authors"
              />
              {validation.errors.author && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.author}
                </p>
              )}
              <p className="text-white-darker text-xs mt-1">
                Separate multiple authors with commas
              </p>
            </div>

            <div>
              <InputField
                value={metadata.prefix || ""}
                onChange={(e) => updateMetadata({ prefix: e.target.value })}
                placeholder="mycustom"
                darkmode={true}
                icon={<TagIcon className="h-5 w-5 text-mint stroke-2" />}
                label="Prefix"
              />
              {validation.errors.prefix && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.prefix}
                </p>
              )}
              <p className="text-white-darker text-xs mt-1">
                Added to all object keys, must be unique
              </p>
            </div>

            <div className="md:col-span-2">
              <label className="block text-white-light text-sm font-medium mb-2">
                Description
              </label>
              <textarea
                value={metadata.description || ""}
                onChange={(e) =>
                  updateMetadata({ description: e.target.value })
                }
                placeholder="Custom jokers created with Joker Forge"
                className="w-full h-24 px-4 py-3 bg-black-darker border-2 border-black-light rounded-lg text-white-light placeholder-white-darker focus:border-mint focus:outline-none resize-none"
              />
              {validation.errors.description && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.description}
                </p>
              )}
            </div>

            <div>
              <InputField
                value={metadata.main_file || ""}
                onChange={(e) => updateMetadata({ main_file: e.target.value })}
                placeholder="main.lua"
                darkmode={true}
                icon={
                  <CodeBracketIcon className="h-5 w-5 text-mint stroke-2" />
                }
                label="Main File"
              />
              {validation.errors.main_file && (
                <p className="text-red-400 text-xs mt-1">
                  {validation.errors.main_file}
                </p>
              )}
            </div>
          </div>
        </div>
        <div>
          <Checkbox
            id="a"
            label="Disable Vanilla Jokers"
            checked={metadata.disable_vanilla ?? false} // Assuming metadataRef holds the latest state
            onChange={(e) => {
              updateMetadata({ disable_vanilla: e });
            }}
          />
          <p className="text-xs text-white-darker mt-2">
            Jimbo may still appear
          </p>
        </div>

        <div className="border-t border-black-light pt-8">
          <h2 className="text-lg text-white-light font-medium mb-6 flex items-center gap-2">
            <PaintBrushIcon className="h-5 w-5 text-mint" />
            Appearance & Display
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div>
              <InputField
                value={metadata.display_name || ""}
                onChange={(e) =>
                  updateMetadata({ display_name: e.target.value })
                }
                placeholder={metadata.name || "Short name for badge"}
                darkmode={true}
                icon={<TagIcon className="h-5 w-5 text-mint stroke-2" />}
                label="Display Name"
              />
              <p className="text-white-darker text-xs mt-1">
                Shown on mod badge, defaults to mod name
              </p>
            </div>

            <div>
              <InputField
                value={metadata.badge_colour || ""}
                onChange={(e) =>
                  updateMetadata({ badge_colour: e.target.value })
                }
                placeholder="666665"
                darkmode={true}
                icon={<span className="text-mint">#</span>}
                label="Badge Color"
              />
              {validation.warnings.badge_colour && (
                <p className="text-yellow-400 text-xs mt-1">
                  {validation.warnings.badge_colour}
                </p>
              )}
              <p className="text-white-darker text-xs mt-1">
                Hex color without #
              </p>
            </div>

            <div>
              <InputField
                value={metadata.badge_text_colour || ""}
                onChange={(e) =>
                  updateMetadata({ badge_text_colour: e.target.value })
                }
                placeholder="FFFFFF"
                darkmode={true}
                icon={<span className="text-mint">#</span>}
                label="Badge Text Color"
              />
              {validation.warnings.badge_text_colour && (
                <p className="text-yellow-400 text-xs mt-1">
                  {validation.warnings.badge_text_colour}
                </p>
              )}
              <p className="text-white-darker text-xs mt-1">
                Hex color without #
              </p>
            </div>
          </div>

          <div className=" p-4">
            <div className="flex justify-center">
              <div
                className="px-3 py-1 rounded text-2xl font-bold border"
                style={{
                  backgroundColor: isValidHexColor(metadata.badge_colour || "")
                    ? `#${metadata.badge_colour}`
                    : "#666665",
                  color: isValidHexColor(metadata.badge_text_colour || "")
                    ? `#${metadata.badge_text_colour}`
                    : "#FFFFFF",
                  borderColor: isValidHexColor(metadata.badge_colour || "")
                    ? `#${metadata.badge_colour}`
                    : "#666665",
                }}
              >
                {metadata.display_name ||
                  (metadata.name && metadata.name.substring(0, 8)) ||
                  "MOD"}
              </div>
            </div>
          </div>
        </div>

        <div className="border-t border-black-lighter pt-6 mt-6">
          <h4 className="text-white-light font-medium text-sm mb-4 tracking-wider flex items-center gap-2">
            <PhotoIcon className="h-4 w-4 text-mint" />
            MOD ICON (34x34px)
          </h4>
          <div className="flex flex-col items-center">
            <div className="w-34 h-34 rounded-lg flex flex-col items-center justify-center relative">
              {metadata.iconImage ? (
                <img
                  src={metadata.iconImage}
                  alt="Mod Icon"
                  className="w-24 h-24 object-contain rounded"
                  style={{ imageRendering: "pixelated" }}
                />
              ) : (
                <>
                  <PhotoIcon className="h-8 w-8 text-white-darker mb-2" />
                  <span className="text-white-darker text-xs text-center">
                    No icon uploaded
                    <br />
                    34x34 recommended
                  </span>
                </>
              )}
              <input
                type="file"
                accept="image/*"
                onChange={async (e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    try {
                      const processedImage = await processModIconImage(file);
                      updateMetadata({
                        iconImage: processedImage,
                        hasUserUploadedIcon: true,
                      });
                    } catch (error) {
                      console.error("Failed to process mod icon:", error);
                    }
                  }
                  e.target.value = "";
                }}
                className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
              />
            </div>
            <Button
              variant="secondary"
              size="sm"
              onClick={() => {
                const fileInput = document.querySelector(
                  'input[type="file"]'
                ) as HTMLInputElement | null;
                if (fileInput) {
                  fileInput.click();
                }
              }}
            >
              Change Icon
            </Button>
          </div>
        </div>

        <div className="border-t border-black-light pt-8">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div>
              <h2 className="text-lg text-white-light font-medium mb-6 flex items-center gap-2">
                <ClockIcon className="h-5 w-5 text-mint" />
                Version & Loading
              </h2>
              <div className="space-y-6">
                <div>
                  <InputField
                    value={metadata.version || ""}
                    onChange={(e) =>
                      updateMetadata({ version: e.target.value })
                    }
                    placeholder="1.0.0"
                    darkmode={true}
                    icon={
                      <HashtagIcon className="h-5 w-5 text-mint stroke-2" />
                    }
                    label="Version"
                  />
                  {validation.warnings.version && (
                    <p className="text-yellow-400 text-xs mt-1">
                      {validation.warnings.version}
                    </p>
                  )}
                  <p className="text-white-darker text-xs mt-1">
                    Format: (major).(minor).(patch), use ~ for beta
                  </p>
                </div>

                <div>
                  <InputField
                    value={(metadata.priority || 0).toString()}
                    onChange={(e) => {
                      const value = e.target.value;
                      const numValue = value === "" ? 0 : parseInt(value);
                      if (!isNaN(numValue)) {
                        updateMetadata({ priority: numValue });
                      }
                    }}
                    placeholder="0"
                    darkmode={true}
                    icon={<CubeIcon className="h-5 w-5 text-mint stroke-2" />}
                    label="Priority"
                  />
                  <p className="text-white-darker text-xs mt-1">
                    Negative values load first, positive load last
                  </p>
                </div>
              </div>
            </div>

            <div className="border border-black-lighter rounded-lg p-4">
              <h4 className="text-white-light font-medium text-sm mb-3 tracking-wider">
                MOD SUMMARY
              </h4>
              <div className="space-y-2 text-xs">
                <div className="flex justify-between">
                  <span className="text-white-darker">Name:</span>
                  <span className="text-white-light">
                    {metadata.name || "N/A"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-white-darker">ID:</span>
                  <span className="text-white-light">
                    {metadata.id || "N/A"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-white-darker">Version:</span>
                  <span className="text-white-light">
                    {metadata.version || "N/A"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-white-darker">Author:</span>
                  <span className="text-white-light">
                    {(metadata.author || []).join(", ") || "N/A"}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div className="border-t border-black-light pt-8">
          <h2 className="text-lg text-white-light font-medium mb-6 flex items-center gap-2">
            <ShieldCheckIcon className="h-5 w-5 text-mint" />
            Dependencies & Conflicts
          </h2>
          <div className="space-y-6">
            <div>
              <label className="block text-white-light text-sm font-medium mb-2">
                Dependencies
              </label>
              <textarea
                value={dependenciesString}
                onChange={(e) => handleDependenciesChange(e.target.value)}
                placeholder="Steamodded (>=1.0.0~BETA-0404a)"
                className="w-full h-20 px-4 py-3 bg-black-darker border-2 border-black-light rounded-lg text-white-light placeholder-white-darker focus:border-mint focus:outline-none resize-none"
              />
              <p className="text-white-darker text-xs mt-1">
                One dependency per line, with version constraints (&gt;=, ==,
                &lt;&lt;, etc.)
              </p>
            </div>

            <div>
              <label className="block text-white-light text-sm font-medium mb-2">
                Conflicts
              </label>
              <textarea
                value={conflictsString}
                onChange={(e) => handleConflictsChange(e.target.value)}
                placeholder="SomeMod (>=1.1) (&lt;&lt;2~)"
                className="w-full h-16 px-4 py-3 bg-black-darker border-2 border-black-light rounded-lg text-white-light placeholder-white-darker focus:border-mint focus:outline-none resize-none"
              />
              <p className="text-white-darker text-xs mt-1">
                Mods that cannot be installed alongside this mod
              </p>
            </div>

            <div>
              <label className="block text-white-light text-sm font-medium mb-2">
                Provides
              </label>
              <textarea
                value={providesString}
                onChange={(e) => handleProvidesChange(e.target.value)}
                placeholder="SomeAPIMod (1.0)"
                className="w-full h-16 px-4 py-3 bg-black-darker border-2 border-black-light rounded-lg text-white-light placeholder-white-darker focus:border-mint focus:outline-none resize-none"
              />
              <p className="text-white-darker text-xs mt-1">
                Alternative mod IDs this mod can fulfill dependencies for
              </p>
            </div>
          </div>
        </div>

        <div className="border-t border-black-light pt-8">
          <div className="border border-black-lighter rounded-lg p-4">
            <h4 className="text-white-light font-medium text-sm mb-3 tracking-wider">
              JSON PREVIEW
            </h4>
            <div className="bg-black border border-black-light rounded p-3 max-h-60 overflow-y-auto custom-scrollbar">
              <pre className="text-white-darker text-xs font-mono whitespace-pre-wrap">
                {JSON.stringify(metadata, null, 2)}
              </pre>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ModMetadataPage;

```

### src\components\pages\NotFoundPage.tsx

```
import React from "react";
import { useNavigate } from "react-router-dom";
import {
  ExclamationTriangleIcon,
  HomeIcon,
  ArrowLeftIcon,
} from "@heroicons/react/24/outline";
import Button from "../generic/Button";

const NotFoundPage: React.FC = () => {
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate("/overview");
  };

  const handleGoBack = () => {
    navigate(-1);
  };

  return (
    <div className="min-h-screen flex items-center justify-center p-8">
      <div className="max-w-md w-full">
        <div className="p-8 text-center">
          {/* Error Icon */}
          <div className="mb-6">
            <ExclamationTriangleIcon className="h-16 w-16 text-mint opacity-80 mx-auto" />
          </div>

          {/* Error Code */}
          <div className="mb-4">
            <h1 className="text-6xl font-bold text-white-light mb-2 font-game tracking-widest">
              404
            </h1>
            <div className="w-16 h-1 bg-mint mx-auto rounded-full"></div>
          </div>

          {/* Error Message */}
          <div className="mb-8">
            <h2 className="text-xl text-white-light font-light mb-3 tracking-wide">
              Page Not Found
            </h2>
            <p className="text-white-darker text-sm leading-relaxed">
              Oh no! This page doesn't exist or has been moved. Please check the
              URL or return to the homepage.
            </p>
          </div>

          {/* Action Buttons */}
          <div className="space-y-3">
            <Button
              variant="primary"
              onClick={handleGoHome}
              icon={<HomeIcon className="h-5 w-5" />}
              fullWidth
              size="lg"
              className="shadow-lg hover:shadow-xl transition-shadow"
            >
              Back to Overview
            </Button>

            <Button
              variant="secondary"
              onClick={handleGoBack}
              icon={<ArrowLeftIcon className="h-4 w-4" />}
              fullWidth
            >
              Go Back
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NotFoundPage;

```

### src\components\pages\seals\EditSealInfo.tsx

```
import React, { useState, useRef, useEffect, useCallback, useContext } from "react";
import {
  PhotoIcon,
  BoltIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
  SwatchIcon,
} from "@heroicons/react/24/outline";
import InputField from "../../generic/InputField";
import Checkbox from "../../generic/Checkbox";
import Button from "../../generic/Button";
import BalatroCard from "../../generic/BalatroCard";
import InfoDescriptionBox from "../../generic/InfoDescriptionBox";
import { SealData, slugify } from "../../data/BalatroUtils";
import {
  validateJokerName,
  validateDescription,
  ValidationResult,
} from "../../generic/validationUtils";
import { applyAutoFormatting } from "../../generic/balatroTextFormatter";
import { UserConfigContext } from "../../Contexts";

interface EditSealInfoProps {
  isOpen: boolean;
  seal: SealData;
  onClose: () => void;
  onSave: (seal: SealData) => void;
  onDelete: (sealId: string) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const predefinedColors = [
  "#FF6B6B",
  "#4ECDC4",
  "#45B7D1",
  "#96CEB4",
  "#FFEAA7",
  "#DDA0DD",
  "#FFB347",
  "#FF69B4",
  "#87CEEB",
  "#98FB98",
  "#F0E68C",
  "#DEB887",
  "#FF4500",
  "#32CD32",
  "#1E90FF",
  "#FF1493",
  "#FFD700",
  "#8A2BE2",
  "#DC143C",
  "#00CED1",
  "#FF6347",
  "#40E0D0",
  "#EE82EE",
  "#90EE90",
];

const EditSealInfo: React.FC<EditSealInfoProps> = ({
  isOpen,
  seal,
  onClose,
  onSave,
  onDelete,
  showConfirmation,
}) => {
  const {userConfig, setUserConfig} = useContext(UserConfigContext)
  const [formData, setFormData] = useState<SealData>(seal);
  const [activeTab, setActiveTab] = useState<
    "visual" | "description" | "colour"
  >("visual");
  const [placeholderError, setPlaceholderError] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  const [lastDescription, setLastDescription] = useState<string>("");
  const [autoFormatEnabled, setAutoFormatEnabled] = useState(userConfig.defaultAutoFormat ?? true);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);
  const [lastFormattedText, setLastFormattedText] = useState<string>("");

  const [placeholderCredits, setPlaceholderCredits] = useState<
    Record<number, string>
  >({});

  const [validationResults, setValidationResults] = useState<{
    name?: ValidationResult;
    description?: ValidationResult;
  }>({});

  const validateField = (field: string, value: string) => {
    let result: ValidationResult;
    switch (field) {
      case "name":
        result = validateJokerName(value);
        break;
      case "description":
        result = validateDescription(value);
        break;
      default:
        return;
    }

    setValidationResults((prev) => ({
      ...prev,
      [field]: result,
    }));
  };

  useEffect(() => {
    const loadCredits = async () => {
      try {
        const response = await fetch("/images/placeholderseals/credit.txt");
        const text = await response.text();
        console.log("Raw credit file content:", JSON.stringify(text));

        const credits: Record<number, string> = {};

        text.split("\n").forEach((line, lineIndex) => {
          const trimmed = line.trim();
          console.log(`Line ${lineIndex}: "${trimmed}"`);

          if (trimmed && trimmed.includes(":")) {
            const [indexStr, nameStr] = trimmed.split(":");
            const index = indexStr?.trim();
            const name = nameStr?.trim();

            if (index && name) {
              const indexNum = parseInt(index);
              if (!isNaN(indexNum)) {
                credits[indexNum] = name;
              }
            }
          }
        });

        setPlaceholderCredits(credits);
      } catch (error) {
        console.error("Failed to load placeholder credits:", error);
      }
    };

    loadCredits();
  }, []);

  const handleSave = useCallback(() => {
    const nameValidation = validateJokerName(formData.name);
    const descValidation = validateDescription(formData.description);

    if (!nameValidation.isValid || !descValidation.isValid) {
      setValidationResults({
        name: nameValidation,
        description: descValidation,
      });
      return;
    }

    onSave(formData);
    onClose();
  }, [formData, onSave, onClose]);

  useEffect(() => {
    if (isOpen) {
      setFormData({
        ...seal,
        unlocked: seal.unlocked !== false,
        discovered: seal.discovered !== false,
        no_collection: seal.no_collection === true,
        badge_colour: seal.badge_colour || "#000000",
        sealKey: seal.sealKey || slugify(seal.name),
        hasUserUploadedImage: seal.hasUserUploadedImage || false,
      });
      setPlaceholderError(false);
      setLastDescription(seal.description || "");
      setLastFormattedText("");
      setValidationResults({});
    }
  }, [isOpen, seal]);

  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current &&
        !modalRef.current.contains(event.target as Node)
      ) {
        handleSave();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, handleSave]);

  if (!isOpen) return null;

  const parseTag = (tag: string): Record<string, string> => {
    const content = tag.slice(1, -1);
    if (!content) return {};

    const modifiers: Record<string, string> = {};
    const parts = content.split(",");

    for (const part of parts) {
      const [key, value] = part.split(":");
      if (key && value) {
        modifiers[key.trim()] = value.trim();
      }
    }

    return modifiers;
  };

  const buildTag = (modifiers: Record<string, string>): string => {
    if (Object.keys(modifiers).length === 0) return "{}";

    const parts = Object.entries(modifiers).map(
      ([key, value]) => `${key}:${value}`
    );
    return `{${parts.join(",")}}`;
  };

  const handleInputChange = (
    field: string,
    value: string,
    shouldAutoFormat: boolean = true
  ) => {
    let finalValue = value;

    if (field === "description" && shouldAutoFormat) {
      const result = applyAutoFormatting(
        value,
        lastFormattedText,
        autoFormatEnabled,
        false
      );
      finalValue = result.formatted;

      if (result.hasChanges) {
        setLastFormattedText(finalValue);
      }

      setFormData({
        ...formData,
        [field]: finalValue,
      });
    } else if (field === "name") {
      setFormData({
        ...formData,
        [field]: value,
        sealKey: slugify(value),
      });
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    validateField(field, finalValue);
  };

  const handleCheckboxChange = (field: string, checked: boolean) => {
    setFormData({
      ...formData,
      [field]: checked,
    });
  };

  const upscaleImage = (img: HTMLImageElement): string => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = 142;
    canvas.height = 190;

    if (ctx) {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, 142, 190);
    }

    return canvas.toDataURL("image/png");
  };

  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          let finalImageData: string;

          if (
            (img.width === 71 && img.height === 95) ||
            (img.width === 142 && img.height === 190)
          ) {
            if (img.width === 71 && img.height === 95) {
              finalImageData = upscaleImage(img);
            } else {
              finalImageData = reader.result as string;
            }

            setFormData({
              ...formData,
              imagePreview: finalImageData,
              hasUserUploadedImage: true,
            });
            setPlaceholderError(false);
          } else {
            alert(
              `Image dimensions must be either 71x95 or 142x190 pixels. Your image is ${img.width}x${img.height}.`
            );
          }
        };
        img.src = reader.result as string;
      };
      reader.readAsDataURL(file);
    }
  };

  const getImageCredit = (seal: SealData): string | null => {
    if (seal.hasUserUploadedImage) {
      return null;
    }

    if (
      seal.placeholderCreditIndex &&
      placeholderCredits[seal.placeholderCreditIndex]
    ) {
      return placeholderCredits[seal.placeholderCreditIndex];
    }
    return null;
  };

  const handleDelete = () => {
    showConfirmation({
      type: "danger",
      title: "Delete Seal",
      description: `Are you sure you want to delete "${formData.name}"? This action cannot be undone.`,
      confirmText: "Delete Forever",
      cancelText: "Keep It",
      onConfirm: () => {
        onDelete(seal.id);
        onClose();
      },
    });
  };

  const insertTagSmart = (tag: string, autoClose: boolean = true) => {
    const textArea = document.getElementById(
      "seal-description-edit"
    ) as HTMLTextAreaElement;
    if (!textArea) return;

    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    const currentValue = textArea.value;
    const selectedText = currentValue.substring(startPos, endPos);

    setLastDescription(currentValue);
    setLastFormattedText(currentValue);

    let newText: string;
    let newCursorPos: number;

    const tagMatch = selectedText.match(/^(\{[^}]*\})(.*?)(\{\})$/);

    if (tagMatch) {
      const [, openTag, content, closeTag] = tagMatch;
      const modifiers = parseTag(openTag);

      const newTagContent = tag.slice(1, -1);
      const [newKey, newValue] = newTagContent.split(":");

      if (newKey && newValue) {
        modifiers[newKey] = newValue;
      }

      const newOpenTag = buildTag(modifiers);
      const newSelectedText = `${newOpenTag}${content}${closeTag}`;

      newText =
        currentValue.substring(0, startPos) +
        newSelectedText +
        currentValue.substring(endPos);
      newCursorPos = startPos + newOpenTag.length + content.length + 2;
    } else if (selectedText) {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length + 2;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          selectedText +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length + selectedText.length;
      }
    } else {
      if (autoClose) {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          "{}" +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      } else {
        newText =
          currentValue.substring(0, startPos) +
          tag +
          currentValue.substring(endPos);
        newCursorPos = startPos + tag.length;
      }
    }

    handleInputChange("description", newText, false);

    setTimeout(() => {
      textArea.focus();
      textArea.setSelectionRange(newCursorPos, newCursorPos);
    }, 0);
  };

  const tabs = [
    { id: "visual", label: "Visual & Properties", icon: PhotoIcon },
    { id: "description", label: "Description", icon: DocumentTextIcon },
    { id: "colour", label: "Badge", icon: SwatchIcon },
  ];

  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>
  ) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z") {
        e.preventDefault();
        const currentDesc = formData.description;
        handleInputChange("description", lastDescription, false);
        setLastDescription(currentDesc);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      const textarea = e.target as HTMLTextAreaElement;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      const newValue = value.substring(0, start) + "[s]" + value.substring(end);

      setLastDescription(value);
      setLastFormattedText(value);
      handleInputChange("description", newValue, false);

      setTimeout(() => {
        textarea.setSelectionRange(start + 3, start + 3);
      }, 0);
    }
  };

  return (
    <div className="fixed inset-0 flex bg-black-darker/80 backdrop-blur-sm items-center justify-center z-50 font-lexend">
      <div ref={modalRef} className="flex items-start gap-8 max-h-[90vh]">
        <div className="bg-black-dark border-2 border-black-lighter rounded-lg w-[100vh] h-[90vh] flex flex-col relative overflow-hidden">
          <div className="flex ">
            {tabs.map((tab, index) => {
              const Icon = tab.icon;
              const isActive = activeTab === tab.id;
              return (
                <button
                  key={tab.id}
                  onClick={() =>
                    setActiveTab(tab.id as "visual" | "description" | "colour")
                  }
                  className={`flex-1 flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium bg-black transition-all relative border-b-2 ${
                    isActive
                      ? "text-mint-lighter bg-black-dark border-mint"
                      : "text-white-darker hover:text-white-light hover:bg-black-dark border-b-2 border-black-lighter"
                  }`}
                >
                  <Icon className="h-4 w-4" />
                  {tab.label}
                  {index < tabs.length - 1 && !isActive && (
                    <div className="absolute right-0 top-1/2 -translate-y-1/2 w-px h-4 bg-black-lighter"></div>
                  )}
                </button>
              );
            })}
          </div>

          <div className="flex-1 overflow-hidden relative">
            <div className="h-full overflow-y-auto custom-scrollbar">
              {activeTab === "visual" && (
                <div className="p-6 space-y-6">
                  <PuzzlePieceIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <PhotoIcon className="h-5 w-5 text-mint" />
                        Visual Assets
                      </h4>
                      <div className="flex gap-6">
                        <div className="flex-shrink-0">
                          <div className="aspect-[142/190] w-60 rounded-lg overflow-hidden relative">
                            {formData.imagePreview ? (
                              <img
                                src={formData.imagePreview}
                                alt={formData.name}
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => setPlaceholderError(true)}
                              />
                            ) : !placeholderError ? (
                              <img
                                src={
                                  !fallbackAttempted
                                    ? "/images/placeholderseals/placeholder-seal.png"
                                    : "/images/placeholder-seal.png"
                                }
                                alt="Placeholder Seal"
                                className="w-full h-full object-cover"
                                draggable="false"
                                onError={() => {
                                  if (!fallbackAttempted) {
                                    setFallbackAttempted(true);
                                  } else {
                                    setPlaceholderError(true);
                                  }
                                }}
                              />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center">
                                <PhotoIcon className="h-16 w-16 text-white-darker opacity-50" />
                              </div>
                            )}
                          </div>
                          <input
                            type="file"
                            accept="image/*"
                            onChange={handleImageUpload}
                            className="hidden"
                            ref={fileInputRef}
                          />
                          <div className="space-y-2 mt-3">
                            <Button
                              onClick={() => fileInputRef.current?.click()}
                              variant="secondary"
                              className="w-full"
                              size="sm"
                              icon={<PhotoIcon className="h-4 w-4" />}
                            >
                              {formData.imagePreview
                                ? "Change Image"
                                : "Upload Image"}
                            </Button>
                          </div>
                          <div className="text-center mt-2">
                            <p className="text-xs text-white-darker">
                              Accepted: 7195px or 142190px
                            </p>
                            {(() => {
                              const credit = getImageCredit(formData);
                              return credit ? (
                                <p className="text-xs text-white-darker mt-1">
                                  Credit: {credit}
                                </p>
                              ) : null;
                            })()}
                          </div>
                        </div>

                        <div className="flex-1 space-y-4">
                          <div>
                            <InputField
                              value={formData.name}
                              onChange={(e) =>
                                handleInputChange("name", e.target.value, false)
                              }
                              placeholder="Enter seal name"
                              separator={true}
                              label="Seal Name"
                              size="md"
                              error={
                                validationResults.name &&
                                !validationResults.name.isValid
                                  ? validationResults.name.error
                                  : undefined
                              }
                            />
                          </div>
                          <InputField
                            value={formData.sealKey || ""}
                            onChange={(e) =>
                              handleInputChange(
                                "sealKey",
                                e.target.value,
                                false
                              )
                            }
                            placeholder="Enter seal key"
                            separator={true}
                            label="Seal Key (Code Name)"
                            size="md"
                          />
                          <p className="text-xs text-white-darker -mt-2">
                            Used in code generation. Auto-fills when you type
                            the name.
                          </p>

                          <div>
                            <h4 className="text-white-light font-medium text-base mb-3 justify-center pt-2 flex tracking-wider items-center gap-2">
                              <BoltIcon className="h-5 w-5 text-mint" />
                              Seal Properties
                            </h4>
                            <div className="space-y-4 rounded-lg border border-black-lighter p-4 bg-black-darker/30">
                              <div>
                                <p className="text-xs font-medium tracking-widest text-white-darker mb-2">
                                  Default State
                                </p>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                                  <Checkbox
                                    id="unlocked_edit"
                                    label="Unlocked by Default"
                                    checked={formData.unlocked !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange("unlocked", checked)
                                    }
                                  />
                                  <Checkbox
                                    id="discovered_edit"
                                    label="Already Discovered"
                                    checked={formData.discovered !== false}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "discovered",
                                        checked
                                      )
                                    }
                                  />
                                  <Checkbox
                                    id="no_collection_edit"
                                    label="Hidden from Collection"
                                    checked={formData.no_collection === true}
                                    onChange={(checked) =>
                                      handleCheckboxChange(
                                        "no_collection",
                                        checked
                                      )
                                    }
                                  />
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "description" && (
                <InfoDescriptionBox
                  value={formData.description}
                  onChange={(value, shouldAutoFormat) =>
                    handleInputChange("description", value, shouldAutoFormat)
                  }
                  onKeyDown={handleKeyDown}
                  item={formData}
                  itemType="seal"
                  textAreaId="seal-description-edit"
                  autoFormatEnabled={autoFormatEnabled}
                  onAutoFormatToggle={() => {
                    setUserConfig(prevConfig => ({
                      ...prevConfig,
                      defaultAutoFormat: !autoFormatEnabled
                    }))
                    setAutoFormatEnabled(!autoFormatEnabled)
                  }}
                  validationResult={validationResults.description}
                  placeholder="Describe your seal's effects using Balatro formatting..."
                  onInsertTag={insertTagSmart}
                />
              )}

              {activeTab === "colour" && (
                <div className="p-6 space-y-6">
                  <SwatchIcon className="absolute top-4 right-8 h-32 w-32 text-black-lighter/20 -rotate-12 pointer-events-none" />

                  <div className="space-y-6">
                    <div>
                      <h4 className="text-white-light font-medium text-base mb-4 flex items-center gap-2">
                        <SwatchIcon className="h-5 w-5 text-mint" />
                        Badge Appearance
                      </h4>
                      <div className="space-y-6 rounded-lg border border-black-lighter p-6 bg-black-darker/30">
                        <div>
                          <label className="block text-sm font-medium text-white-light mb-3">
                            Badge Color
                          </label>
                          <div className="flex items-center gap-4 mb-4">
                            <input
                              type="color"
                              value={formData.badge_colour || "#000000"}
                              onChange={(e) =>
                                handleInputChange(
                                  "badge_colour",
                                  e.target.value,
                                  false
                                )
                              }
                              className="w-16 h-16 rounded-lg border-2 border-black-lighter bg-black-dark cursor-pointer"
                            />
                            <InputField
                              value={formData.badge_colour || "#000000"}
                              onChange={(e) =>
                                handleInputChange(
                                  "badge_colour",
                                  e.target.value,
                                  false
                                )
                              }
                              placeholder="#000000"
                              size="md"
                              className="flex-1"
                            />
                          </div>

                          <div>
                            <label className="block text-sm font-medium text-white-darker mb-3">
                              Quick Colors
                            </label>
                            <div className="grid grid-cols-8 gap-2">
                              {predefinedColors.map((color) => (
                                <button
                                  key={color}
                                  onClick={() =>
                                    handleInputChange(
                                      "badge_colour",
                                      color,
                                      false
                                    )
                                  }
                                  className={`w-8 h-8 rounded border-2 transition-all hover:scale-110 ${
                                    formData.badge_colour === color
                                      ? "border-white-light shadow-lg"
                                      : "border-black-lighter hover:border-white-darker"
                                  }`}
                                  style={{ backgroundColor: color }}
                                  title={color}
                                />
                              ))}
                            </div>
                          </div>

                          <div className="mt-10">
                            <div className="flex items-center justify-center">
                              <div className="relative">
                                <div
                                  className="absolute inset-0 rounded-xl translate-y-1 opacity-60"
                                  style={{
                                    backgroundColor: formData.badge_colour
                                      ? `${formData.badge_colour}80`
                                      : "#000000",
                                  }}
                                />
                                <div
                                  className="rounded-xl text-center text-lg text-white py-2 px-4 relative font-bold"
                                  style={{
                                    backgroundColor:
                                      formData.badge_colour || "#000000",
                                  }}
                                >
                                  <span className="relative text-[#fff]">
                                    {formData.name || "Seal Name"}
                                  </span>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="flex gap-4 p-4">
            <Button variant="secondary" onClick={onClose} className="flex-1">
              Cancel
            </Button>
            <Button variant="primary" onClick={handleSave} className="flex-1">
              Save Changes
            </Button>
            <Button
              onClick={handleDelete}
              onTouchEnd={handleDelete}
              variant="danger"
              className="px-8"
            >
              Delete
            </Button>
          </div>
        </div>

        <div className="flex-shrink-0 relative my-auto pb-40">
          <div className="relative pl-24" style={{ zIndex: 1000 }}>
            <BalatroCard
              type="card"
              data={{
                id: formData.id,
                name: formData.name,
                description: formData.description,
                imagePreview: formData.imagePreview,
              }}
              size="lg"
              isSeal={true}
              sealBadgeColor={formData.badge_colour}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default EditSealInfo;

```

### src\components\pages\seals\SealCard.tsx

```
import React, { useState } from "react";
import {
  PencilIcon,
  PuzzlePieceIcon,
  DocumentDuplicateIcon,
  TrashIcon,
  LockOpenIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  ArrowDownTrayIcon,
  EyeSlashIcon as HiddenIcon,
} from "@heroicons/react/24/solid";

import Tooltip from "../../generic/Tooltip";
import { formatBalatroText } from "../../generic/balatroTextFormatter";
import { validateJokerName } from "../../generic/validationUtils";
import { SealData, slugify } from "../../data/BalatroUtils";

interface SealCardProps {
  seal: SealData;
  onEditInfo: () => void;
  onEditRules: () => void;
  onDelete: () => void;
  onDuplicate: () => void;
  onExport: () => void;
  onQuickUpdate: (updates: Partial<SealData>) => void;
  modPrefix: string;
  showConfirmation: (options: {
    type?: "default" | "warning" | "danger" | "success";
    title: string;
    description: string;
    confirmText?: string;
    cancelText?: string;
    confirmVariant?: "primary" | "secondary" | "danger";
    icon?: React.ReactNode;
    onConfirm: () => void;
    onCancel?: () => void;
  }) => void;
}

const PropertyIcon: React.FC<{
  icon: React.ReactNode;
  tooltip: string;
  variant: "disabled" | "warning" | "success" | "info" | "special";
  isEnabled: boolean;
  onClick: () => void;
}> = ({ icon, tooltip, variant, isEnabled, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const variantStyles = {
    disabled: isEnabled
      ? "bg-black-dark border-black-lighter text-white-darker"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    warning: isEnabled
      ? "bg-balatro-orange/20 border-balatro-orange/40 text-balatro-orange"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    success: isEnabled
      ? "bg-balatro-green/20 border-balatro-green/40 text-balatro-green"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    info: isEnabled
      ? "bg-balatro-blue/20 border-balatro-blue/40 text-balatro-blue"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
    special: isEnabled
      ? "bg-balatro-purple/20 border-balatro-purple/40 text-balatro-purple"
      : "bg-black-darker border-black-dark text-black-light opacity-50",
  };

  return (
    <Tooltip content={tooltip} show={isHovered}>
      <div
        className={`flex items-center justify-center w-7 h-7 rounded-lg border-2 transition-all duration-200 cursor-pointer ${variantStyles[variant]}`}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={onClick}
      >
        <div className="w-4 h-4">{icon}</div>
      </div>
    </Tooltip>
  );
};

const SealCard: React.FC<SealCardProps> = ({
  seal,
  onEditInfo,
  onEditRules,
  onDuplicate,
  onExport,
  onQuickUpdate,
  showConfirmation,
  onDelete,
}) => {
  const rulesCount = seal.rules?.length || 0;

  const [editingName, setEditingName] = useState(false);
  const [editingDescription, setEditingDescription] = useState(false);
  const [tempName, setTempName] = useState(seal.name);
  const [tempDescription, setTempDescription] = useState(seal.description);

  const [hoveredButton, setHoveredButton] = useState<string | null>(null);
  const [hoveredTrash, setHoveredTrash] = useState(false);
  const [tooltipDelayTimeout, setTooltipDelayTimeout] =
    useState<NodeJS.Timeout | null>(null);

  const [imageLoadError, setImageLoadError] = useState(false);
  const [fallbackAttempted, setFallbackAttempted] = useState(false);

  const [nameValidationError, setNameValidationError] = useState<string>("");

  const handleEditRules = () => {
    onEditRules();
  };

  const handleNameSave = () => {
    const validation = validateJokerName(tempName);

    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid name");
      return;
    }

    onQuickUpdate({ name: tempName, sealKey: slugify(tempName) });
    setEditingName(false);
    setNameValidationError("");
  };

  const handleDescriptionSave = () => {
    onQuickUpdate({ description: tempDescription });
    setEditingDescription(false);
  };

  const handleButtonHover = (buttonType: string) => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredButton(buttonType);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleButtonLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredButton(null);
  };

  const handleTrashHover = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
    }
    const timeout = setTimeout(() => {
      setHoveredTrash(true);
    }, 500);
    setTooltipDelayTimeout(timeout);
  };

  const handleTrashLeave = () => {
    if (tooltipDelayTimeout) {
      clearTimeout(tooltipDelayTimeout);
      setTooltipDelayTimeout(null);
    }
    setHoveredTrash(false);
  };

  const isUnlocked = seal.unlocked !== false;
  const isDiscovered = seal.discovered !== false;
  const noCollection = seal.no_collection === true;
  const propertyIcons = [
    {
      icon: isUnlocked ? (
        <LockOpenIcon className="w-full h-full" />
      ) : (
        <LockClosedIcon className="w-full h-full" />
      ),
      tooltip: isUnlocked ? "Unlocked by Default" : "Locked by Default",
      variant: "warning" as const,
      isEnabled: isUnlocked,
      onClick: () => onQuickUpdate({ unlocked: !isUnlocked }),
    },
    {
      icon: isDiscovered ? (
        <EyeIcon className="w-full h-full" />
      ) : (
        <EyeSlashIcon className="w-full h-full" />
      ),
      tooltip: isDiscovered ? "Visible in Collection" : "Hidden in Collection",
      variant: "info" as const,
      isEnabled: isDiscovered,
      onClick: () => onQuickUpdate({ discovered: !isDiscovered }),
    },
    {
      icon: <HiddenIcon className="w-full h-full" />,
      tooltip: noCollection ? "Hidden from Collection" : "Shows in Collection",
      variant: "disabled" as const,
      isEnabled: noCollection,
      onClick: () => onQuickUpdate({ no_collection: !noCollection }),
    },
  ];

  return (
    <div className="flex gap-4 relative">
      <div className="relative flex flex-col items-center">
        <div className="w-42 z-10 relative">
          <div className="relative">
            <div className="relative">
              {seal.imagePreview && !imageLoadError ? (
                <div className="relative w-full h-full">
                  {/* Base layer: back.png */}
                  <img
                    src="/images/back.png"
                    alt="Card back"
                    className="w-full h-full object-contain"
                    draggable="false"
                  />

                  {/* Middle layer: ace */}
                  <img
                    src="/images/aces/HC_A_hearts.png"
                    alt=""
                    className="absolute inset-0 w-full h-full object-contain pointer-events-none"
                    draggable="false"
                  />

                  {/* Top layer: seal image */}
                  <img
                    src={seal.imagePreview}
                    alt={seal.name}
                    className="absolute inset-0 w-full h-full object-contain"
                    draggable="false"
                    onError={() => setImageLoadError(true)}
                  />
                </div>
              ) : (
                <div className="relative w-full h-full">
                  {/* Base layer: back.png */}
                  <img
                    src="/images/back.png"
                    alt="Card back"
                    className="w-full h-full object-contain"
                    draggable="false"
                  />

                  {/* Middle layer: ace */}
                  <img
                    src="/images/aces/HC_A_clubs.png"
                    alt=""
                    className="absolute inset-0 w-full h-full object-contain pointer-events-none"
                    draggable="false"
                  />

                  {/* Top layer: placeholder */}
                  <img
                    src={
                      !fallbackAttempted
                        ? "/images/placeholderseals/placeholder-seal.png"
                        : "/images/placeholder-seal.png"
                    }
                    alt="Default Seal"
                    className="absolute inset-0 w-full h-full object-contain"
                    draggable="false"
                    onError={() => {
                      if (!fallbackAttempted) {
                        setFallbackAttempted(true);
                      }
                    }}
                  />
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="relative z-30">
          <div className="px-6 py-1 -mt-6 rounded-md bg-black-dark border-2 text-sm tracking-wide font-medium text-balatro-blue">
            Seal
          </div>
        </div>
      </div>

      <div className="my-auto border-l-2 pl-4 border-black-light relative flex-1 min-h-fit">
        <Tooltip content="Delete Seal" show={hoveredTrash}>
          <div
            className="absolute -top-3 -right-3 bg-black-dark border-2 border-balatro-red rounded-lg p-1 hover:bg-balatro-redshadow cursor-pointer transition-colors flex items-center justify-center z-10"
            onMouseEnter={handleTrashHover}
            onMouseLeave={handleTrashLeave}
          >
            <button
              onClick={(e) => {
                e.stopPropagation();
                showConfirmation({
                  type: "danger",
                  title: "Delete Seal",
                  description: `Are you sure you want to delete "${seal.name}"? This action cannot be undone.`,
                  confirmText: "Delete Forever",
                  cancelText: "Keep It",
                  confirmVariant: "danger",
                  onConfirm: () => onDelete(),
                });
              }}
              className="w-full h-full flex items-center cursor-pointer justify-center"
            >
              <TrashIcon className="h-5 w-5 text-balatro-red" />
            </button>
          </div>
        </Tooltip>

        <div className="flex flex-col h-full">
          <div className="flex-1">
            <div className="mb-3 h-7 flex items-start overflow-hidden">
              {editingName ? (
                <div className="w-full">
                  <input
                    type="text"
                    value={tempName}
                    onChange={(e) => {
                      setTempName(e.target.value);
                      if (nameValidationError) {
                        const validation = validateJokerName(e.target.value);
                        if (validation.isValid) {
                          setNameValidationError("");
                        }
                      }
                    }}
                    onBlur={() => {
                      if (!nameValidationError) {
                        handleNameSave();
                      }
                    }}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleNameSave();
                      }
                      if (e.key === "Escape") {
                        setTempName(seal.name);
                        setEditingName(false);
                        setNameValidationError("");
                      }
                    }}
                    className={`text-white-lighter text-xl tracking-wide leading-tight bg-transparent border-none outline-none w-full cursor-text ${
                      nameValidationError ? "border-b-2 border-balatro-red" : ""
                    }`}
                    autoFocus
                  />
                </div>
              ) : (
                <h3
                  className="text-white-lighter text-xl tracking-wide leading-tight cursor-pointer line-clamp-1"
                  onClick={() => {
                    setTempName(seal.name);
                    setEditingName(true);
                    setNameValidationError("");
                  }}
                  style={{ lineHeight: "1.75rem" }}
                >
                  {seal.name}
                </h3>
              )}
            </div>

            <div className=" mb-4 h-12 flex items-start overflow-hidden">
              {editingDescription ? (
                <textarea
                  value={tempDescription}
                  onChange={(e) => setTempDescription(e.target.value)}
                  onBlur={handleDescriptionSave}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && e.ctrlKey) handleDescriptionSave();
                    if (e.key === "Escape") {
                      setTempDescription(seal.description);
                      setEditingDescription(false);
                    }
                  }}
                  className="text-white-darker text-sm leading-relaxed bg-transparent border-none outline-none resize-none w-full cursor-text h-full"
                  autoFocus
                />
              ) : (
                <div
                  className="text-white-darker text-sm leading-relaxed cursor-pointer w-full line-clamp-3"
                  onClick={() => {
                    setTempDescription(seal.description);
                    setEditingDescription(true);
                  }}
                  dangerouslySetInnerHTML={{
                    __html: formatBalatroText(seal.description),
                  }}
                />
              )}
            </div>

            <div className="flex items-center justify-between mb-4 px-4 h-8 flex-wrap">
              {propertyIcons.map((iconConfig, index) => (
                <PropertyIcon
                  key={index}
                  icon={iconConfig.icon}
                  tooltip={iconConfig.tooltip}
                  variant={iconConfig.variant}
                  isEnabled={iconConfig.isEnabled}
                  onClick={iconConfig.onClick}
                />
              ))}
            </div>
          </div>

          <div className="flex items-center justify-between px-8 overflow-hidden">
            <Tooltip content="Edit Info" show={hoveredButton === "edit"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onEditInfo}
                onMouseEnter={() => handleButtonHover("edit")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center px-3 py-3">
                  <PencilIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>
            <Tooltip content="Edit Rules" show={hoveredButton === "rules"}>
              <div
                className="flex flex-1 hover:text-mint-light transition-colors cursor-pointer group"
                onClick={handleEditRules}
                onMouseEnter={() => handleButtonHover("rules")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <div className="relative">
                    <PuzzlePieceIcon className="h-6 w-6 group-hover:text-mint-lighter text-white transition-colors" />
                    {rulesCount > 0 && (
                      <div className="absolute -top-2 -right-2 bg-mint text-black text-xs font-bold rounded-full w-4 h-4 flex items-center justify-center shadow-sm">
                        {rulesCount}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Export Seal" show={hoveredButton === "export"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onExport}
                onMouseEnter={() => handleButtonHover("export")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <ArrowDownTrayIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
            <div className="w-px bg-black-lighter py-3"></div>

            <Tooltip content="Duplicate" show={hoveredButton === "duplicate"}>
              <div
                className="flex flex-1 transition-colors cursor-pointer group"
                onClick={onDuplicate}
                onMouseEnter={() => handleButtonHover("duplicate")}
                onMouseLeave={handleButtonLeave}
              >
                <div className="flex-1 flex items-center justify-center py-3 px-3">
                  <DocumentDuplicateIcon className="h-6 w-6 text-white group-hover:text-mint-lighter transition-colors" />
                </div>
              </div>
            </Tooltip>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SealCard;

```

### src\components\pages\SkeletonPage.tsx

```
import React from "react";

interface SkeletonPageProps {
  variant?: "grid" | "form" | "metadata";
  showFloatingDock?: boolean;
  showFilters?: boolean;
}

const SkeletonPage: React.FC<SkeletonPageProps> = ({
  variant = "grid",
  showFloatingDock = false,
  showFilters = false,
}) => {
  const renderGridSkeleton = () => (
    <div className="grid lg:grid-cols-2 md:grid-cols-1 gap-14">
      {Array.from({ length: 4 }).map((_, index) => (
        <div key={index} className="animate-pulse">
          <div className=" rounded-xl p-6">
            <div className="flex items-start gap-4 mb-4">
              <div className="w-24 h-32 bg-black-lighter rounded-lg"></div>
              <div className="flex-1 space-y-3">
                <div className="h-6 bg-black-lighter rounded w-3/4"></div>
                <div className="h-4 bg-black-lighter rounded w-1/2"></div>
                <div className="space-y-2">
                  <div className="h-3 bg-black-lighter rounded w-full"></div>
                  <div className="h-3 bg-black-lighter rounded w-5/6"></div>
                </div>
              </div>
            </div>
            <div className="flex justify-between pt-4 border-t border-black-lighter">
              <div className="h-8 bg-black-lighter rounded w-20"></div>
              <div className="h-8 bg-black-lighter rounded w-20"></div>
              <div className="h-8 bg-black-lighter rounded w-20"></div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );

  const renderFormSkeleton = () => (
    <div className="max-w-6xl mx-auto space-y-8">
      {Array.from({ length: 3 }).map((_, sectionIndex) => (
        <div key={sectionIndex} className="animate-pulse">
          <div className="flex items-center gap-2 mb-6">
            <div className="w-5 h-5 bg-black-lighter rounded"></div>
            <div className="h-6 bg-black-lighter rounded w-48"></div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {Array.from({ length: 4 }).map((_, fieldIndex) => (
              <div key={fieldIndex} className="space-y-2">
                <div className="h-4 bg-black-lighter rounded w-24"></div>
                <div className="h-12 bg-black-darker border-2 border-black-light rounded-lg"></div>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );

  const renderMetadataSkeleton = () => (
    <div className="max-w-6xl mx-auto space-y-8">
      <div className="animate-pulse">
        <div className="flex items-center gap-2 mb-6">
          <div className="w-5 h-5 bg-black-lighter rounded"></div>
          <div className="h-6 bg-black-lighter rounded w-48"></div>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {Array.from({ length: 6 }).map((_, index) => (
            <div key={index} className="space-y-2">
              <div className="h-4 bg-black-lighter rounded w-24"></div>
              <div className="h-12 bg-black-darker border-2 border-black-light rounded-lg"></div>
            </div>
          ))}
        </div>
      </div>

      <div className="border-t border-black-light pt-8 animate-pulse">
        <div className="flex items-center gap-2 mb-6">
          <div className="w-5 h-5 bg-black-lighter rounded"></div>
          <div className="h-6 bg-black-lighter rounded w-56"></div>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
          {Array.from({ length: 3 }).map((_, index) => (
            <div key={index} className="space-y-2">
              <div className="h-4 bg-black-lighter rounded w-24"></div>
              <div className="h-12 bg-black-darker border-2 border-black-light rounded-lg"></div>
            </div>
          ))}
        </div>
        <div className="p-4">
          <div className="flex justify-center">
            <div className="h-12 w-24 bg-black-lighter rounded border-2"></div>
          </div>
        </div>
      </div>

      <div className="border-t border-black-light pt-8">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          <div className="animate-pulse">
            <div className="flex items-center gap-2 mb-6">
              <div className="w-5 h-5 bg-black-lighter rounded"></div>
              <div className="h-6 bg-black-lighter rounded w-48"></div>
            </div>
            <div className="space-y-6">
              {Array.from({ length: 2 }).map((_, index) => (
                <div key={index} className="space-y-2">
                  <div className="h-4 bg-black-lighter rounded w-24"></div>
                  <div className="h-12 bg-black-darker border-2 border-black-light rounded-lg"></div>
                </div>
              ))}
            </div>
          </div>
          <div className="border border-black-lighter rounded-lg p-4 animate-pulse">
            <div className="h-4 bg-black-lighter rounded w-32 mb-3"></div>
            <div className="space-y-2">
              {Array.from({ length: 4 }).map((_, index) => (
                <div key={index} className="flex justify-between">
                  <div className="h-3 bg-black-lighter rounded w-16"></div>
                  <div className="h-3 bg-black-lighter rounded w-20"></div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>

      <div className="border-t border-black-light pt-8 animate-pulse">
        <div className="flex items-center gap-2 mb-6">
          <div className="w-5 h-5 bg-black-lighter rounded"></div>
          <div className="h-6 bg-black-lighter rounded w-64"></div>
        </div>
        <div className="space-y-6">
          {Array.from({ length: 3 }).map((_, index) => (
            <div key={index} className="space-y-2">
              <div className="h-4 bg-black-lighter rounded w-32"></div>
              <div className="h-20 bg-black-darker border-2 border-black-light rounded-lg"></div>
            </div>
          ))}
        </div>
      </div>

      <div className="border-t border-black-light pt-8 animate-pulse">
        <div className="border border-black-lighter rounded-lg p-4">
          <div className="h-4 bg-black-lighter rounded w-32 mb-3"></div>
          <div className="bg-black border border-black-light rounded p-3 h-60">
            <div className="space-y-2">
              {Array.from({ length: 15 }).map((_, index) => (
                <div
                  key={index}
                  className="h-3 bg-black-lighter rounded w-full"
                ></div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );

  return (
    <div className={`min-h-screen ${showFloatingDock ? "pb-24" : ""}`}>
      <div className="p-8 font-lexend max-w-7xl mx-auto">
        {/* Header Section */}
        <div className="animate-pulse mb-8">
          <div className="h-9 bg-black-lighter rounded w-64 mx-auto mb-2"></div>
          <div className="h-6 bg-black-lighter rounded w-48 mx-auto mb-6"></div>
        </div>

        {variant !== "metadata" && (
          <>
            {/* Add Button Section */}
            <div className="flex justify-center mb-2 animate-pulse">
              <div className="h-12 bg-black-lighter rounded-lg w-48"></div>
            </div>

            {/* Stats Section */}
            <div className="flex items-center mb-2 animate-pulse">
              <div className="flex items-center gap-6">
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-black-lighter rounded"></div>
                  <div className="h-4 bg-black-lighter rounded w-32"></div>
                </div>
              </div>
            </div>

            {/* Search and Filters Section */}
            <div className="mb-8 animate-pulse">
              <div className="flex flex-col lg:flex-row gap-4">
                <div className="flex-1 relative">
                  <div className="w-full h-14 bg-black-darker border-2 border-black-lighter rounded-lg"></div>
                </div>
                <div className="flex gap-3">
                  <div className="h-14 w-32 bg-black-dark border-2 border-black-lighter rounded-lg"></div>
                  {showFilters && (
                    <div className="h-14 w-28 bg-black-dark border-2 border-black-lighter rounded-lg"></div>
                  )}
                </div>
              </div>
            </div>
          </>
        )}

        {/* Content Section */}
        {variant === "grid" && renderGridSkeleton()}
        {variant === "form" && renderFormSkeleton()}
        {variant === "metadata" && renderMetadataSkeleton()}
      </div>

      {/* Floating Dock Skeleton */}
      {showFloatingDock && (
        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-40 animate-pulse">
          <div className="bg-black-dark border-2 border-black-lighter rounded-full px-3 py-2 shadow-2xl">
            <div className="flex items-center gap-2">
              {Array.from({ length: 2 }).map((_, index) => (
                <div
                  key={index}
                  className="w-11 h-11 bg-black-darker border-2 border-black-lighter rounded-full"
                ></div>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SkeletonPage;

```

### src\components\ruleBuilder\BlockComponent.tsx

```
import React, { useState, useRef, useEffect } from "react";
import { motion } from "framer-motion";
import {
  ExclamationTriangleIcon,
} from "@heroicons/react/24/outline";
import {
  BoltIcon,
  PuzzlePieceIcon,
  BeakerIcon,
  PercentBadgeIcon,
  TrashIcon,
} from "@heroicons/react/16/solid";

interface BlockComponentProps {
  label: string;
  type: "trigger" | "condition" | "effect";
  onClick: (e?: React.MouseEvent) => void;
  isSelected?: boolean;
  showTrash?: boolean;
  onDelete?: () => void;
  parameterCount?: number;
  isNegated?: boolean;
  dynamicTitle?: string;
  variableName?: string;
  hasRandomChance?: boolean;
  isDraggable?: boolean;
  dragHandleProps?: Record<string, unknown>;
  variant?: "default" | "palette" | "condition";
}

const BlockComponent: React.FC<BlockComponentProps> = ({
  label,
  type,
  onClick,
  isSelected = false,
  showTrash = false,
  onDelete,
  parameterCount,
  isNegated = false,
  dynamicTitle,
  variableName,
  hasRandomChance = false,
  isDraggable = false,
  dragHandleProps,
  variant = "default",
}) => {
  const getTypeConfig = () => {
    switch (type) {
      case "trigger":
        return {
          borderColor: "border-l-trigger",
          backgroundColor: "bg-black",
          icon: <BoltIcon className="h-6 w-6 text-trigger -mt-4 -ml-1" />,
          typeLabel: "Trigger",
          selectColor: "border-trigger",
          hoverColor: "hover:border-trigger-dark",
        };
      case "condition":
        return {
          borderColor: "border-l-condition",
          backgroundColor: "bg-black",
          icon: <BeakerIcon className="h-6 w-6 text-condition -mt-4 -ml-1" />,
          typeLabel: "Condition",
          selectColor: "border-condition",
          hoverColor: "hover:border-condition-dark",
        };
      case "effect":
        return {
          borderColor: "border-l-effect",
          backgroundColor: "bg-black",
          icon: <PuzzlePieceIcon className="h-6 w-6 text-effect -mt-4 -ml-1" />,
          typeLabel: "Effect",
          selectColor: "border-effect",
          hoverColor: "hover:border-effect-dark",
        };
    }
  };

  const getVariantStyles = () => {
    switch (variant) {
      case "palette":
        return "w-full";
      case "condition":
        return "w-62";
      case "default":
      default:
        return "w-71";
    }
  };

  const config = getTypeConfig();
  const displayTitle = dynamicTitle || label;

  const [hasOverflow, setHasOverflow] = useState(false);
  const textRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const CheckOverflow = () => {
      if (textRef.current && containerRef.current) {
        const overflowAmount =
          textRef.current.scrollWidth - containerRef.current.clientWidth;
        setHasOverflow(overflowAmount > 10);
      } else {
        setHasOverflow(false);
      }
    };

    const timer = setTimeout(CheckOverflow, 100);
    window.addEventListener("resize", CheckOverflow);

    return () => {
      clearTimeout(timer);
      window.removeEventListener("resize", CheckOverflow);
    };
  }, [displayTitle, variant]);

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    onClick(e);
  };

  return (
    <div
      className={`
        relative ${config.backgroundColor} ${
        config.borderColor
      } border-l-4 border-2 
        ${isSelected ? config.selectColor : "border-black-light"} 
        rounded-lg cursor-pointer transition-all ${config.hoverColor} p-3 pt-6
        ${getVariantStyles()}
        ${
          isDraggable
            ? "cursor-grab active:cursor-grabbing hover:shadow-lg"
            : ""
        }
      `}
      onClick={handleClick}
      style={{ pointerEvents: "auto" }}
      {...(isDraggable ? dragHandleProps : {})}
    >
      <div className="absolute top-2 left-11 text-white-darker text-xs font-medium tracking-wider">
        {config.typeLabel}
      </div>

      <div className="absolute top-[2px] right-6 flex items-center gap-2">
        {variableName && (
          <span className="bg-mint/20 text-mint text-xs px-2 py-1 rounded font-medium">
            ${variableName}
          </span>
        )}
        {parameterCount !== undefined && parameterCount > 0 && (
          <span className="text-white-darker text-xs font-medium">
            {parameterCount} Parameter{parameterCount !== 1 ? "s" : ""}
          </span>
        )}
      </div>

      {showTrash && onDelete && (
        <div className="absolute -top-3 -right-3 w-8 h-8 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-redshadow">
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            className="w-full h-full flex items-center rounded justify-center transition-colors hover:bg-balatro-redshadow/50 active:bg-balatro-blackshadow cursor-pointer"
          >
            <TrashIcon className="h-5 w-5 text-balatro-red transition-colors" />
          </button>
        </div>
      )}

      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3 flex-grow min-w-0">
          <div className="flex items-center gap-2">
            <div className="flex-shrink-0">{config.icon}</div>
            {isNegated && (
              <div className="flex-shrink-0 -mr-2">
                <ExclamationTriangleIcon className="h-4 w-4 text-balatro-red" />
              </div>
            )}
            {hasRandomChance && (
              <div className="flex-shrink-0 -mr-2">
                <PercentBadgeIcon className="h-4 w-4 text-mint" />
              </div>
            )}
          </div>
          <div ref={containerRef} className="flex-grow min-w-0 overflow-hidden">
            <motion.div
              ref={textRef}
              className="text-white text-sm tracking-wide whitespace-nowrap"
              animate={{
                x:
                  hasOverflow && textRef.current && containerRef.current
                    ? [
                        0,
                        -(
                          textRef.current.scrollWidth -
                          containerRef.current.clientWidth
                        ),
                      ]
                    : 0,
              }}
              transition={
                hasOverflow
                  ? {
                      x: {
                        repeat: Infinity,
                        repeatType: "mirror",
                        duration: (textRef.current?.scrollWidth || 0) / 75,
                        ease: "linear",
                        delay: 1.5,
                        repeatDelay: 1.5,
                      },
                    }
                  : { duration: 0 }
              }
            >
              {isNegated ? `NOT ${displayTitle}` : displayTitle}
            </motion.div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BlockComponent;

```

### src\components\ruleBuilder\BlockPalette.tsx

```
import React, { useState, useMemo, useEffect } from "react";
import { useDraggable } from "@dnd-kit/core";
import { motion, AnimatePresence } from "framer-motion";
import type {
  Rule,
  TriggerDefinition,
  ConditionTypeDefinition,
  EffectTypeDefinition,
} from "./types";
import BlockComponent from "./BlockComponent";
import {
  SwatchIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  MagnifyingGlassIcon,
  XMarkIcon,
  Bars3Icon,
  SparklesIcon,
} from "@heroicons/react/24/outline";
import {
  BoltIcon,
  PuzzlePieceIcon,
  BeakerIcon,
} from "@heroicons/react/16/solid";

import {
  TRIGGERS,
  TRIGGER_CATEGORIES,
  type CategoryDefinition,
} from "../data/Jokers/Triggers";
import {
  getConditionsForTrigger,
  CONDITION_CATEGORIES,
} from "../data/Jokers/Conditions";
import {
  getEffectsForTrigger,
  EFFECT_CATEGORIES,
} from "../data/Jokers/Effects";

import {
  CONSUMABLE_TRIGGERS,
  CONSUMABLE_TRIGGER_CATEGORIES,
} from "../data/Consumables/Triggers";
import {
  getConsumableConditionsForTrigger,
  CONSUMABLE_CONDITION_CATEGORIES,
} from "../data/Consumables/Conditions";
import {
  getConsumableEffectsForTrigger,
  CONSUMABLE_EFFECT_CATEGORIES,
} from "../data/Consumables/Effects";
import { CARD_TRIGGERS, CARD_TRIGGER_CATEGORIES } from "../data/Card/Triggers";
import {
  CARD_CONDITION_CATEGORIES,
  getCardConditionsForTrigger,
} from "../data/Card/Conditions";
import {
  CARD_EFFECT_CATEGORIES,
  getCardEffectsForTrigger,
} from "../data/Card/Effects";

interface BlockPaletteProps {
  position: { x: number; y: number };
  selectedRule: Rule | null;
  onAddTrigger: (triggerId: string) => void;
  onAddCondition: (conditionType: string) => void;
  onAddEffect: (effectType: string) => void;
  onClose: () => void;
  onPositionChange: (position: { x: number; y: number }) => void;
  itemType: "joker" | "consumable" | "card";
}

type FilterType = "triggers" | "conditions" | "effects";

const BlockPalette: React.FC<BlockPaletteProps> = ({
  position,
  selectedRule,
  onAddTrigger,
  onAddCondition,
  onAddEffect,
  onClose,
  itemType,
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set()
  );
  const [activeFilter, setActiveFilter] = useState<FilterType>(
    selectedRule ? "conditions" : "triggers"
  );
  const [previousSelectedRule, setPreviousSelectedRule] = useState<Rule | null>(
    selectedRule
  );

  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "panel-blockPalette",
  });

  const triggers =
    itemType === "joker"
      ? TRIGGERS
      : itemType === "consumable"
      ? CONSUMABLE_TRIGGERS
      : CARD_TRIGGERS;

  const triggerCategories =
    itemType === "joker"
      ? TRIGGER_CATEGORIES
      : itemType === "consumable"
      ? CONSUMABLE_TRIGGER_CATEGORIES
      : CARD_TRIGGER_CATEGORIES;

  const conditionCategories =
    itemType === "joker"
      ? CONDITION_CATEGORIES
      : itemType === "consumable"
      ? CONSUMABLE_CONDITION_CATEGORIES
      : CARD_CONDITION_CATEGORIES;

  const effectCategories =
    itemType === "joker"
      ? EFFECT_CATEGORIES
      : itemType === "consumable"
      ? CONSUMABLE_EFFECT_CATEGORIES
      : CARD_EFFECT_CATEGORIES;

  const getConditionsForTriggerFn =
    itemType === "joker"
      ? getConditionsForTrigger
      : itemType === "consumable"
      ? getConsumableConditionsForTrigger
      : getCardConditionsForTrigger;

  const getEffectsForTriggerFn =
    itemType === "joker"
      ? getEffectsForTrigger
      : itemType === "consumable"
      ? getConsumableEffectsForTrigger
      : getCardEffectsForTrigger;

  const style = transform
    ? {
        position: "absolute" as const,
        left: position.x + transform.x,
        top: position.y + transform.y,
      }
    : {
        position: "absolute" as const,
        left: position.x,
        top: position.y,
      };

  useEffect(() => {
    const ruleChanged = selectedRule !== previousSelectedRule;
    const hasRuleNow = !!selectedRule;

    if (ruleChanged && hasRuleNow && activeFilter === "triggers") {
      setActiveFilter("conditions");
    }

    setPreviousSelectedRule(selectedRule);
  }, [selectedRule, previousSelectedRule, activeFilter]);

  useEffect(() => {
    setExpandedCategories(new Set());
  }, [activeFilter]);

  const availableConditions = useMemo(() => {
    return selectedRule ? getConditionsForTriggerFn(selectedRule.trigger) : [];
  }, [selectedRule, getConditionsForTriggerFn]);

  const availableEffects = useMemo(() => {
    return selectedRule ? getEffectsForTriggerFn(selectedRule.trigger) : [];
  }, [selectedRule, getEffectsForTriggerFn]);

  const categorizedItems = useMemo(() => {
    const normalizedSearch = searchTerm.toLowerCase();

    const filteredTriggers = triggers.filter(
      (trigger) =>
        trigger.label.toLowerCase().includes(normalizedSearch) ||
        trigger.description.toLowerCase().includes(normalizedSearch)
    );

    const triggersByCategory: Record<
      string,
      { category: CategoryDefinition; items: TriggerDefinition[] }
    > = {};

    triggerCategories.forEach((category) => {
      triggersByCategory[category.label] = {
        category,
        items: [],
      };
    });

    const uncategorizedCategory: CategoryDefinition = {
      label: "Other",
      icon: SparklesIcon,
    };
    triggersByCategory["Other"] = {
      category: uncategorizedCategory,
      items: [],
    };

    filteredTriggers.forEach((trigger) => {
      const categoryLabel = trigger.category || "Other";
      if (triggersByCategory[categoryLabel]) {
        triggersByCategory[categoryLabel].items.push(trigger);
      } else {
        triggersByCategory["Other"].items.push(trigger);
      }
    });

    Object.keys(triggersByCategory).forEach((categoryLabel) => {
      if (triggersByCategory[categoryLabel].items.length === 0) {
        delete triggersByCategory[categoryLabel];
      }
    });

    const filteredConditions = availableConditions.filter(
      (condition) =>
        condition.label.toLowerCase().includes(normalizedSearch) ||
        condition.description.toLowerCase().includes(normalizedSearch)
    );

    const conditionsByCategory: Record<
      string,
      { category: CategoryDefinition; items: ConditionTypeDefinition[] }
    > = {};

    conditionCategories.forEach((category) => {
      conditionsByCategory[category.label] = {
        category,
        items: [],
      };
    });

    conditionsByCategory["Other"] = {
      category: uncategorizedCategory,
      items: [],
    };

    filteredConditions.forEach((condition) => {
      const categoryLabel = condition.category || "Other";
      if (conditionsByCategory[categoryLabel]) {
        conditionsByCategory[categoryLabel].items.push(condition);
      } else {
        conditionsByCategory["Other"].items.push(condition);
      }
    });

    Object.keys(conditionsByCategory).forEach((categoryLabel) => {
      if (conditionsByCategory[categoryLabel].items.length === 0) {
        delete conditionsByCategory[categoryLabel];
      }
    });

    const filteredEffects = availableEffects.filter(
      (effect) =>
        effect.label.toLowerCase().includes(normalizedSearch) ||
        effect.description.toLowerCase().includes(normalizedSearch)
    );

    const effectsByCategory: Record<
      string,
      { category: CategoryDefinition; items: EffectTypeDefinition[] }
    > = {};

    effectCategories.forEach((category) => {
      effectsByCategory[category.label] = {
        category,
        items: [],
      };
    });

    effectsByCategory["Other"] = {
      category: uncategorizedCategory,
      items: [],
    };

    filteredEffects.forEach((effect) => {
      const categoryLabel = effect.category || "Other";
      if (effectsByCategory[categoryLabel]) {
        effectsByCategory[categoryLabel].items.push(effect);
      } else {
        effectsByCategory["Other"].items.push(effect);
      }
    });

    Object.keys(effectsByCategory).forEach((categoryLabel) => {
      if (effectsByCategory[categoryLabel].items.length === 0) {
        delete effectsByCategory[categoryLabel];
      }
    });

    return {
      triggers: triggersByCategory,
      conditions: conditionsByCategory,
      effects: effectsByCategory,
    };
  }, [
    searchTerm,
    availableConditions,
    availableEffects,
    triggers,
    triggerCategories,
    conditionCategories,
    effectCategories,
  ]);

  const shouldShowSection = (sectionType: FilterType) => {
    if (!selectedRule && sectionType !== "triggers") {
      return false;
    }

    return activeFilter === sectionType;
  };

  const toggleCategory = (categoryLabel: string) => {
    setExpandedCategories((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(categoryLabel)) {
        newSet.delete(categoryLabel);
      } else {
        newSet.add(categoryLabel);
      }
      return newSet;
    });
  };

  const handleFilterToggle = (filterType: FilterType) => {
    setActiveFilter(filterType);
  };

  const renderCategory = (
    categoryData: {
      category: CategoryDefinition;
      items:
        | TriggerDefinition[]
        | ConditionTypeDefinition[]
        | EffectTypeDefinition[];
    },
    type: "trigger" | "condition" | "effect",
    onAdd: (id: string) => void
  ) => {
    const { category, items } = categoryData;
    const isExpanded = expandedCategories.has(category.label);
    const IconComponent = category.icon;

    return (
      <div key={category.label} className="mb-3">
        <button
          onClick={() => toggleCategory(category.label)}
          className="w-full flex items-center justify-between p-2 hover:bg-black-light rounded-md transition-colors"
        >
          <div className="flex items-center gap-2">
            <IconComponent className="h-4 w-4 text-mint-light" />
            <span className="text-white-light text-xs font-medium tracking-wider uppercase">
              {category.label}
            </span>
            <span className="text-white-darker text-xs">({items.length})</span>
          </div>
          {isExpanded ? (
            <ChevronDownIcon className="h-3 w-3 text-white-darker" />
          ) : (
            <ChevronRightIcon className="h-3 w-3 text-white-darker" />
          )}
        </button>

        <AnimatePresence>
          {isExpanded && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: "auto", opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="mt-2 space-y-2 ml-1 mr-1">
                {items.map((item, index) => (
                  <motion.div
                    key={`${activeFilter}-${item.id}`}
                    initial={{ x: -20, opacity: 0 }}
                    animate={{ x: 0, opacity: 1 }}
                    transition={{
                      delay: index * 0.03,
                      duration: 0.15,
                      ease: "easeOut",
                    }}
                    className="px-2"
                  >
                    <BlockComponent
                      label={item.label}
                      type={type}
                      onClick={() => onAdd(item.id)}
                      variant="palette"
                    />
                  </motion.div>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    );
  };

  const renderSection = (
    categorizedData: Record<
      string,
      {
        category: CategoryDefinition;
        items:
          | TriggerDefinition[]
          | ConditionTypeDefinition[]
          | EffectTypeDefinition[];
      }
    >,
    type: "trigger" | "condition" | "effect",
    onAdd: (id: string) => void,
    sectionKey: FilterType
  ) => {
    if (!shouldShowSection(sectionKey)) return null;

    const totalItems = Object.values(categorizedData).reduce(
      (sum, { items }) => sum + items.length,
      0
    );

    if (totalItems === 0 && searchTerm) return null;

    return (
      <AnimatePresence mode="wait">
        <motion.div
          key={activeFilter}
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          transition={{ duration: 0.2 }}
          className="space-y-3"
        >
          {Object.values(categorizedData).map((categoryData) =>
            renderCategory(categoryData, type, onAdd)
          )}
        </motion.div>
      </AnimatePresence>
    );
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="w-80 bg-black-dark backdrop-blur-md border-2 border-black-lighter rounded-lg shadow-2xl z-40"
    >
      <div
        className="flex items-center justify-between p-3 border-b border-black-lighter cursor-grab active:cursor-grabbing"
        {...attributes}
        {...listeners}
      >
        <div className="flex items-center gap-2">
          <Bars3Icon className="h-4 w-4 text-white-darker" />
          <SwatchIcon className="h-5 w-5 text-white-light" />
          <h3 className="text-white-light text-sm font-medium tracking-wider">
            Block Palette ({itemType})
          </h3>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-white-darker hover:text-white transition-colors cursor-pointer"
        >
          <XMarkIcon className="h-4 w-4" />
        </button>
      </div>

      <div className="p-3">
        <div className="w-1/4 h-[1px] bg-black-lighter mx-auto mb-4"></div>

        <div className="flex justify-center gap-2 mb-4">
          <button
            onClick={() => handleFilterToggle("triggers")}
            className={`p-2 rounded-md transition-colors cursor-pointer border ${
              activeFilter === "triggers"
                ? "bg-trigger text-black border-trigger"
                : "bg-black-darker text-trigger border-trigger hover:bg-trigger hover:text-black"
            }`}
            title="Filter Triggers"
          >
            <BoltIcon className="h-4 w-4" />
          </button>
          <button
            onClick={() => handleFilterToggle("conditions")}
            disabled={!selectedRule}
            className={`p-2 rounded-md transition-colors cursor-pointer border ${
              !selectedRule
                ? "bg-black-darker text-white-darker border-black-lighter cursor-not-allowed opacity-50"
                : activeFilter === "conditions"
                ? "bg-condition text-white border-condition"
                : "bg-black-darker text-condition border-condition hover:bg-condition hover:text-white"
            }`}
            title="Filter Conditions"
          >
            <BeakerIcon className="h-4 w-4" />
          </button>
          <button
            onClick={() => handleFilterToggle("effects")}
            disabled={!selectedRule}
            className={`p-2 rounded-md transition-colors cursor-pointer border ${
              !selectedRule
                ? "bg-black-darker text-white-darker border-black-lighter cursor-not-allowed opacity-50"
                : activeFilter === "effects"
                ? "bg-effect text-black border-effect"
                : "bg-black-darker text-effect border-effect hover:bg-effect hover:text-black"
            }`}
            title="Filter Effects"
          >
            <PuzzlePieceIcon className="h-4 w-4" />
          </button>
        </div>

        <div className="relative mb-4">
          <div className="relative">
            <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-mint stroke-2" />
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search blocks..."
              className="w-full bg-black-darker border border-black-lighter rounded-lg pl-10 pr-4 py-2 text-white text-sm placeholder-white-darker focus:outline-none focus:border-mint transition-colors"
            />
          </div>
        </div>

        <div className="h-[calc(100vh-18rem)] overflow-y-auto custom-scrollbar">
          {renderSection(
            categorizedItems.triggers,
            "trigger",
            onAddTrigger,
            "triggers"
          )}

          {renderSection(
            categorizedItems.conditions,
            "condition",
            onAddCondition,
            "conditions"
          )}

          {renderSection(
            categorizedItems.effects,
            "effect",
            onAddEffect,
            "effects"
          )}
        </div>
      </div>
    </div>
  );
};

export default BlockPalette;

```

### src\components\ruleBuilder\FloatingDock.tsx

```
import React from "react";
import {
  SwatchIcon,
  CommandLineIcon,
  ChartPieIcon,
  CubeIcon,
} from "@heroicons/react/24/outline";

interface PanelState {
  id: string;
  isVisible: boolean;
  position: { x: number; y: number };
  size: { width: number; height: number };
}

interface FloatingDockProps {
  panels: Record<string, PanelState>;
  onTogglePanel: (panelId: string) => void;
  itemType: "joker" | "consumable" | "card";
}

const FloatingDock: React.FC<FloatingDockProps> = ({
  panels,
  onTogglePanel,
  itemType,
}) => {
  const allDockItems = [
    {
      id: "blockPalette",
      icon: SwatchIcon,
      label: "Block Palette",
      shortcut: "B",
    },
    {
      id: "variables",
      icon: CommandLineIcon,
      label: "Variables",
      shortcut: "V",
    },
    {
      id: "gameVariables",
      icon: CubeIcon,
      label: "Game Variables",
      shortcut: "G",
    },
    {
      id: "inspector",
      icon: ChartPieIcon,
      label: "Inspector",
      shortcut: "P",
    },
  ];

  const dockItems = allDockItems.filter((item) => {
    if (item.id === "variables" && itemType === "consumable") {
      return false;
    }
    return true;
  });

  return (
    <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 z-50">
      <div className="bg-black-dark/90 backdrop-blur-md border-2 border-black-lighter rounded-full px-3 py-2 shadow-2xl">
        <div className="flex items-center gap-2">
          {dockItems.map((item) => {
            const Icon = item.icon;
            const isActive = panels[item.id]?.isVisible;

            return (
              <button
                key={item.id}
                onClick={() => onTogglePanel(item.id)}
                className={`
                  relative group p-3 rounded-full transition-all duration-200 cursor-pointer
                  ${
                    isActive
                      ? "bg-mint/20 border-2 border-mint text-mint scale-110"
                      : "bg-black-darker/50 border-2 border-black-lighter text-white-darker hover:border-mint hover:text-mint hover:scale-105"
                  }
                `}
                title={`${item.label} (${item.shortcut})`}
              >
                <Icon className="h-5 w-5" />

                <div className="absolute -top-12 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none">
                  <div className="bg-black-darker border border-black-lighter rounded-lg px-2 py-1 whitespace-nowrap">
                    <span className="text-white-light text-xs font-medium">
                      {item.label}
                    </span>
                    <div className="text-white-darker text-xs">
                      Press {item.shortcut}
                    </div>
                  </div>
                  <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black-lighter"></div>
                </div>

                {isActive && (
                  <div className="absolute -top-1 -right-1 w-3 h-3 bg-mint rounded-full border-2 border-black-dark"></div>
                )}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
};

export default FloatingDock;

```

### src\components\ruleBuilder\GameVariables.tsx

```
import React, { useState, useMemo } from "react";
import { useDraggable } from "@dnd-kit/core";
import {
  GAME_VARIABLE_CATEGORIES,
  GameVariable,
  GameVariableCategory,
  GameVariableSubcategory,
} from "../data/Jokers/GameVars";
import {
  XMarkIcon,
  Bars3Icon,
  MagnifyingGlassIcon,
  ChevronRightIcon,
  ChevronDownIcon,
} from "@heroicons/react/24/outline";

interface GameVariablesProps {
  position: { x: number; y: number };
  selectedGameVariable: GameVariable | null;
  onSelectGameVariable: (variable: GameVariable) => void;
  onClose: () => void;
  onPositionChange: (position: { x: number; y: number }) => void;
}

const GameVariables: React.FC<GameVariablesProps> = ({
  position,
  onSelectGameVariable,
  onClose,
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set()
  );
  const [expandedSubcategories, setExpandedSubcategories] = useState<
    Set<string>
  >(new Set());

  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "panel-gameVariables",
  });

  const style = transform
    ? {
        position: "absolute" as const,
        left: position.x + transform.x,
        top: position.y + transform.y,
      }
    : {
        position: "absolute" as const,
        left: position.x,
        top: position.y,
      };

  const filteredCategories = useMemo(() => {
    if (!searchTerm.trim()) {
      return GAME_VARIABLE_CATEGORIES;
    }

    const search = searchTerm.toLowerCase();
    return GAME_VARIABLE_CATEGORIES.map((category) => {
      const matchingVariables = category.variables.filter(
        (variable) =>
          variable.label.toLowerCase().includes(search) ||
          variable.description.toLowerCase().includes(search) ||
          variable.id.toLowerCase().includes(search)
      );

      const matchingSubcategories =
        category.subcategories
          ?.map((subcategory) => ({
            ...subcategory,
            variables: subcategory.variables.filter(
              (variable) =>
                variable.label.toLowerCase().includes(search) ||
                variable.description.toLowerCase().includes(search) ||
                variable.id.toLowerCase().includes(search)
            ),
          }))
          .filter((subcategory) => subcategory.variables.length > 0) || [];

      const categoryMatches = category.label.toLowerCase().includes(search);

      if (
        categoryMatches ||
        matchingVariables.length > 0 ||
        matchingSubcategories.length > 0
      ) {
        return {
          ...category,
          variables: categoryMatches ? category.variables : matchingVariables,
          subcategories: categoryMatches
            ? category.subcategories
            : matchingSubcategories,
        };
      }

      return null;
    }).filter(Boolean) as GameVariableCategory[];
  }, [searchTerm]);

  const toggleCategory = (categoryId: string) => {
    setExpandedCategories((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  };

  const toggleSubcategory = (subcategoryId: string) => {
    setExpandedSubcategories((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(subcategoryId)) {
        newSet.delete(subcategoryId);
      } else {
        newSet.add(subcategoryId);
      }
      return newSet;
    });
  };

  const handleVariableSelect = (variable: GameVariable) => {
    onSelectGameVariable(variable);
  };

  const renderVariable = (
    variable: GameVariable,
    isNested: boolean = false
  ) => (
    <div
      key={variable.id}
      className={`p-2.5 rounded-lg border border-black-lighter bg-black-darker cursor-pointer transition-all hover:bg-black-dark hover:border-mint/50 active:bg-mint/10 ${
        isNested ? "ml-4 mr-2" : ""
      }`}
      onClick={() => handleVariableSelect(variable)}
    >
      <div className="flex items-center justify-between mb-1.5">
        <h4 className="text-white-light text-sm font-medium">
          {variable.label}
        </h4>
        <span className="text-xs px-1.5 py-0.5 bg-black-light text-white-dark rounded uppercase tracking-wider">
          {variable.category}
        </span>
      </div>

      <p className="text-white-darker text-xs leading-relaxed mb-2">
        {variable.description}
      </p>

      <div className="bg-black/40 rounded px-2 py-1">
        <code className="text-mint-lighter text-xs font-mono">
          ${variable.id}
        </code>
      </div>
    </div>
  );

  const renderSubcategory = (
    category: GameVariableCategory,
    subcategory: GameVariableSubcategory
  ) => {
    const subcategoryKey = `${category.id}-${subcategory.id}`;
    const isExpanded = expandedSubcategories.has(subcategoryKey);
    const hasVariables = subcategory.variables.length > 0;

    return (
      <div key={subcategoryKey} className="ml-6">
        <div
          className="flex items-center gap-2 p-2 rounded-lg cursor-pointer hover:bg-black-dark/50 transition-colors"
          onClick={() => hasVariables && toggleSubcategory(subcategoryKey)}
        >
          {hasVariables && (
            <>
              {isExpanded ? (
                <ChevronDownIcon className="h-4 w-4 text-white-darker" />
              ) : (
                <ChevronRightIcon className="h-4 w-4 text-white-darker" />
              )}
            </>
          )}
          <h4 className="text-white-light text-sm tracking-wide">
            {subcategory.label}
          </h4>
          <span className="text-xs text-white-darker">
            ({subcategory.variables.length})
          </span>
        </div>

        {isExpanded && (
          <div className="space-y-1.5 mt-2">
            {subcategory.variables.map((variable) =>
              renderVariable(variable, true)
            )}
          </div>
        )}
      </div>
    );
  };

  const renderCategory = (category: GameVariableCategory) => {
    const isExpanded = expandedCategories.has(category.id);
    const hasContent =
      category.variables.length > 0 ||
      (category.subcategories && category.subcategories.length > 0);
    const IconComponent = category.icon;

    return (
      <div
        key={category.id}
        className="border-b border-black-lighter/30 last:border-b-0"
      >
        <div
          className="flex items-center gap-3 p-3 cursor-pointer hover:bg-black-dark/50 transition-colors"
          onClick={() => hasContent && toggleCategory(category.id)}
        >
          {hasContent && (
            <>
              {isExpanded ? (
                <ChevronDownIcon className="h-4 w-4 text-white-darker" />
              ) : (
                <ChevronRightIcon className="h-4 w-4 text-white-darker" />
              )}
            </>
          )}
          <IconComponent className="h-5 w-5 text-mint-light" />
          <h3 className="text-white-light text-sm font-medium tracking-widest flex-1">
            {category.label}
          </h3>
          <span className="text-xs text-white-darker">
            (
            {category.variables.length +
              (category.subcategories?.reduce(
                (acc, sub) => acc + sub.variables.length,
                0
              ) || 0)}
            )
          </span>
        </div>

        {isExpanded && (
          <div className="pb-3">
            {category.variables.length > 0 && (
              <div className="space-y-1.5 px-3">
                {category.variables.map((variable) => renderVariable(variable))}
              </div>
            )}

            {category.subcategories && category.subcategories.length > 0 && (
              <div className="space-y-2 mt-3">
                {category.subcategories.map((subcategory) =>
                  renderSubcategory(category, subcategory)
                )}
              </div>
            )}
          </div>
        )}
      </div>
    );
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="w-96 bg-black-dark backdrop-blur-md border-2 border-black-lighter rounded-lg shadow-2xl select-none max-h-[70vh] z-40 flex flex-col"
    >
      <div
        className="flex items-center justify-between p-3 border-b border-black-lighter cursor-grab flex-shrink-0"
        {...attributes}
        {...listeners}
      >
        <div className="flex items-center gap-2">
          <Bars3Icon className="h-4 w-4 text-white-darker" />
          <h3 className="text-white-light text-sm font-medium tracking-wider">
            Game Variables
          </h3>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-white-darker hover:text-white transition-colors cursor-pointer"
        >
          <XMarkIcon className="h-4 w-4" />
        </button>
      </div>

      <div className="p-3 flex flex-col min-h-0 flex-1">
        <div className="relative mb-3 flex-shrink-0">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <MagnifyingGlassIcon className="h-4 w-4 text-white-darker" />
          </div>
          <input
            type="text"
            placeholder="Search variables..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-10 pr-4 py-2 bg-black-darker border border-black-lighter rounded-lg text-white-light placeholder-white-darker text-sm focus:outline-none focus:border-mint transition-colors"
          />
        </div>

        <div className="overflow-y-auto custom-scrollbar min-h-0 flex-1 -mx-3">
          {filteredCategories.length === 0 ? (
            <div className="text-center py-8 px-3">
              <div className="text-white-darker text-sm">
                No variables found
              </div>
              <div className="text-white-darker text-xs mt-1">
                Try adjusting your search terms
              </div>
            </div>
          ) : (
            <div className="space-y-0">
              {filteredCategories.map((category) => renderCategory(category))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default GameVariables;

```

### src\components\ruleBuilder\index.ts

```
export { default as RuleBuilder } from "./RuleBuilder";

// Export types
export type {
  Rule,
  ConditionGroup,
  Condition,
  Effect,
  RandomGroup,
  TriggerDefinition,
  ConditionTypeDefinition,
  EffectTypeDefinition,
  ConditionParameter,
  EffectParameter,
} from "./types";

// Export constants and helpers
export { TRIGGERS, getTriggerById } from "../data/Jokers/Triggers";

export {
  CONDITION_TYPES,
  getConditionTypeById,
} from "../data/Jokers/Conditions";

export { EFFECT_TYPES, getEffectTypeById } from "../data/Jokers/Effects";

export { LOGICAL_OPERATORS } from "./types";

```

### src\components\ruleBuilder\Inspector.tsx

```
import React, { useState } from "react";
import { useDraggable } from "@dnd-kit/core";
import type {
  Rule,
  Condition,
  Effect,
  RandomGroup,
  ConditionParameter,
  EffectParameter,
  ShowWhenCondition,
  LoopGroup,
} from "./types";
import { getModPrefix, JokerData } from "../data/BalatroUtils";
import {
  addSuitVariablesToOptions,
  addRankVariablesToOptions,
  getAllVariables,
  addPokerHandVariablesToOptions,
} from "../codeGeneration/Jokers/variableUtils";

import { getTriggerById } from "../data/Jokers/Triggers";
import { getConditionTypeById } from "../data/Jokers/Conditions";
import { getEffectTypeById } from "../data/Jokers/Effects";

import { getConsumableTriggerById } from "../data/Consumables/Triggers";
import { getConsumableConditionTypeById } from "../data/Consumables/Conditions";
import { getConsumableEffectTypeById } from "../data/Consumables/Effects";

import InputField from "../generic/InputField";
import InputDropdown from "../generic/InputDropdown";
import Button from "../generic/Button";
import {
  EyeIcon,
  InformationCircleIcon,
  VariableIcon,
  XMarkIcon,
  Bars3Icon,
  PlusIcon,
  ExclamationTriangleIcon,
  ArrowsRightLeftIcon,
  PlayCircleIcon,
  ArrowPathIcon,
} from "@heroicons/react/24/outline";
import { ChartPieIcon, PercentBadgeIcon } from "@heroicons/react/16/solid";
import {
  validateVariableName,
  validateCustomMessage,
} from "../generic/validationUtils";
import { GameVariable, getGameVariableById } from "../data/Jokers/GameVars";
import { CubeIcon } from "@heroicons/react/24/outline";
import { SelectedItem } from "./types";

import { getCardTriggerById } from "../data/Card/Triggers";
import { getCardConditionTypeById } from "../data/Card/Conditions";
import { getCardEffectTypeById } from "../data/Card/Effects";
import Checkbox from "../generic/Checkbox";

interface InspectorProps {
  position: { x: number; y: number };
  joker: JokerData;
  selectedRule: Rule | null;
  selectedCondition: Condition | null;
  selectedEffect: Effect | null;
  selectedRandomGroup: RandomGroup | null;
  selectedLoopGroup: LoopGroup | null;
  onUpdateCondition: (
    ruleId: string,
    conditionId: string,
    updates: Partial<Condition>
  ) => void;
  onUpdateEffect: (
    ruleId: string,
    effectId: string,
    updates: Partial<Effect>
  ) => void;
  onUpdateRandomGroup: (
    ruleId: string,
    randomGroupId: string,
    updates: Partial<RandomGroup>
  ) => void;
  onUpdateLoopGroup: (
    ruleId: string,
    randomGroupId: string,
    updates: Partial<LoopGroup>
  ) => void;
  onUpdateJoker: (updates: Partial<JokerData>) => void;
  onClose: () => void;
  onPositionChange: (position: { x: number; y: number }) => void;
  onToggleVariablesPanel: () => void;
  onToggleGameVariablesPanel: () => void;
  onCreateRandomGroupFromEffect: (ruleId: string, effectId: string) => void;
  onCreateLoopGroupFromEffect: (ruleId: string, effectId: string) => void;
  selectedGameVariable: GameVariable | null;
  onGameVariableApplied: () => void;
  selectedItem: SelectedItem;
  itemType: "joker" | "consumable" | "card";
}

interface ParameterFieldProps {
  param: ConditionParameter | EffectParameter;
  value: unknown;
  onChange: (value: unknown) => void;
  parentValues?: Record<string, unknown>;
  availableVariables?: Array<{ value: string; label: string }>;
  onCreateVariable?: (name: string, initialValue: number) => void;
  onOpenVariablesPanel?: () => void;
  onOpenGameVariablesPanel?: () => void;
  selectedGameVariable?: GameVariable | null;
  onGameVariableApplied?: () => void;
  isEffect?: boolean;
  joker?: JokerData;
  itemType?: "joker" | "consumable" | "card";
}

interface ChanceInputProps {
  label: string;
  value: string | number | undefined;
  onChange: (value: string | number) => void;
  availableVariables: Array<{ value: string; label: string }>;
  onCreateVariable: (name: string, initialValue: number) => void;
  onOpenVariablesPanel: () => void;
  onOpenGameVariablesPanel: () => void;
  selectedGameVariable?: GameVariable | null;
  onGameVariableApplied?: () => void;
  itemType?: "joker" | "consumable" | "card";
}

const ChanceInput: React.FC<ChanceInputProps> = React.memo(
  ({
    label,
    value,
    onChange,
    availableVariables,
    onOpenVariablesPanel,
    onOpenGameVariablesPanel,
    selectedGameVariable,
    onGameVariableApplied,
    itemType,
  }) => {
    const [isVariableMode, setIsVariableMode] = React.useState(
      typeof value === "string" &&
        !value.startsWith("GAMEVAR:") &&
        !value.startsWith("RANGE:")
    );
    const [isRangeMode, setIsRangeMode] = React.useState(
      typeof value === "string" && value.startsWith("RANGE:")
    );
    const [inputValue, setInputValue] = React.useState("");

    const numericValue = typeof value === "number" ? value : 1;
    const actualValue = value || numericValue;

    React.useEffect(() => {
      if (typeof value === "number") {
        setInputValue(value.toString());
      }
    }, [value]);

    const parseRangeValue = (rangeStr: string | number | unknown) => {
      if (typeof rangeStr === "string" && rangeStr.startsWith("RANGE:")) {
        const parts = rangeStr.replace("RANGE:", "").split("|");
        return {
          min: parseFloat(parts[0] || "1"),
          max: parseFloat(parts[1] || "5"),
        };
      }
      return { min: 1, max: 5 };
    };

    const rangeValues =
      isRangeMode && typeof actualValue === "string"
        ? parseRangeValue(actualValue)
        : { min: 1, max: 5 };

    React.useEffect(() => {
      const isVar =
        typeof value === "string" &&
        !value.startsWith("GAMEVAR:") &&
        !value.startsWith("RANGE:");
      const isRange = typeof value === "string" && value.startsWith("RANGE:");
      setIsVariableMode(isVar);
      setIsRangeMode(isRange);
    }, [value]);

    React.useEffect(() => {
      if (selectedGameVariable) {
        const currentValue = value;
        const isAlreadyGameVar =
          typeof currentValue === "string" &&
          currentValue.startsWith("GAMEVAR:");
        const multiplier = isAlreadyGameVar
          ? parseFloat(currentValue.split("|")[1] || "1")
          : 1;
        const startsFrom = isAlreadyGameVar
          ? parseFloat(currentValue.split("|")[2] || "0")
          : 0;

        onChange(
          `GAMEVAR:${selectedGameVariable.id}|${multiplier}|${startsFrom}`
        );
        onGameVariableApplied?.();
      }
    }, [selectedGameVariable, value, onChange, onGameVariableApplied]);

    const handleModeChange = (mode: "number" | "variable" | "range") => {
      if (mode === "number") {
        setIsVariableMode(false);
        setIsRangeMode(false);
        onChange(numericValue);
      } else if (mode === "variable") {
        setIsVariableMode(true);
        setIsRangeMode(false);
        onChange("");
      } else if (mode === "range") {
        setIsVariableMode(false);
        setIsRangeMode(true);
        onChange("RANGE:1|5");
      }
    };

    const handleNumberChange = (
      e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
    ) => {
      const newValue = e.target.value;
      setInputValue(newValue);

      if (newValue === "" || newValue === "-") {
        onChange(0);
        return;
      }

      const parsed = parseFloat(newValue);
      if (!isNaN(parsed)) {
        onChange(parsed);
      }
    };

    return (
      <div className="flex flex-col gap-2 items-center">
        <div className="flex items-center gap-2">
          <span className="text-white-light text-sm">{label}</span>
          {itemType !== "consumable" && (
            <button
              onClick={() =>
                handleModeChange(isVariableMode ? "number" : "variable")
              }
              className={`p-1 rounded transition-colors cursor-pointer ${
                isVariableMode
                  ? "bg-mint/20 text-mint"
                  : "bg-black-lighter text-white-darker hover:text-mint"
              }`}
              title="Toggle variable mode"
            >
              <VariableIcon className="h-3 w-3" />
            </button>
          )}
          <button
            onClick={onOpenGameVariablesPanel}
            className={`p-1 rounded transition-colors cursor-pointer ${
              typeof value === "string" && value.startsWith("GAMEVAR:")
                ? "bg-mint/20 text-mint"
                : "bg-black-lighter text-white-darker hover:text-mint"
            }`}
            title="Use game variable"
          >
            <CubeIcon className="h-3 w-3" />
          </button>
          <button
            onClick={() => handleModeChange(isRangeMode ? "number" : "range")}
            className={`p-1 rounded transition-colors cursor-pointer ${
              isRangeMode
                ? "bg-mint/20 text-mint"
                : "bg-black-lighter text-white-darker hover:text-mint"
            }`}
            title="Toggle range mode"
          >
            <ArrowsRightLeftIcon className="h-3 w-3" />
          </button>
        </div>

        {isRangeMode ? (
          <div className="flex items-center gap-2 w-full">
            <InputField
              type="number"
              value={rangeValues.min.toString()}
              onChange={(e) => {
                const newMin = parseFloat(e.target.value) ?? 1;
                onChange(`RANGE:${newMin}|${rangeValues.max}`);
              }}
              size="sm"
              className="w-16"
              placeholder="Min"
            />
            <span className="text-white-light text-xs">to</span>
            <InputField
              type="number"
              value={rangeValues.max.toString()}
              onChange={(e) => {
                const newMax = parseFloat(e.target.value) ?? 1;
                onChange(`RANGE:${rangeValues.min}|${newMax}`);
              }}
              size="sm"
              className="w-16"
              placeholder="Max"
            />
          </div>
        ) : isVariableMode && itemType !== "consumable" ? (
          <div className="space-y-2 w-full">
            {availableVariables.length > 0 ? (
              <InputDropdown
                value={(actualValue as string) || ""}
                onChange={(newValue) => onChange(newValue)}
                options={availableVariables}
                placeholder="Select variable"
                className="bg-black-dark"
                size="sm"
              />
            ) : (
              <Button
                variant="secondary"
                size="sm"
                fullWidth
                onClick={onOpenVariablesPanel}
                icon={<PlusIcon className="h-4 w-4" />}
                className="cursor-pointer"
              >
                Create Variable
              </Button>
            )}
          </div>
        ) : (
          <InputField
            type="number"
            value={inputValue}
            onChange={handleNumberChange}
            size="sm"
            className="w-20"
          />
        )}
      </div>
    );
  }
);

ChanceInput.displayName = "ChanceInput";

function hasShowWhen(param: ConditionParameter | EffectParameter): param is (
  | ConditionParameter
  | EffectParameter
) & {
  showWhen: ShowWhenCondition;
} {
  return "showWhen" in param && param.showWhen !== undefined;
}

const ParameterField: React.FC<ParameterFieldProps> = ({
  param,
  value,
  onChange,
  parentValues = {},
  availableVariables = [],
  onOpenVariablesPanel,
  onOpenGameVariablesPanel,
  selectedGameVariable,
  onGameVariableApplied,
  isEffect = false,
  joker = null,
  itemType,
}) => {
  const [isVariableMode, setIsVariableMode] = React.useState(
    typeof value === "string" &&
      !value.startsWith("GAMEVAR:") &&
      !value.startsWith("RANGE:")
  );
  const [isRangeMode, setIsRangeMode] = React.useState(
    typeof value === "string" && value.startsWith("RANGE:")
  );
  const [inputValue, setInputValue] = React.useState("");
  const [inputError, setInputError] = React.useState<string>("");

  const [showStartsFromTooltip, setShowStartsFromTooltip] =
    React.useState(false);
  const [showMultiplierTooltip, setShowMultiplierTooltip] =
    React.useState(false);

  React.useEffect(() => {
    if (param.type === "number" && typeof value === "number") {
      setInputValue(value.toString());
    }
  }, [param.type, value]);

  React.useEffect(() => {
    const isVar =
      typeof value === "string" &&
      !value.startsWith("GAMEVAR:") &&
      !value.startsWith("RANGE:");
    const isRange = typeof value === "string" && value.startsWith("RANGE:");
    setIsVariableMode(isVar);
    setIsRangeMode(isRange);
  }, [value]);

  React.useEffect(() => {
    if (selectedGameVariable && param.type === "number") {
      const currentValue = value;
      const isAlreadyGameVar =
        typeof currentValue === "string" && currentValue.startsWith("GAMEVAR:");
      const multiplier = isAlreadyGameVar
        ? parseFloat(currentValue.split("|")[1] || "1")
        : 1;
      const startsFrom = isAlreadyGameVar
        ? parseFloat(currentValue.split("|")[2] || "0")
        : 0;

      onChange(
        `GAMEVAR:${selectedGameVariable.id}|${multiplier}|${startsFrom}`
      );
      onGameVariableApplied?.();
    }
  }, [
    selectedGameVariable,
    param.type,
    onChange,
    onGameVariableApplied,
    value,
  ]);

  if (hasShowWhen(param)) {
    const { parameter, values } = param.showWhen;
    const parentValue = parentValues[parameter];
    if (!values.includes(parentValue as string)) {
      return null;
    }
  }

  if (param.id === "variable_name") {
    if (availableVariables.length > 0) {
      return (
        <InputDropdown
          label={String(param.label)}
          labelPosition="center"
          value={(value as string) || ""}
          onChange={(newValue) => onChange(newValue)}
          options={availableVariables}
          className="bg-black-dark"
          size="sm"
        />
      );
    } else {
      return (
        <div>
          <span className="text-white-light text-sm mb-2 block">
            {String(param.label)}
          </span>
          <Button
            variant="secondary"
            size="sm"
            fullWidth
            onClick={onOpenVariablesPanel}
            icon={<PlusIcon className="h-4 w-4" />}
            className="cursor-pointer"
          >
            Create Variable
          </Button>
        </div>
      );
    }
  }

  switch (param.type) {
    case "select": {
      let options: Array<{ value: string; label: string }> = [];

      if (typeof param.options === "function") {
        // Check if the function expects parentValues parameter
        if (param.options.length > 0) {
          // Function expects parentValues
          options = param.options(parentValues || {});
        } else {
          // Function with no parameters, but expects parentValues argument
          options = param.options(parentValues || {});
        }
      } else if (Array.isArray(param.options)) {
        options = param.options.map((option) => ({
          value: option.value,
          label: option.label,
        }));
      }

      if (param.id === "specific_suit" && joker) {
        options = addSuitVariablesToOptions(options, joker);
      }

      if (param.id === "specific_rank" && joker) {
        options = addRankVariablesToOptions(options, joker);
      }

      if (param.id === "value" && param.label === "Hand Type" && joker) {
        options = addPokerHandVariablesToOptions(options, joker);
      }

      if (param.id === "variable_name" && joker && param.label) {
        if (param.label.includes("Suit")) {
          const suitVariables =
            joker.userVariables?.filter((v) => v.type === "suit") || [];
          options = suitVariables.map((variable) => ({
            value: variable.name,
            label: variable.name,
          }));
        } else if (param.label.includes("Rank")) {
          const rankVariables =
            joker.userVariables?.filter((v) => v.type === "rank") || [];
          options = rankVariables.map((variable) => ({
            value: variable.name,
            label: variable.name,
          }));
        } else if (param.label.includes("Poker Hand")) {
          const pokerHandVariables =
            joker.userVariables?.filter((v) => v.type === "pokerhand") || [];
          options = pokerHandVariables.map((variable) => ({
            value: variable.name,
            label: variable.name,
          }));
        }
      }

      return (
        <InputDropdown
          label={String(param.label)}
          labelPosition="center"
          value={(value as string) || ""}
          onChange={(newValue) => onChange(newValue)}
          options={options}
          className="bg-black-dark"
          size="sm"
        />
      );
    }

    case "number": {
      const isGameVariable =
        typeof value === "string" && value.startsWith("GAMEVAR:");
      const gameVariableId = isGameVariable
        ? value.replace("GAMEVAR:", "").split("|")[0]
        : null;
      const gameVariableMultiplier = isGameVariable
        ? parseFloat(value.replace("GAMEVAR:", "").split("|")[1] || "1")
        : 1;
      const gameVariableStartsFrom = isGameVariable
        ? parseFloat(value.replace("GAMEVAR:", "").split("|")[2] || "0")
        : 0;
      const gameVariable = gameVariableId
        ? getGameVariableById(gameVariableId)
        : null;

      const parseRangeValue = (rangeStr: string) => {
        if (rangeStr.startsWith("RANGE:")) {
          const parts = rangeStr.replace("RANGE:", "").split("|");
          return {
            min: parseFloat(parts[0] || "1"),
            max: parseFloat(parts[1] || "5"),
          };
        }
        return { min: 1, max: 5 };
      };

      const rangeValues =
        isRangeMode && typeof value === "string"
          ? parseRangeValue(value)
          : { min: 1, max: 5 };

      const numericValue =
        !isGameVariable && !isRangeMode && typeof value === "number"
          ? value
          : typeof param.default === "number"
          ? param.default
          : 0;

      const handleModeChange = (mode: "number" | "variable" | "range") => {
        if (mode === "number") {
          setIsVariableMode(false);
          setIsRangeMode(false);
          onChange(numericValue);
          setInputValue(numericValue.toString());
        } else if (mode === "variable") {
          setIsVariableMode(true);
          setIsRangeMode(false);
          onChange("");
        } else if (mode === "range") {
          setIsVariableMode(false);
          setIsRangeMode(true);
          onChange("RANGE:1|5");
        }
      };

      const handleNumberChange = (
        e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
      ) => {
        const newValue = e.target.value;
        setInputValue(newValue);

        if (newValue === "" || newValue === "-") {
          onChange(0);
          return;
        }

        const parsed = parseFloat(newValue);
        if (!isNaN(parsed)) {
          onChange(parsed);
        }
      };

      const handleGameVariableChange = (
        field: "multiplier" | "startsFrom",
        newValue: string
      ) => {
        const parsed = parseFloat(newValue) || 0;
        if (field === "multiplier") {
          onChange(
            `GAMEVAR:${gameVariableId}|${parsed}|${gameVariableStartsFrom}`
          );
        } else {
          onChange(
            `GAMEVAR:${gameVariableId}|${gameVariableMultiplier}|${parsed}`
          );
        }
      };

      const handleRangeChange = (field: "min" | "max", newValue: string) => {
        const parsed = parseFloat(newValue) ?? 1;
        if (field === "min") {
          onChange(`RANGE:${parsed}|${rangeValues.max}`);
        } else {
          onChange(`RANGE:${rangeValues.min}|${parsed}`);
        }
      };

      return (
        <>
          <div className="flex items-center gap-2 mb-2">
            <span className="text-white-light text-sm">
              {String(param.label)}
            </span>
            {itemType !== "consumable" && (
              <button
                onClick={() =>
                  handleModeChange(isVariableMode ? "number" : "variable")
                }
                className={`p-1 rounded transition-colors cursor-pointer ${
                  isVariableMode
                    ? "bg-mint/20 text-mint"
                    : "bg-black-lighter text-white-darker hover:text-mint"
                }`}
                title="Toggle variable mode"
              >
                <VariableIcon className="h-4 w-4" />
              </button>
            )}
            <button
              onClick={onOpenGameVariablesPanel}
              className={`p-1 rounded transition-colors cursor-pointer ${
                isGameVariable
                  ? "bg-mint/20 text-mint"
                  : "bg-black-lighter text-white-darker hover:text-mint"
              }`}
              title="Use game variable"
            >
              <CubeIcon className="h-4 w-4" />
            </button>
            {isEffect && (
              <button
                onClick={() =>
                  handleModeChange(isRangeMode ? "number" : "range")
                }
                className={`p-1 rounded transition-colors cursor-pointer ${
                  isRangeMode
                    ? "bg-mint/20 text-mint"
                    : "bg-black-lighter text-white-darker hover:text-mint"
                }`}
                title="Toggle range mode"
              >
                <ArrowsRightLeftIcon className="h-4 w-4" />
              </button>
            )}
          </div>

          {isGameVariable ? (
            <div className="space-y-2">
              <div className="flex items-center justify-between p-2 bg-mint/10 border border-mint/30 rounded-lg">
                <div className="flex items-center gap-2">
                  <CubeIcon className="h-4 w-4 text-mint" />
                  <span className="text-mint text-sm font-medium">
                    {gameVariable?.label || "Unknown Game Variable"}
                  </span>
                </div>
                <button
                  onClick={() => {
                    onChange(numericValue);
                    setInputValue(numericValue.toString());
                  }}
                  className="p-1 text-mint hover:text-white transition-colors cursor-pointer"
                  title="Remove game variable"
                >
                  <XMarkIcon className="h-4 w-4" />
                </button>
              </div>
              <div className="relative">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-white-light text-sm">Starts From</span>
                  <div
                    className="relative"
                    onMouseEnter={() => setShowStartsFromTooltip(true)}
                    onMouseLeave={() => setShowStartsFromTooltip(false)}
                  >
                    <InformationCircleIcon className="h-4 w-4 text-white-darker hover:text-white-light cursor-help transition-colors" />
                    {showStartsFromTooltip && (
                      <div className="absolute bottom-full left-1/2 transform -translate-x-1/4 mb-2 px-3 py-2 bg-black-darker border border-black-lighter rounded-lg text-sm text-white-light w-72 z-50 shadow-lg pointer-events-none">
                        Value that the Game Variable starts from. (e.g. 1 for
                        XMult)
                      </div>
                    )}
                  </div>
                </div>
                <InputField
                  type="number"
                  value={gameVariableStartsFrom.toString()}
                  onChange={(e) =>
                    handleGameVariableChange("startsFrom", e.target.value)
                  }
                  size="sm"
                />
              </div>
              <div className="relative">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-white-light text-sm">Multiplier</span>
                  <div
                    className="relative"
                    onMouseEnter={() => setShowMultiplierTooltip(true)}
                    onMouseLeave={() => setShowMultiplierTooltip(false)}
                  >
                    <InformationCircleIcon className="h-4 w-4 text-white-darker hover:text-white-light cursor-help transition-colors" />
                    {showMultiplierTooltip && (
                      <div className="absolute bottom-full left-1/2 transform -translate-x-1/4 mb-2 px-3 py-2 bg-black-darker border border-black-lighter rounded-lg text-sm text-white-light w-72 z-50 shadow-lg pointer-events-none">
                        Factor that the Game Variable with multiply with /
                        increment by. (e.g. 0.1 for XMult)
                      </div>
                    )}
                  </div>
                </div>
                <InputField
                  type="number"
                  value={gameVariableMultiplier.toString()}
                  onChange={(e) =>
                    handleGameVariableChange("multiplier", e.target.value)
                  }
                  size="sm"
                />
              </div>
            </div>
          ) : isRangeMode && isEffect ? (
            <div className="space-y-2">
              <div className="flex items-center justify-between p-2 bg-mint/10 border border-mint/30 rounded-lg">
                <div className="flex items-center gap-2">
                  <ArrowsRightLeftIcon className="h-4 w-4 text-mint" />
                  <span className="text-mint text-sm font-medium">
                    Range Mode: {rangeValues.min} to {rangeValues.max}
                  </span>
                </div>
                <button
                  onClick={() => handleModeChange("number")}
                  className="p-1 text-mint hover:text-white transition-colors cursor-pointer"
                  title="Remove range mode"
                >
                  <XMarkIcon className="h-4 w-4" />
                </button>
              </div>
              <div>
                <span className="text-white-light text-sm mb-2 block">
                  Minimum Value
                </span>
                <InputField
                  type="number"
                  value={rangeValues.min.toString()}
                  onChange={(e) => handleRangeChange("min", e.target.value)}
                  size="sm"
                />
              </div>
              <div>
                <span className="text-white-light text-sm mb-2 block">
                  Maximum Value
                </span>
                <InputField
                  type="number"
                  value={rangeValues.max.toString()}
                  onChange={(e) => handleRangeChange("max", e.target.value)}
                  size="sm"
                />
              </div>
            </div>
          ) : isVariableMode && itemType !== "consumable" ? (
            <div className="space-y-2">
              {availableVariables && availableVariables.length > 0 ? (
                <InputDropdown
                  value={(value as string) || ""}
                  onChange={(newValue) => onChange(newValue)}
                  options={availableVariables}
                  placeholder="Select variable"
                  className="bg-black-dark"
                  size="sm"
                />
              ) : (
                <Button
                  variant="secondary"
                  size="sm"
                  fullWidth
                  onClick={() => onOpenVariablesPanel?.()}
                  icon={<PlusIcon className="h-4 w-4" />}
                  className="cursor-pointer"
                >
                  Create Variable
                </Button>
              )}
            </div>
          ) : (
            <InputField
              type="number"
              value={inputValue}
              onChange={handleNumberChange}
              size="sm"
              labelPosition="center"
            />
          )}
        </>
      );
    }

    case "text": {
      const isVariableName = param.id === "variable_name";

      return (
        <div>
          <InputField
            label={String(param.label)}
            value={(value as string) || ""}
            onChange={(e) => {
              const newValue = e.target.value;
              onChange(newValue);

              if (isVariableName) {
                const validation = validateVariableName(newValue);
                setInputError(
                  validation.isValid ? "" : validation.error || "Invalid name"
                );
              }
            }}
            className="text-sm"
            size="sm"
            error={isVariableName ? inputError : undefined}
          />
          {isVariableName && inputError && (
            <div className="flex items-center gap-2 mt-1 text-balatro-red text-sm">
              <ExclamationTriangleIcon className="h-4 w-4" />
              <span>{inputError}</span>
            </div>
          )}
        </div>
      );
    }

    default:
      return null;
  }
};

const Inspector: React.FC<InspectorProps> = ({
  position,
  joker,
  selectedRule,
  selectedCondition,
  selectedEffect,
  selectedRandomGroup,
  selectedLoopGroup,
  onUpdateCondition,
  onUpdateEffect,
  onUpdateRandomGroup,
  onUpdateLoopGroup,
  onUpdateJoker,
  onClose,
  onToggleVariablesPanel,
  onToggleGameVariablesPanel,
  onCreateRandomGroupFromEffect,
  onCreateLoopGroupFromEffect,
  selectedGameVariable,
  onGameVariableApplied,
  selectedItem,
  itemType,
}) => {
  const [customMessageValidationError, setCustomMessageValidationError] =
    useState<string>("");

  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "panel-inspector",
  });

  const style = transform
    ? {
        position: "absolute" as const,
        left: position.x + transform.x,
        top: position.y + transform.y,
      }
    : {
        position: "absolute" as const,
        left: position.x,
        top: position.y,
      };

  const getTrigger =
    itemType === "joker"
      ? getTriggerById
      : itemType === "consumable"
      ? getConsumableTriggerById
      : getCardTriggerById;

  const getConditionType =
    itemType === "joker"
      ? getConditionTypeById
      : itemType === "consumable"
      ? getConsumableConditionTypeById
      : getCardConditionTypeById;

  const getEffectType =
    itemType === "joker"
      ? getEffectTypeById
      : itemType === "consumable"
      ? getConsumableEffectTypeById
      : getCardEffectTypeById;

  const availableVariables = getAllVariables(joker).map(
    (variable: { name: string }) => ({
      value: variable.name,
      label: variable.name,
    })
  );

  const handleCreateVariable = (name: string, initialValue: number) => {
    const validation = validateVariableName(name);

    if (!validation.isValid) {
      alert(validation.error);
      return;
    }

    const existingNames = getAllVariables(joker).map((v) =>
      v.name.toLowerCase()
    );
    if (existingNames.includes(name.toLowerCase())) {
      alert("Variable name already exists");
      return;
    }

    const newVariable = {
      id: crypto.randomUUID(),
      name,
      initialValue,
    };

    const updatedVariables = [...(joker.userVariables || []), newVariable];
    onUpdateJoker({ userVariables: updatedVariables });
  };

  React.useEffect(() => {
    setCustomMessageValidationError("");
  }, [selectedEffect?.id]);

  React.useEffect(() => {
    if (selectedGameVariable && selectedItem) {
      if (selectedItem.type === "condition" && selectedCondition) {
        if (selectedCondition.id == "Generic Compare") {
          const valueParam = selectedCondition.params.value;
          if (valueParam !== undefined) {
            const currentValue = valueParam;
            const isAlreadyGameVar =
              typeof currentValue === "string" &&
              currentValue.startsWith("GAMEVAR:");
            const multiplier = isAlreadyGameVar
              ? parseFloat(currentValue.split("|")[1] || "1")
              : 1;
            const startsFrom = isAlreadyGameVar
              ? parseFloat(currentValue.split("|")[2] || "0")
              : 0;

            onUpdateCondition(selectedRule?.id || "", selectedCondition.id, {
              params: {
                ...selectedCondition.params,
                value: `GAMEVAR:${selectedGameVariable.id}|${multiplier}|${startsFrom}`,
              },
            });
          }
          onGameVariableApplied();
        } else {
          let valueParam, item;
          if (selectedCondition.params.value1 === 0) {
            valueParam = selectedCondition.params.value1;
            item = "value1";
          } else {
            valueParam = selectedCondition.params.value2;
            item = "value2";
          }
          if (valueParam !== undefined) {
            const currentValue = valueParam;
            const isAlreadyGameVar =
              typeof currentValue === "string" &&
              currentValue.startsWith("GAMEVAR:");
            const multiplier = isAlreadyGameVar
              ? parseFloat(currentValue.split("|")[1] || "1")
              : 1;
            const startsFrom = isAlreadyGameVar
              ? parseFloat(currentValue.split("|")[2] || "0")
              : 0;

            onUpdateCondition(selectedRule?.id || "", selectedCondition.id, {
              params: {
                ...selectedCondition.params,
                [item]: `GAMEVAR:${selectedGameVariable.id}|${multiplier}|${startsFrom}`,
              },
            });
          }
          onGameVariableApplied();
        }
      } else if (selectedItem.type === "effect" && selectedEffect) {
        const valueParam =
          selectedEffect.params.value || selectedEffect.params.repetitions;
        if (valueParam !== undefined) {
          const currentValue = valueParam;
          const isAlreadyGameVar =
            typeof currentValue === "string" &&
            currentValue.startsWith("GAMEVAR:");
          const multiplier = isAlreadyGameVar
            ? parseFloat(currentValue.split("|")[1] || "1")
            : 1;
          const startsFrom = isAlreadyGameVar
            ? parseFloat(currentValue.split("|")[2] || "0")
            : 0;

          const paramKey =
            selectedEffect.params.value !== undefined ? "value" : "repetitions";
          onUpdateEffect(selectedRule?.id || "", selectedEffect.id, {
            params: {
              ...selectedEffect.params,
              [paramKey]: `GAMEVAR:${selectedGameVariable.id}|${multiplier}|${startsFrom}`,
            },
          });
          onGameVariableApplied();
        }
      } else if (selectedItem.type === "randomgroup" && selectedRandomGroup) {
        onUpdateRandomGroup(selectedRule?.id || "", selectedRandomGroup.id, {
          chance_numerator: `GAMEVAR:${selectedGameVariable.id}|1|0`,
        });
        onGameVariableApplied();
      } else if (selectedItem.type === "loopgroup" && selectedLoopGroup) {
        onUpdateLoopGroup(selectedRule?.id || "", selectedLoopGroup.id, {
          repetitions: `GAMEVAR:${selectedGameVariable.id}|1|0`,
        });
        onGameVariableApplied();
      }
    }
  }, [
    selectedGameVariable,
    selectedItem,
    selectedCondition,
    selectedEffect,
    selectedRandomGroup,
    selectedLoopGroup,
    selectedRule?.id,
    onUpdateCondition,
    onUpdateEffect,
    onUpdateRandomGroup,
    onUpdateLoopGroup,
    onGameVariableApplied,
  ]);

  const renderTriggerInfo = () => {
    if (!selectedRule) return null;
    const trigger = getTrigger(selectedRule.trigger);
    if (!trigger) return null;

    return (
      <div className="space-y-4">
        <div className="bg-gradient-to-r from-trigger/20 to-transparent border border-trigger/30 rounded-lg p-4">
          <div className="flex items-center gap-3 mb-3">
            <div className="w-10 h-10 bg-trigger/20 rounded-lg flex items-center justify-center">
              <EyeIcon className="h-5 w-5 text-trigger" />
            </div>
            <div>
              <h4 className="text-trigger font-medium text-lg">
                {trigger.label}
              </h4>
              <span className="text-white-darker text-xs uppercase tracking-wider">
                Trigger Event ({itemType})
              </span>
            </div>
          </div>
          <p className="text-white-light text-sm leading-relaxed">
            {trigger.description}
          </p>
        </div>

        <div className="grid grid-cols-3 gap-3">
          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <div className="text-white-light text-sm font-medium mb-1">
              Conditions
            </div>
            <div className="text-mint text-2xl font-bold">
              {selectedRule.conditionGroups.reduce(
                (total, group) => total + group.conditions.length,
                0
              )}
            </div>
          </div>
          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <div className="text-white-light text-sm font-medium mb-1">
              Effects
            </div>
            <div className="text-mint text-2xl font-bold">
              {selectedRule.effects.length +
                selectedRule.randomGroups.reduce(
                  (sum, group) => sum + group.effects.length,
                  0
                ) +
                selectedRule.loops.reduce(
                  (sum, group) => sum + group.effects.length,
                  0
                )}
            </div>
          </div>
          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <div className="text-white-light text-sm font-medium mb-1">
              Random Groups
            </div>
            <div className="text-mint text-2xl font-bold">
              {selectedRule.randomGroups.length}
            </div>
          </div>
        </div>
      </div>
    );
  };

  const renderConditionEditor = () => {
    if (!selectedCondition || !selectedRule) return null;
    const conditionType = getConditionType(selectedCondition.type);
    if (!conditionType) return null;

    const paramsToRender = conditionType.params.filter((param) => {
      if (!hasShowWhen(param)) return true;
      const { parameter, values } = param.showWhen;
      const parentValue = selectedCondition.params[parameter];
      return values.includes(parentValue as string);
    });

    return (
      <div className="space-y-4">
        <div className="bg-gradient-to-r from-condition/20 to-transparent border border-condition/30 rounded-lg p-4 relative">
          <button
            onClick={() =>
              onUpdateCondition(selectedRule.id, selectedCondition.id, {
                negate: !selectedCondition.negate,
              })
            }
            className={`absolute top-4 right-4 p-2 rounded-lg border-2 transition-colors cursor-pointer z-10 ${
              selectedCondition.negate
                ? "bg-balatro-red/20 border-balatro-red text-balatro-red"
                : "bg-black-darker border-black-lighter text-white-darker hover:border-balatro-red hover:text-balatro-red"
            }`}
            title={
              selectedCondition.negate ? "Remove negation" : "Negate condition"
            }
          >
            <ExclamationTriangleIcon className="h-4 w-4 text-balatro-red" />
          </button>

          <div className="flex items-center gap-3 mb-3">
            <div className="w-10 h-10 bg-condition/20 rounded-lg flex items-center justify-center">
              <InformationCircleIcon className="h-5 w-5 text-condition" />
            </div>
            <div className="flex-1 pr-12">
              <h4 className="text-condition font-medium text-lg">
                {conditionType.label}
              </h4>
              <span className="text-white-darker text-xs uppercase tracking-wider">
                Condition Logic ({itemType})
              </span>
            </div>
          </div>
          <p className="text-white-light text-sm leading-relaxed">
            {conditionType.description}
          </p>
        </div>

        {paramsToRender.length > 0 && (
          <div className="space-y-3">
            <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
              <div className="w-2 h-2 bg-condition rounded-full"></div>
              Parameters
            </h5>
            {paramsToRender.map((param) => (
              <div
                key={param.id}
                className="bg-black-darker border border-black-lighter rounded-lg p-3"
              >
                <ParameterField
                  param={param}
                  value={selectedCondition.params[param.id]}
                  onChange={(value) => {
                    const newParams = {
                      ...selectedCondition.params,
                      [param.id]: value,
                    };
                    onUpdateCondition(selectedRule.id, selectedCondition.id, {
                      params: newParams,
                    });
                  }}
                  parentValues={selectedCondition.params}
                  availableVariables={availableVariables}
                  onCreateVariable={handleCreateVariable}
                  onOpenVariablesPanel={onToggleVariablesPanel}
                  onOpenGameVariablesPanel={onToggleGameVariablesPanel}
                  selectedGameVariable={selectedGameVariable}
                  onGameVariableApplied={onGameVariableApplied}
                  isEffect={false}
                  joker={joker}
                  itemType={itemType}
                />
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  const renderRandomGroupEditor = () => {
    if (!selectedRandomGroup || !selectedRule) return null;

    return (
      <div className="space-y-4">
        <div className="bg-gradient-to-r from-mint/20 to-transparent border border-mint/30 rounded-lg p-4">
          <div className="flex items-center gap-3 mb-3">
            <div className="w-10 h-10 bg-mint/20 rounded-lg flex items-center justify-center">
              <PercentBadgeIcon className="h-5 w-5 text-mint" />
            </div>
            <div>
              <h4 className="text-mint font-medium text-lg">Random Group</h4>
              <span className="text-white-darker text-xs uppercase tracking-wider">
                Chance-Based Effects
              </span>
            </div>
          </div>
          <p className="text-white-light text-sm leading-relaxed">
            Effects in this group will all be triggered together if the random
            chance succeeds.
          </p>
        </div>

        <div className="space-y-3">
          <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
            <div className="w-2 h-2 bg-mint rounded-full"></div>
            Chance Configuration
          </h5>

          <div className="bg-mint/10 border border-mint/30 rounded-lg p-4">
            <div className="flex flex-col items-center gap-4">
              <ChanceInput
                key="numerator"
                label="Numerator"
                value={selectedRandomGroup.chance_numerator}
                onChange={(value) => {
                  onUpdateRandomGroup(selectedRule.id, selectedRandomGroup.id, {
                    chance_numerator: value,
                  });
                }}
                availableVariables={availableVariables}
                onCreateVariable={handleCreateVariable}
                onOpenVariablesPanel={onToggleVariablesPanel}
                onOpenGameVariablesPanel={onToggleGameVariablesPanel}
                selectedGameVariable={selectedGameVariable}
                onGameVariableApplied={onGameVariableApplied}
                itemType={itemType}
              />
              <span className="text-white-light text-sm">in</span>
              <ChanceInput
                key="denominator"
                label="Denominator"
                value={selectedRandomGroup.chance_denominator}
                onChange={(value) => {
                  onUpdateRandomGroup(selectedRule.id, selectedRandomGroup.id, {
                    chance_denominator: value,
                  });
                }}
                availableVariables={availableVariables}
                onCreateVariable={handleCreateVariable}
                onOpenVariablesPanel={onToggleVariablesPanel}
                onOpenGameVariablesPanel={onToggleGameVariablesPanel}
                selectedGameVariable={selectedGameVariable}
                onGameVariableApplied={onGameVariableApplied}
                itemType={itemType}
              />
            </div>
          </div>
          <div className="space-y-3">
            <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
              <div className="w-2 h-2 bg-mint rounded-full"></div>
              Advanced Configuration
            </h5>

            <div className="bg-mint/10 border border-mint/30 rounded-lg p-4">
              <div className="flex flex-col items-center gap-4">
                <div className="space-y-6 p-2">
                  <Checkbox
                    id="respect_probability_effects"
                    label="Affected by Probability Effects"
                    checked={
                      selectedRule.trigger === "change_probability"
                        ? false
                        : selectedRandomGroup.respect_probability_effects !==
                          false
                    }
                    disabled={selectedRule.trigger === "change_probability"}
                    onChange={(checked) => {
                      onUpdateRandomGroup(
                        selectedRule.id,
                        selectedRandomGroup.id,
                        {
                          respect_probability_effects: checked,
                        }
                      );
                    }}
                  />
                  <InputField
                    key="custom_key"
                    value={selectedRandomGroup.custom_key}
                    onChange={(e) => {
                      onUpdateRandomGroup(
                        selectedRule.id,
                        selectedRandomGroup.id,
                        {
                          custom_key: e.target.value,
                        }
                      );
                    }}
                    placeholder={(() => {
                      let classPrefix: string;
                      let key: string;
                      switch (itemType) {
                        case "joker":
                          classPrefix = "j";
                          key = joker.jokerKey || "";
                          break;
                        case "consumable":
                          classPrefix = "c";
                          // @ts-expect-error: The inspector can take more than JokerData
                          key = joker.consumableKey || "";
                          break;
                        case "card":
                          classPrefix = "m";
                          // @ts-expect-error: The inspector can take more than JokerData
                          key = joker.sealKey || joker.enhancementKey || "";
                          break;
                        default:
                          classPrefix = "j";
                          key = joker.jokerKey || "";
                      }
                      const modPrefix = getModPrefix();

                      return `${classPrefix}_${modPrefix}_${key}`;
                    })()}
                    label="Custom Probability key"
                    type="text"
                    size="sm"
                  />
                </div>
              </div>
            </div>
          </div>

          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <div className="text-white-light text-sm font-medium mb-2">
              Effects in this group
            </div>
            <div className="text-mint text-lg font-bold">
              {selectedRandomGroup.effects.length}
            </div>
          </div>
        </div>
      </div>
    );
  };

  const renderLoopGroupEditor = () => {
    if (!selectedLoopGroup || !selectedRule) return null;

    return (
      <div className="space-y-4">
        <div className="bg-gradient-to-r from-balatro-blue/20 to-transparent border border-balatro-blue/30 rounded-lg p-4">
          <div className="flex items-center gap-3 mb-3">
            <div className="w-10 h-10 bg-balatro-blue/20 rounded-lg flex items-center justify-center">
              <PlayCircleIcon className="h-5 w-5 text-balatro-blue" />
            </div>
            <div>
              <h4 className="text-balatro-blue font-medium text-lg">
                Loop Group
              </h4>
              <span className="text-white-darker text-xs uppercase tracking-wider">
                Repeat Effects
              </span>
            </div>
          </div>
          <p className="text-white-light text-sm leading-relaxed">
            Effects in this group will all be triggered together for the amount
            of repetitions you set.
          </p>
        </div>

        <div className="space-y-3">
          <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
            <div className="w-2 h-2 bg-balatro-blue rounded-full"></div>
            Loop Configuration
          </h5>

          <div className="bg-balatro-blue/10 border border-balatro-blue/30 rounded-lg p-4">
            <div className="flex flex-col items-center gap-4">
              <span className="text-white-light text-sm">Loop</span>
              <ChanceInput
                key="repetitions"
                label=""
                value={selectedLoopGroup.repetitions}
                onChange={(value) => {
                  onUpdateLoopGroup(selectedRule.id, selectedLoopGroup.id, {
                    repetitions: value,
                  });
                }}
                availableVariables={availableVariables}
                onCreateVariable={handleCreateVariable}
                onOpenVariablesPanel={onToggleVariablesPanel}
                onOpenGameVariablesPanel={onToggleGameVariablesPanel}
                selectedGameVariable={selectedGameVariable}
                onGameVariableApplied={onGameVariableApplied}
                itemType={itemType}
              />
              <span className="text-white-light text-sm">Time(s)</span>
            </div>
          </div>

          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <div className="text-white-light text-sm font-medium mb-2">
              Effects in this group
            </div>
            <div className="text-balatro-blue text-lg font-bold">
              {selectedLoopGroup.effects.length}
            </div>
          </div>
        </div>
      </div>
    );
  };

  const renderEffectEditor = () => {
    if (!selectedEffect || !selectedRule) return null;
    const effectType = getEffectType(selectedEffect.type);
    if (!effectType) return null;

    const paramsToRender = effectType.params.filter((param) => {
      if (!hasShowWhen(param)) return true;
      const { parameter, values } = param.showWhen;
      const parentValue = selectedEffect.params[parameter];
      return values.includes(parentValue as string);
    });

    const isInRandomGroup = selectedRule.randomGroups.some((group) =>
      group.effects.some((effect) => effect.id === selectedEffect.id)
    );
    const isInLoopGroup = selectedRule.loops.some((group) =>
      group.effects.some((effect) => effect.id === selectedEffect.id)
    );

    return (
      <div className="space-y-4">
        <div className="bg-gradient-to-r from-effect/20 to-transparent border border-effect/30 rounded-lg p-4 relative">
          {!isInRandomGroup && !isInLoopGroup && (
            <button
              onClick={() =>
                onCreateRandomGroupFromEffect(
                  selectedRule.id,
                  selectedEffect.id
                )
              }
              className="absolute top-4 right-4 p-2 rounded-lg border-2 transition-colors cursor-pointer z-10 bg-black-darker border-mint text-mint hover:bg-mint/20"
              title="Create Random Group"
            >
              <PercentBadgeIcon className="h-4 w-4" />
            </button>
          )}
          {!isInRandomGroup && !isInLoopGroup && (
            <button
              onClick={() =>
                onCreateLoopGroupFromEffect(selectedRule.id, selectedEffect.id)
              }
              className="absolute top-4 right-16 p-2 rounded-lg border-2 transition-colors cursor-pointer z-10 bg-black-darker border-balatro-blue text-balatro-blue hover:bg-balatro-blue/20"
              title="Create Loop Group"
            >
              <ArrowPathIcon className="h-4 w-4" />
            </button>
          )}

          <div className="flex items-center gap-3 mb-3">
            <div className="w-10 h-10 bg-effect/20 rounded-lg flex items-center justify-center">
              <InformationCircleIcon className="h-5 w-5 text-effect" />
            </div>
            <div className="flex-1 pr-12">
              <h4 className="text-effect font-medium text-lg">
                {effectType.label}
              </h4>
              <span className="text-white-darker text-xs uppercase tracking-wider">
                Effect Action ({itemType})
              </span>
            </div>
          </div>
          <p className="text-white-light text-sm leading-relaxed">
            {effectType.description}
          </p>
        </div>

        <div className="space-y-3">
          <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
            <div className="w-2 h-2 bg-effect rounded-full"></div>
            Custom Message
          </h5>
          <div className="bg-black-darker border border-black-lighter rounded-lg p-3">
            <InputField
              label="Message"
              value={selectedEffect.customMessage || ""}
              onChange={(e) => {
                const value = e.target.value;
                const validation = validateCustomMessage(value);

                if (validation.isValid) {
                  setCustomMessageValidationError("");
                } else {
                  setCustomMessageValidationError(
                    validation.error || "Invalid message"
                  );
                }

                onUpdateEffect(selectedRule.id, selectedEffect.id, {
                  customMessage: value || undefined,
                });
              }}
              placeholder="Leave blank for default message"
              size="sm"
            />
            {customMessageValidationError && (
              <div className="flex items-center gap-2 mt-1 text-balatro-red text-sm">
                <ExclamationTriangleIcon className="h-4 w-4" />
                <span>{customMessageValidationError}</span>
              </div>
            )}
          </div>
        </div>

        {paramsToRender.length > 0 && (
          <div className="space-y-3">
            <h5 className="text-white-light font-medium text-sm flex items-center gap-2">
              <div className="w-2 h-2 bg-effect rounded-full"></div>
              Parameters
            </h5>
            {paramsToRender.map((param) => (
              <div
                key={param.id}
                className="bg-black-darker border border-black-lighter rounded-lg p-3"
              >
                <ParameterField
                  param={param}
                  value={selectedEffect.params[param.id]}
                  onChange={(value) => {
                    const newParams = {
                      ...selectedEffect.params,
                      [param.id]: value,
                    };
                    onUpdateEffect(selectedRule.id, selectedEffect.id, {
                      params: newParams,
                    });
                  }}
                  parentValues={selectedEffect.params}
                  availableVariables={availableVariables}
                  onCreateVariable={handleCreateVariable}
                  onOpenVariablesPanel={onToggleVariablesPanel}
                  onOpenGameVariablesPanel={onToggleGameVariablesPanel}
                  selectedGameVariable={selectedGameVariable}
                  onGameVariableApplied={onGameVariableApplied}
                  isEffect={true}
                  joker={joker}
                  itemType={itemType}
                />
              </div>
            ))}
          </div>
        )}
      </div>
    );
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="w-96 bg-black-dark backdrop-blur-md border-2 border-black-lighter rounded-lg shadow-2xl max-h-[calc(100vh-6rem)] z-40 flex flex-col"
    >
      <div
        className="flex items-center justify-between p-3 border-b border-black-lighter cursor-grab active:cursor-grabbing flex-shrink-0"
        {...attributes}
        {...listeners}
      >
        <div className="flex items-center gap-2">
          <Bars3Icon className="h-4 w-4 text-white-darker" />
          <ChartPieIcon className="h-5 w-5 text-white-light" />
          <h3 className="text-white-light text-sm font-medium tracking-wider">
            Inspector ({itemType})
          </h3>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-white-darker hover:text-white transition-colors cursor-pointer"
        >
          <XMarkIcon className="h-4 w-4" />
        </button>
      </div>

      <div className="p-4 overflow-y-auto custom-scrollbar min-h-0 flex-1">
        <div className="w-1/4 h-[1px] bg-black-lighter mx-auto mb-6"></div>

        {!selectedRule && (
          <div className="flex items-center justify-center h-40">
            <div className="text-center">
              <InformationCircleIcon className="h-12 w-12 text-white-darker mx-auto mb-3 opacity-50" />
              <p className="text-white-darker text-sm">
                Select a rule to view its properties
              </p>
            </div>
          </div>
        )}

        {selectedRule &&
          !selectedCondition &&
          !selectedEffect &&
          !selectedRandomGroup &&
          !selectedLoopGroup &&
          renderTriggerInfo()}
        {selectedCondition && renderConditionEditor()}
        {selectedEffect && renderEffectEditor()}
        {selectedRandomGroup && renderRandomGroupEditor()}
        {selectedLoopGroup && renderLoopGroupEditor()}
      </div>
    </div>
  );
};

export default Inspector;

```

### src\components\ruleBuilder\RuleCard.tsx

```
import React, { useState, useEffect, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  SortableContext,
  verticalListSortingStrategy,
  useSortable,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import type {
  Rule,
  ConditionGroup,
  Condition,
  Effect,
  RandomGroup,
  SelectedItem,
  LoopGroup,
} from "./types";

import { getTriggerById } from "../data/Jokers/Triggers";
import { getConditionTypeById } from "../data/Jokers/Conditions";
import { getEffectTypeById } from "../data/Jokers/Effects";
import { getConsumableTriggerById } from "../data/Consumables/Triggers";
import { getConsumableConditionTypeById } from "../data/Consumables/Conditions";
import { getConsumableEffectTypeById } from "../data/Consumables/Effects";

import BlockComponent from "./BlockComponent";
import { ChevronDownIcon, Bars3Icon, ArrowPathIcon } from "@heroicons/react/24/outline";
import {
  TrashIcon,
  PlusIcon,
  DocumentDuplicateIcon,
  XMarkIcon,
} from "@heroicons/react/16/solid";
import {
  JokerData,
  ConsumableData,
  EnhancementData,
  SealData,
  EditionData,
} from "../data/BalatroUtils";
import { WrenchIcon } from "@heroicons/react/24/solid";

import { getCardTriggerById } from "../data/Card/Triggers";
import { getCardConditionTypeById } from "../data/Card/Conditions";
import { getCardEffectTypeById } from "../data/Card/Effects";

interface RuleCardProps {
  rule: Rule;
  ruleIndex: number;
  selectedItem: SelectedItem
  onSelectItem: (item: {
    type: "trigger" | "condition" | "effect" | "randomgroup" | "loopgroup";
    ruleId: string;
    itemId?: string;
    groupId?: string;
    randomGroupId?: string;
    loopGroupId?: string
  }) => void;
  onDeleteRule: (ruleId: string) => void;
  onDuplicateRule: (ruleId: string) => void;
  onDeleteCondition: (ruleId: string, conditionId: string) => void;
  onDeleteConditionGroup: (ruleId: string, groupId: string) => void;
  onDeleteEffect: (ruleId: string, effectId: string) => void;
  onAddConditionGroup: (ruleId: string) => void;
  onAddRandomGroup: (ruleId: string) => void;
  onAddLoop: (ruleId: string) => void;
  onToggleBlueprintCompatibility: (ruleId: string) => void;
  onDeleteRandomGroup: (ruleId: string, randomGroupId: string) => void;
  onDeleteLoopGroup: (ruleId: string, randomGroupId: string) => void;
  onToggleGroupOperator?: (ruleId: string, groupId: string) => void;
  onUpdatePosition: (
    ruleId: string,
    position: { x: number; y: number }
  ) => void;
  isRuleSelected: boolean;
  item: JokerData | ConsumableData | EnhancementData | SealData | EditionData;
  itemType: "joker" | "consumable" | "card";
  generateConditionTitle: (condition: Condition) => string;
  generateEffectTitle: (effect: Effect) => string;
  getParameterCount: (params: Record<string, unknown>) => number;
  onUpdateConditionOperator: (
    ruleId: string,
    conditionId: string,
    operator: "and" | "or"
  ) => void;
  onRuleDoubleClick: () => void;
}

const SortableCondition: React.FC<{
  condition: Condition;
  ruleId: string;
  groupId: string;
  isSelected: boolean;
  isNegated: boolean;
  onSelect: () => void;
  onDelete: () => void;
  parameterCount: number;
  dynamicTitle: string;
  itemType: "joker" | "consumable" | "card";
}> = ({
  condition,
  isSelected,
  isNegated,
  onSelect,
  onDelete,
  parameterCount,
  dynamicTitle,
  itemType,
}) => {
  const getConditionType =
    itemType === "joker"
      ? getConditionTypeById
      : itemType === "consumable"
      ? getConsumableConditionTypeById
      : getCardConditionTypeById;
  const conditionType = getConditionType(condition.type);

  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: condition.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      className="flex justify-center -mt-3"
    >
      <BlockComponent
        type="condition"
        label={conditionType?.label || "Unknown Condition"}
        dynamicTitle={dynamicTitle}
        isSelected={isSelected}
        onClick={(e) => {
          e?.stopPropagation();
          onSelect();
        }}
        showTrash={true}
        onDelete={() => {
          onDelete();
        }}
        parameterCount={parameterCount}
        isNegated={isNegated}
        isDraggable={true}
        dragHandleProps={listeners}
        variant="condition"
      />
    </div>
  );
};

const SortableEffect: React.FC<{
  effect: Effect;
  ruleId: string;
  isSelected: boolean;
  onSelect: () => void;
  onDelete: () => void;
  parameterCount: number;
  dynamicTitle: string;
  randomGroupId?: string;
  itemType: "joker" | "consumable" | "card";
}> = ({
  effect,
  isSelected,
  onSelect,
  onDelete,
  parameterCount,
  dynamicTitle,
  itemType,
}) => {
  const getEffectType =
    itemType === "joker"
      ? getEffectTypeById
      : itemType === "consumable"
      ? getConsumableEffectTypeById
      : getCardEffectTypeById;
  const effectType = getEffectType(effect.type);

  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: effect.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      className="flex justify-center"
    >
      <BlockComponent
        type="effect"
        label={effectType?.label || "Unknown Effect"}
        dynamicTitle={dynamicTitle}
        isSelected={isSelected}
        onClick={(e) => {
          e?.stopPropagation();
          onSelect();
        }}
        showTrash={true}
        onDelete={() => {
          onDelete();
        }}
        parameterCount={parameterCount}
        isDraggable={true}
        dragHandleProps={listeners}
        variant="palette"
      />
    </div>
  );
};

const RandomGroupContainer: React.FC<{
  group: RandomGroup;
  children: React.ReactNode;
  isSelected: boolean;
  onSelect: () => void;
  onDelete: () => void;
}> = ({ group, children, isSelected, onSelect, onDelete }) => {
  return (
    <div
      className={`border-2 border-dashed rounded-lg p-4 bg-mint/5 relative transition-all min-h-[120px] w-full max-w-full ${
        isSelected ? "border-mint" : "border-mint/30"
      }`}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
    >
      <div className="flex items-center justify-between mb-4">
        <div className="text-mint text-xs tracking-wider font-medium">
          {group.chance_numerator} in {group.chance_denominator} chance{" "}
          {isSelected && "(SELECTED)"}
        </div>
        <div onClick={(e) => e.stopPropagation()}>
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            className="w-full h-full flex items-center rounded justify-center"
            title="Delete Random Group"
          >
            <XMarkIcon className="h-4 w-4 text-mint/60 hover:text-mint cursor-pointer transition-colors" />
          </button>
        </div>
      </div>
      {children}
    </div>
  );
};

const LoopGroupContainer: React.FC<{
  group: LoopGroup;
  children: React.ReactNode;
  isSelected: boolean;
  onSelect: () => void;
  onDelete: () => void;
}> = ({ group, children, isSelected, onSelect, onDelete }) => {
  return (
    <div
      className={`border-2 border-dashed rounded-lg p-4 bg-mint/5 relative transition-all min-h-[120px] w-full max-w-full ${
        isSelected ? "border-balatro-blue" : "border-balatro-blue/30"
      }`}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
    >
      <div className="flex items-center justify-between mb-4">
        <div className="text-balatro-blue text-xs tracking-wider font-medium">
          Loop {group.repetitions} times{" "}
          {isSelected && "(SELECTED)"}
        </div>
        <div onClick={(e) => e.stopPropagation()}>
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete();
            }}
            className="w-full h-full flex items-center rounded justify-center"
            title="Delete the Loop"
          >
            <XMarkIcon className="h-4 w-4 text-balatro-blue/60 hover:text-balatro-blue cursor-pointer transition-colors" />
          </button>
        </div>
      </div>
      {children}
    </div>
  );
};

const RuleCard: React.FC<RuleCardProps> = ({
  rule,
  ruleIndex,
  selectedItem,
  onSelectItem,
  onDuplicateRule,
  onDeleteRule,
  onDeleteCondition,
  onDeleteConditionGroup,
  onDeleteEffect,
  onAddConditionGroup,
  onToggleBlueprintCompatibility,
  onAddRandomGroup,
  onAddLoop,
  onDeleteRandomGroup,
  onDeleteLoopGroup,
  onToggleGroupOperator,
  onUpdatePosition,
  isRuleSelected,
  generateConditionTitle,
  generateEffectTitle,
  getParameterCount,
  onUpdateConditionOperator,
  itemType,
  onRuleDoubleClick,
}) => {
  const getTrigger =
    itemType === "joker"
      ? getTriggerById
      : itemType === "consumable"
      ? getConsumableTriggerById
      : getCardTriggerById;

  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [groupOperators, setGroupOperators] = useState<Record<string, string>>(
    {}
  );
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({
    x: 0,
    y: 0,
  });

  const transformOffset = isDragging ? dragOffset : { x: 0, y: 0 };

  const handleCardMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  const handleHeaderMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0) {
      e.stopPropagation();
      setIsDragging(true);
      setDragStart({
        x: e.clientX,
        y: e.clientY,
      });
    }
  };

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (isDragging) {
        const deltaX = e.clientX - dragStart.x;
        const deltaY = e.clientY - dragStart.y;
        setDragOffset({ x: deltaX, y: deltaY });
      }
    },
    [isDragging, dragStart]
  );

  const handleMouseUp = useCallback(() => {
    if (isDragging) {
      setIsDragging(false);
      const finalPosition = {
        x: (rule.position?.x || 0) + dragOffset.x,
        y: (rule.position?.y || 0) + dragOffset.y,
      };
      onUpdatePosition(rule.id, finalPosition);
      setDragOffset({ x: 0, y: 0 });
    }
  }, [isDragging, rule.id, rule.position, dragOffset, onUpdatePosition]);

  useEffect(() => {
    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  const trigger = getTrigger(rule.trigger);
  const allConditions = rule.conditionGroups.flatMap(
    (group) => group.conditions
  );
  const totalConditions = allConditions.length;
  const totalEffects =
    rule.effects.length +
    rule.randomGroups.reduce((sum, group) => sum + group.effects.length, 0) +
    rule.loops.reduce((sum, group) => sum + group.effects.length, 0);

  const snapFadeUp = {
    initial: { opacity: 0, y: 15 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -15 },
  };
  const quickFade = {
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
  };
  const slideFromRight = {
    initial: { opacity: 0, x: 20, scale: 0.9 },
    animate: { opacity: 1, x: 0, scale: 1 },
    exit: { opacity: 0, x: 20, scale: 0.9 },
  };
  const cardEntrance = {
    initial: { opacity: 0, scale: 0.95 },
    animate: { opacity: 1, scale: 1 },
  };
  const popIn = {
    initial: { opacity: 0, scale: 0.8, y: 10 },
    animate: { opacity: 1, scale: 1, y: 0 },
    exit: { opacity: 0, scale: 0.8, y: -10 },
  };

  const isItemSelected = (
    type: "trigger" | "condition" | "effect" | "randomgroup" | "loopgroup",
    itemId?: string,
    groupId?: string,
    randomGroupId?: string,
    loopGroupId?: string
  ) => {
    if (!selectedItem || selectedItem.ruleId !== rule.id) return false;
    if (selectedItem.type !== type) return false;
    if (type === "trigger") return true;
    if (type === "condition" && groupId && selectedItem.groupId !== groupId)
      return false;
    if (
      type === "randomgroup" &&
      randomGroupId &&
      selectedItem.randomGroupId !== randomGroupId
    )
      return false;
    if (
      type === "loopgroup" &&
      loopGroupId &&
      selectedItem.loopGroupId !== loopGroupId
    )
      return false;
    if (type === "effect") {
      if (selectedItem.itemId !== itemId) return false;
      if (randomGroupId && selectedItem.randomGroupId !== randomGroupId)
        return false;
      if (!randomGroupId && selectedItem.randomGroupId) return false;
      if (loopGroupId && selectedItem.loopGroupId !== loopGroupId)
        return false;
      if (!loopGroupId && selectedItem.loopGroupId) return false;
      return true;
    }
    return selectedItem.itemId === itemId;
  };

  const isGroupSelected = (groupId: string) => {
    return (
      selectedItem?.ruleId === rule.id && selectedItem?.groupId === groupId
    );
  };
  const isRandomGroupSelected = (randomGroupId: string) => {
    return (
      selectedItem?.ruleId === rule.id &&
      selectedItem?.randomGroupId === randomGroupId
    );
  };
  const isLoopGroupSelected = (loopGroupId: string) => {
    return (
      selectedItem?.ruleId === rule.id &&
      selectedItem?.loopGroupId === loopGroupId
    );
  };

  const handleDuplicateRule = () => onDuplicateRule(rule.id);

  const handleConditionOperatorToggle = (
    groupId: string,
    conditionIndex: number
  ) => {
    const group = rule.conditionGroups.find((g) => g.id === groupId);
    if (group && group.conditions[conditionIndex]) {
      const condition = group.conditions[conditionIndex];
      const newOperator =
        (condition.operator || "and") === "and" ? "or" : "and";
      onUpdateConditionOperator(rule.id, condition.id, newOperator);
    }
  };

  const handleGroupOperatorToggle = (groupIndex: number, groupId: string) => {
    const key = `group-${groupIndex}`;
    const newOperator = (groupOperators[key] || "AND") === "AND" ? "OR" : "AND";
    setGroupOperators((prev) => ({ ...prev, [key]: newOperator }));
    onToggleGroupOperator?.(rule.id, groupId);
  };

  const renderConditionGroup = (group: ConditionGroup, groupIndex: number) => {
    const isSelected = isGroupSelected(group.id);
    return (
      <motion.div
        key={group.id}
        className="relative"
        variants={popIn}
        initial="initial"
        animate="animate"
        transition={{ duration: 0.15, delay: 0.03 }}
      >
        <div
          className={`border-2 border-dashed rounded-lg p-4 bg-black-darker/50 relative ${
            isSelected ? "border-mint" : "border-black-lighter"
          }`}
          onClick={(e) => {
            e.stopPropagation();
            onSelectItem({
              type: "condition",
              ruleId: rule.id,
              groupId: group.id,
            });
          }}
        >
          <div className="flex items-center justify-between mb-10">
            <div className="text-white-darker text-xs tracking-wider">
              CONDITION GROUP {groupIndex + 1} {isSelected && "(SELECTED)"}
            </div>
            <div onClick={(e) => e.stopPropagation()}>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onDeleteConditionGroup(rule.id, group.id);
                }}
                className="w-full h-full flex items-center rounded justify-center"
                title="Delete Condition Group"
              >
                <XMarkIcon className="h-4 w-4 text-white-dark hover:text-white-lighter cursor-pointer transition-colors" />
              </button>
            </div>
          </div>
          <SortableContext
            items={group.conditions.map((c) => c.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-3">
              {group.conditions.map((condition, conditionIndex) => {
                const currentOperator = condition.operator || "and";
                return (
                  <motion.div key={condition.id}>
                    <div onClick={(e) => e.stopPropagation()}>
                      <SortableCondition
                        condition={condition}
                        ruleId={rule.id}
                        groupId={group.id}
                        isSelected={isItemSelected(
                          "condition",
                          condition.id,
                          group.id
                        )}
                        isNegated={condition.negate}
                        onSelect={() =>
                          onSelectItem({
                            type: "condition",
                            ruleId: rule.id,
                            itemId: condition.id,
                            groupId: group.id,
                          })
                        }
                        onDelete={() =>
                          onDeleteCondition(rule.id, condition.id)
                        }
                        parameterCount={getParameterCount(condition.params)}
                        dynamicTitle={generateConditionTitle(condition)}
                        itemType={itemType}
                      />
                    </div>
                    {conditionIndex < group.conditions.length - 1 && (
                      <div
                        className="text-center py-2"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <button
                          onClick={() =>
                            handleConditionOperatorToggle(
                              group.id,
                              conditionIndex
                            )
                          }
                          className="px-3 text-white-darker text-sm font-medium tracking-wider cursor-pointer rounded transition-colors hover:bg-black-light"
                        >
                          {currentOperator.toUpperCase()}
                        </button>
                      </div>
                    )}
                  </motion.div>
                );
              })}
            </div>
          </SortableContext>
        </div>
        {groupIndex < rule.conditionGroups.length - 1 && (
          <div className="text-center py-2">
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleGroupOperatorToggle(groupIndex, group.id);
              }}
              className="px-3 text-white-darker text-sm font-medium tracking-wider cursor-pointer rounded transition-colors hover:bg-black-light"
            >
              {groupOperators[`group-${groupIndex}`] ||
                group.operator?.toUpperCase() ||
                "AND"}
            </button>
          </div>
        )}
      </motion.div>
    );
  };

  const renderRandomGroup = (group: RandomGroup) => {
    return (
      <motion.div
        key={`rg-motion-${group.id}`}
        className="relative"
        variants={popIn}
        initial="initial"
        animate="animate"
        transition={{ duration: 0.15, delay: 0.03 }}
      >
        <RandomGroupContainer
          group={group}
          isSelected={isRandomGroupSelected(group.id)}
          onSelect={() =>
            onSelectItem({
              type: "randomgroup",
              ruleId: rule.id,
              randomGroupId: group.id,
            })
          }
          onDelete={() => onDeleteRandomGroup(rule.id, group.id)}
        >
          <SortableContext
            id={group.id}
            items={group.effects.map((e) => e.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-3">
              {group.effects.map((effect) => (
                <div key={effect.id} onClick={(e) => e.stopPropagation()}>
                  <SortableEffect
                    effect={effect}
                    ruleId={rule.id}
                    isSelected={isItemSelected("effect", effect.id)}
                    onSelect={() =>
                      onSelectItem({
                        type: "effect",
                        ruleId: rule.id,
                        itemId: effect.id,
                      })
                    }
                    onDelete={() => onDeleteEffect(rule.id, effect.id)}
                    parameterCount={getParameterCount(effect.params)}
                    dynamicTitle={generateEffectTitle(effect)}
                    itemType={itemType}
                  />
                </div>
              ))}
            </div>
          </SortableContext>
        </RandomGroupContainer>
      </motion.div>
    );
  };

  const renderLoopGroup = (group: LoopGroup) => {
    return (
      <motion.div
        key={`rg-motion-${group.id}`}
        className="relative"
        variants={popIn}
        initial="initial"
        animate="animate"
        transition={{ duration: 0.15, delay: 0.03 }}
      >
        <LoopGroupContainer
          group={group}
          isSelected={isLoopGroupSelected(group.id)}
          onSelect={() =>
            onSelectItem({
              type: "loopgroup",
              ruleId: rule.id,
              loopGroupId: group.id, ///////
            })
          }
          onDelete={() => onDeleteLoopGroup(rule.id, group.id)}
        >
          <SortableContext
            id={group.id}
            items={group.effects.map((e) => e.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-3">
              {group.effects.map((effect) => (
                <div key={effect.id} onClick={(e) => e.stopPropagation()}>
                  <SortableEffect
                    effect={effect}
                    ruleId={rule.id}
                    isSelected={isItemSelected("effect", effect.id)}
                    onSelect={() =>
                      onSelectItem({
                        type: "effect",
                        ruleId: rule.id,
                        itemId: effect.id,
                      })
                    }
                    onDelete={() => onDeleteEffect(rule.id, effect.id)}
                    parameterCount={getParameterCount(effect.params)}
                    dynamicTitle={generateEffectTitle(effect)}
                    itemType={itemType}
                  />
                </div>
              ))}
            </div>
          </SortableContext>
        </LoopGroupContainer>
      </motion.div>
    );
  };

  return (
    <div
      className="w-80 relative pl-8 select-none"
      style={{
        zIndex: isRuleSelected ? 30 : 20,
        pointerEvents: "auto",
        transform: `translate(${transformOffset.x}px, ${transformOffset.y}px)`,
        cursor: isDragging ? "grabbing" : "default",
      }}
      onClick={(e) => {
        e.stopPropagation();
        onSelectItem({ type: "trigger", ruleId: rule.id });
      }}
      onDoubleClick={(e) => {
        e.stopPropagation();
        onRuleDoubleClick();
      }}
      onMouseDown={handleCardMouseDown}
    >
      <AnimatePresence>
        {sidebarOpen && (
          <motion.div
            className="absolute left-0 top-9 -ml-6 bg-black-dark border-2 border-black-lighter rounded-lg z-20 flex flex-col gap-2 py-2 p-[6px]"
            variants={slideFromRight}
            initial="initial"
            animate="animate"
            exit="exit"
            transition={{ duration: 0.15 }}
          >
            <motion.div
              className="w-8 h-8 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-redshadow"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              transition={{ duration: 0.05 }}
            >
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onDeleteRule(rule.id);
                }}
                className="w-full h-full flex items-center rounded justify-center transition-colors hover:bg-balatro-redshadow active:bg-balatro-blackshadow cursor-pointer"
                title="Delete Rule"
              >
                <TrashIcon className="h-4 w-4 text-balatro-red transition-colors" />
              </button>
            </motion.div>
            <motion.div
              className="w-8 h-8 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-blue"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              transition={{ duration: 0.05 }}
            >
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleDuplicateRule();
                }}
                className="w-full h-full flex items-center rounded justify-center transition-colors hover:bg-balatro-blue/20 cursor-pointer"
                title="Duplicate Rule"
              >
                <DocumentDuplicateIcon className="h-4 w-4 text-balatro-blue" />
              </button>
            </motion.div>
            <motion.div
              className="w-8 h-8 bg-black-darker rounded-lg flex items-center justify-center border-2 border-white-darker"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              transition={{ duration: 0.05 }}
            >
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setSidebarOpen(false);
                }}
                className="w-full h-full flex items-center rounded justify-center transition-colors hover:bg-white-darker/20 cursor-pointer"
                title="Close Menu"
              >
                <XMarkIcon className="h-4 w-4 text-white-darker" />
              </button>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      <motion.div
        className={`w-80 relative`}
        variants={cardEntrance}
        initial="initial"
        animate="animate"
        transition={{ duration: 0.3 }}
      >
        <motion.div
          className="flex justify-center relative"
          variants={snapFadeUp}
          initial="initial"
          animate="animate"
          transition={{ duration: 0.15 }}
          onMouseDown={handleHeaderMouseDown}
          style={{ cursor: isDragging ? "grabbing" : "grab" }}
        >
          <div
            className={`bg-black border-2 rounded-t-md px-8 py-2 pt-1 relative ${
              isRuleSelected ? "border-mint" : "border-black-light"
            } `}
          >
            <span className="text-white-light text-sm tracking-widest">
              Rule {ruleIndex}
            </span>
          </div>
        </motion.div>

        <motion.div
          className={`
            bg-black-dark border-2 rounded-lg overflow-hidden -mt-2 relative
            ${isRuleSelected ? "border-mint" : "border-black-lighter"}
          `}
          style={{ pointerEvents: "auto" }}
          variants={snapFadeUp}
          initial="initial"
          animate="animate"
          transition={{ duration: 0.18, delay: 0.05 }}
        >
          <div
            className="bg-black-darker px-3 py-2 border-b border-black-lighter"
            onMouseDown={handleHeaderMouseDown}
            style={{ cursor: isDragging ? "grabbing" : "grab" }}
          >
            <div className="flex justify-between items-center">
              <motion.button
                onClick={(e) => {
                  e.stopPropagation();
                  setSidebarOpen(!sidebarOpen);
                }}
                className="p-1 text-white-darker hover:bg-black-light rounded transition-colors cursor-pointer"
                title="Open Menu"
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                transition={{ duration: 0.05 }}
              >
                <Bars3Icon className="h-4 w-4" />
              </motion.button>
              <motion.div
                className="flex items-center gap-3"
                variants={quickFade}
                initial="initial"
                animate="animate"
                transition={{ duration: 0.12, delay: 0.08 }}
              >
                {totalConditions > 0 && (
                  <span className="text-white-darker text-xs">
                    {totalConditions} Condition{totalConditions !== 1 && "s"}
                  </span>
                )}
                {totalEffects > 0 && (
                  <span className="text-white-darker text-xs">
                    {totalEffects} Effect{totalEffects !== 1 && "s"}
                  </span>
                )}
                <div className="flex items-center gap-2">
                  {rule.conditionGroups.length > 0 && (
                    <div onClick={(e) => e.stopPropagation()}>
                      <button
                        onClick={() => onAddConditionGroup(rule.id)}
                        className="w-6 h-6 bg-black-darker rounded-lg flex items-center justify-center border-2 border-mint hover:bg-mint/20 transition-colors cursor-pointer"
                        title="Add Condition Group"
                      >
                        <PlusIcon className="h-3 w-3 text-mint" />
                      </button>
                    </div>
                  )}
                  <div onClick={(e) => e.stopPropagation()}>
                    <button
                      onClick={() => onAddLoop(rule.id)}
                      className="w-6 h-6 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-blue hover:bg-effect/20 transition-colors cursor-pointer"
                      title="Add a Loop"
                    >
                      <ArrowPathIcon className="h-3 w-3 text-balatro-blue" />
                    </button>
                  </div>
                  <div onClick={(e) => e.stopPropagation()}>
                    <button
                      onClick={() => onAddRandomGroup(rule.id)}
                      className="w-6 h-6 bg-black-darker rounded-lg flex items-center justify-center border-2 border-effect hover:bg-effect/20 transition-colors cursor-pointer"
                      title="Add Random Group"
                    >
                      <PlusIcon className="h-3 w-3 text-effect" />
                    </button>
                  </div>
                  {itemType === "joker" && (
                    <div onClick={(e) => e.stopPropagation()}>
                      {rule.blueprintCompatible ?? true ? (
                        <button
                          onClick={() =>
                            onToggleBlueprintCompatibility(rule.id)
                          }
                          className="w-6 h-6 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-blue hover:bg-balatro-blue/20 transition-colors cursor-pointer"
                          title="Copied by Blueprint"
                        >
                          <WrenchIcon className="h-3 w-3 text-balatro-blue" />
                        </button>
                      ) : (
                        <button
                          onClick={() =>
                            onToggleBlueprintCompatibility(rule.id)
                          }
                          className="w-6 h-6 bg-black-darker rounded-lg flex items-center justify-center border-2 border-balatro-red hover:bg-balatro-red/20 transition-colors cursor-pointer"
                          title="Not Copied by Blueprint"
                        >
                          <WrenchIcon className="h-3 w-3 text-balatro-red" />
                        </button>
                      )}
                    </div>
                  )}
                </div>
              </motion.div>
            </div>
          </div>

          <motion.div
            className="p-4 space-y-3"
            variants={quickFade}
            initial="initial"
            animate="animate"
            transition={{ duration: 0.15, delay: 0.1 }}
          >
            <motion.div
              variants={snapFadeUp}
              initial="initial"
              animate="animate"
              transition={{ duration: 0.12, delay: 0.12 }}
              className="flex justify-center"
            >
              <BlockComponent
                type="trigger"
                label={trigger?.label || "Unknown Trigger"}
                isSelected={isItemSelected("trigger")}
                onClick={(e) => {
                  e?.stopPropagation();
                  onSelectItem({ type: "trigger", ruleId: rule.id });
                }}
                variant="default"
              />
            </motion.div>

            {(rule.conditionGroups.length > 0 ||
              rule.effects.length > 0 ||
              rule.randomGroups.length > 0 ||
              rule.loops.length > 0
            ) && (
              <motion.div
                className="flex justify-center"
                variants={quickFade}
                initial="initial"
                animate="animate"
                transition={{ duration: 0.1, delay: 0.15 }}
              >
                <ChevronDownIcon className="h-5 w-5 text-white-darker" />
              </motion.div>
            )}

            {rule.conditionGroups.length > 0 && (
              <motion.div
                variants={quickFade}
                initial="initial"
                animate="animate"
                transition={{ duration: 0.1, delay: 0.17 }}
                className="space-y-3"
              >
                {rule.conditionGroups.map((group, index) =>
                  renderConditionGroup(group, index)
                )}
              </motion.div>
            )}

            {(rule.effects.length > 0 || rule.randomGroups.length > 0 || rule.loops.length > 0) &&
              rule.conditionGroups.length > 0 && (
                <motion.div
                  className="flex justify-center"
                  variants={quickFade}
                  initial="initial"
                  animate="animate"
                  transition={{ duration: 0.1, delay: 0.2 }}
                >
                  <ChevronDownIcon className="h-5 w-5 text-white-darker" />
                </motion.div>
              )}

            <motion.div
              className="space-y-3"
              variants={quickFade}
              initial="initial"
              animate="animate"
              transition={{ duration: 0.1, delay: 0.22 }}
            >
              <SortableContext
                items={rule.effects.map((e) => e.id)}
                strategy={verticalListSortingStrategy}
              >
                <div className="space-y-3">
                  {rule.effects.map((effect) => (
                    <div key={effect.id}>
                      <SortableEffect
                        effect={effect}
                        ruleId={rule.id}
                        isSelected={isItemSelected("effect", effect.id)}
                        onSelect={() =>
                          onSelectItem({
                            type: "effect",
                            ruleId: rule.id,
                            itemId: effect.id,
                          })
                        }
                        onDelete={() => onDeleteEffect(rule.id, effect.id)}
                        parameterCount={getParameterCount(effect.params)}
                        dynamicTitle={generateEffectTitle(effect)}
                        itemType={itemType}
                      />
                    </div>
                  ))}
                </div>
              </SortableContext>
            </motion.div>

            <motion.div
              className="space-y-3"
              variants={quickFade}
              initial="initial"
              animate="animate"
              transition={{ duration: 0.1, delay: 0.24 }}
            >
              {rule.randomGroups.map((group) => renderRandomGroup(group))}
            </motion.div>
            <motion.div
              className="space-y-3"
              variants={quickFade}
              initial="initial"
              animate="animate"
              transition={{ duration: 0.1, delay: 0.24 }}
            >
              {rule.loops.map((group) => renderLoopGroup(group))}
            </motion.div>
          </motion.div>
        </motion.div>
      </motion.div>
    </div>
  );
};

export default RuleCard;

```

### src\components\ruleBuilder\types.ts

```
// Rule structure for the Rule Builder: Trigger -> Condition(s) -> Effect(s)
export interface Rule {
  position: { x: number; y: number };
  id: string;
  trigger: string;
  blueprintCompatible: boolean;
  conditionGroups: ConditionGroup[];
  effects: Effect[];
  randomGroups: RandomGroup[];
  loops: LoopGroup[]
}

// A group of effects with shared random chance
export interface RandomGroup {
  id: string;
  chance_numerator: number | string;
  chance_denominator: number | string;
  respect_probability_effects: boolean;
  custom_key: string;
  effects: Effect[];
}

export interface LoopGroup {
  id: string;
  repetitions: number | string;
  effects: Effect[];
}

// A group of conditions with a logical operator (AND/OR)
export interface ConditionGroup {
  id: string;
  operator: string; // "and" or "or"
  conditions: Condition[];
}

// A single condition with parameters
export interface Condition {
  id: string;
  type: string;
  negate: boolean; // For NOT logic
  params: Record<string, unknown>;
  operator?: string;
}

// An effect with parameters
export interface Effect {
  id: string;
  type: string;
  params: Record<string, unknown>;
  customMessage?: string;
}

// Interface for trigger definitions
export interface TriggerDefinition {
  id: string;
  label: string;
  description: string;
  category: string;
}

// When a parameter should be shown based on other parameter values
export interface ShowWhenCondition {
  parameter: string;
  values: string[];
}

// Interface for condition parameter options
export interface ConditionParameterOption {
  value: string;
  label: string;
}

// Interface for condition parameters
export interface ConditionParameter {
  id: string;
  type: "select" | "number" | "range" | "text";
  label: string;
  description?: string;
  options?:
    | ConditionParameterOption[]
    | (() => ConditionParameterOption[])
    | ((parentValues: Record<string, unknown>) => ConditionParameterOption[]);
  min?: number;
  max?: number;
  default?: unknown;
  showWhen?: ShowWhenCondition;
}

// Interface for condition type definitions
export interface ConditionTypeDefinition {
  id: string;
  label: string;
  description: string;
  params: ConditionParameter[];
  applicableTriggers?: string[];
  category: string;
}

// Interface for effect parameter options
export interface EffectParameterOption {
  value: string;
  label: string;
}

// Interface for effect parameters
export interface EffectParameter {
  id: string;
  type: "select" | "number" | "range" | "text";
  label: string;
  description?: string;
  options?:
    | EffectParameterOption[]
    | (() => EffectParameterOption[])
    | ((parentValues: Record<string, unknown>) => EffectParameterOption[]);
  min?: number;
  max?: number;
  default?: unknown;
  showWhen?: ShowWhenCondition;
}

// Interface for effect type definitions
export interface EffectTypeDefinition {
  id: string;
  label: string;
  description: string;
  params: EffectParameter[];
  applicableTriggers?: string[];
  category: string;
}

// Interface for logical operators
export interface LogicalOperator {
  value: string;
  label: string;
}

// Interface for selected items in the rule builder
export type SelectedItem = {
  type: "trigger" | "condition" | "effect" | "randomgroup" | "loopgroup";
  ruleId: string;
  itemId?: string;
  groupId?: string;
  randomGroupId?: string;
  loopGroupId?: string;
} | null;

// Export logical operators
export const LOGICAL_OPERATORS: LogicalOperator[] = [
  { value: "and", label: "AND" },
  { value: "or", label: "OR" },
];

```

### src\components\ruleBuilder\Variables.tsx

```
import React, { useState, useMemo } from "react";
import { useDraggable } from "@dnd-kit/core";
import { ConsumableData, UserVariable } from "../data/BalatroUtils";
import { getVariableUsageDetails } from "../codeGeneration/Jokers/variableUtils";
import {
  SUITS,
  RANKS,
  POKER_HANDS,
  SUIT_VALUES,
  POKER_HAND_VALUES,
} from "../data/BalatroUtils";
import {
  CommandLineIcon,
  XMarkIcon,
  Bars3Icon,
  ExclamationTriangleIcon,
  HashtagIcon,
  SparklesIcon,
  CubeIcon,
  RectangleStackIcon,
} from "@heroicons/react/24/outline";
import { PlusIcon, TrashIcon, PencilIcon } from "@heroicons/react/24/solid";
import InputField from "../generic/InputField";
import InputDropdown from "../generic/InputDropdown";
import Button from "../generic/Button";
import { validateVariableName } from "../generic/validationUtils";
import { ItemData } from "./RuleBuilder";

interface VariablesProps {
  position: { x: number; y: number };
  item: Exclude<ItemData, ConsumableData>;
  onUpdateItem: (updates: Partial<ItemData>) => void;
  onClose: () => void;
  onPositionChange: (position: { x: number; y: number }) => void;
}

const SUIT_OPTIONS = SUITS.map((suit) => ({
  value: suit.value,
  label: `${suit.label}`,
}));

const RANK_OPTIONS = RANKS.map((rank) => ({
  value: rank.label,
  label: rank.label,
}));

const POKER_HAND_OPTIONS = POKER_HANDS.map((hand) => ({
  value: hand.value,
  label: hand.label,
}));

const VARIABLE_TYPE_OPTIONS = [
  { value: "number", label: "Number Variable", icon: HashtagIcon },
  { value: "suit", label: "Suit Variable", icon: SparklesIcon },
  { value: "rank", label: "Rank Variable", icon: CubeIcon },
  {
    value: "pokerhand",
    label: "Poker Hand Variable",
    icon: RectangleStackIcon,
  },
];

type SuitValue = (typeof SUIT_VALUES)[number];
type RankLabel =
  | "2"
  | "3"
  | "4"
  | "5"
  | "6"
  | "7"
  | "8"
  | "9"
  | "10"
  | "Jack"
  | "Queen"
  | "King"
  | "Ace";
type PokerHandValue = (typeof POKER_HAND_VALUES)[number];

const Variables: React.FC<VariablesProps> = ({
  position,
  item,
  onUpdateItem,
  onClose,
}) => {
  const [showAddForm, setShowAddForm] = useState(false);
  const [editingVariable, setEditingVariable] = useState<string | null>(null);
  const [newVariableType, setNewVariableType] = useState<
    "number" | "suit" | "rank" | "pokerhand"
  >("number");
  const [newVariableName, setNewVariableName] = useState("");
  const [newVariableValue, setNewVariableValue] = useState("0");
  const [newVariableSuit, setNewVariableSuit] = useState<SuitValue>(
    SUIT_VALUES[0]
  );
  const [newVariableRank, setNewVariableRank] = useState<RankLabel>("Ace");
  const [newVariablePokerHand, setNewVariablePokerHand] =
    useState<PokerHandValue>(POKER_HAND_VALUES[0]);

  const [nameValidationError, setNameValidationError] = useState<string>("");
  const [editValidationError, setEditValidationError] = useState<string>("");

  const [editingType, setEditingType] = useState<
    "number" | "suit" | "rank" | "pokerhand"
  >("number");
  const [editingName, setEditingName] = useState("");
  const [editingValue, setEditingValue] = useState(0);
  const [editingSuit, setEditingSuit] = useState<SuitValue>(SUIT_VALUES[0]);
  const [editingRank, setEditingRank] = useState<RankLabel>("Ace");
  const [editingPokerHand, setEditingPokerHand] = useState<PokerHandValue>(
    POKER_HAND_VALUES[0]
  );

  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "panel-variables",
  });

  const style = transform
    ? {
        position: "absolute" as const,
        left: position.x + transform.x,
        top: position.y + transform.y,
      }
    : {
        position: "absolute" as const,
        left: position.x,
        top: position.y,
      };

  const usageDetails = useMemo(() => getVariableUsageDetails(item), [item]);
  const userVariables =
    "userVariables" in item &&
    Array.isArray((item as { userVariables: UserVariable[] }).userVariables)
      ? (item as { userVariables: UserVariable[] }).userVariables
      : [];

  const getUsageInfo = (variableName: string) => {
    const usages = usageDetails.filter(
      (usage) => usage.variableName === variableName
    );
    const ruleNumbers = [...new Set(usages.map((usage) => usage.ruleIndex))];
    return {
      count: usages.length,
      rules: ruleNumbers,
    };
  };

  const validateNewVariableName = (name: string) => {
    const validation = validateVariableName(name.trim());
    if (!validation.isValid) {
      setNameValidationError(validation.error || "Invalid variable name");
      return false;
    }

    const existingNames = userVariables.map((v: UserVariable) =>
      v.name.toLowerCase()
    );
    if (existingNames.includes(name.trim().toLowerCase())) {
      setNameValidationError("Variable name already exists");
      return false;
    }

    setNameValidationError("");
    return true;
  };

  const validateEditVariableName = (
    name: string,
    currentVariableId: string
  ) => {
    const validation = validateVariableName(name);
    if (!validation.isValid) {
      setEditValidationError(validation.error || "Invalid variable name");
      return false;
    }

    const existingNames = userVariables
      .filter((v: UserVariable) => v.id !== currentVariableId)
      .map((v: UserVariable) => v.name.toLowerCase());

    if (existingNames.includes(name.toLowerCase())) {
      setEditValidationError("Variable name already exists");
      return false;
    }

    setEditValidationError("");
    return true;
  };

  const handleAddVariable = () => {
    if (!validateNewVariableName(newVariableName)) {
      return;
    }

    const newVariable: UserVariable = {
      id: crypto.randomUUID(),
      name: newVariableName.trim(),
      type: newVariableType,
    };

    if (newVariableType === "number") {
      newVariable.initialValue = parseFloat(newVariableValue) || 0;
    } else if (newVariableType === "suit") {
      newVariable.initialSuit = newVariableSuit;
    } else if (newVariableType === "rank") {
      newVariable.initialRank = newVariableRank;
    } else if (newVariableType === "pokerhand") {
      newVariable.initialPokerHand = newVariablePokerHand;
    }

    const updatedVariables = [...userVariables, newVariable];
    onUpdateItem({ userVariables: updatedVariables });

    setNewVariableName("");
    setNewVariableValue("0");
    setNewVariableSuit(SUIT_VALUES[0]);
    setNewVariableRank("Ace");
    setNewVariablePokerHand(POKER_HAND_VALUES[0]);
    setNewVariableType("number");
    setNameValidationError("");
    setShowAddForm(false);
  };

  const handleDeleteVariable = (variableId: string) => {
    const updatedVariables = userVariables.filter(
      (v: UserVariable) => v.id !== variableId
    );
    onUpdateItem({ userVariables: updatedVariables });
  };

  const handleStartEdit = (variable: UserVariable) => {
    setEditingVariable(variable.id);
    setEditingName(variable.name);
    setEditingType(variable.type || "number");
    setEditingValue(variable.initialValue || 0);
    setEditingSuit((variable.initialSuit as SuitValue) || SUIT_VALUES[0]);
    setEditingRank((variable.initialRank as RankLabel) || "Ace");
    setEditingPokerHand(
      (variable.initialPokerHand) || POKER_HAND_VALUES[0]
    );
    setEditValidationError("");
  };

  const handleSaveEdit = (variableId: string) => {
    if (!validateEditVariableName(editingName, variableId)) {
      return;
    }

    const updatedVariable: UserVariable = {
      id: variableId,
      name: editingName,
      type: editingType,
    };

    if (editingType === "number") {
      updatedVariable.initialValue = editingValue;
    } else if (editingType === "suit") {
      updatedVariable.initialSuit = editingSuit;
    } else if (editingType === "rank") {
      updatedVariable.initialRank = editingRank;
    } else if (editingType === "pokerhand") {
      updatedVariable.initialPokerHand = editingPokerHand;
    }

    const updatedVariables = userVariables.map((v: UserVariable) =>
      v.id === variableId ? updatedVariable : v
    );
    onUpdateItem({ userVariables: updatedVariables });
    setEditingVariable(null);
    setEditValidationError("");
  };

  const handleCancelEdit = () => {
    setEditingVariable(null);
    setEditValidationError("");
  };

  const getVariableDisplayValue = (variable: UserVariable) => {
    if (variable.type === "suit") {
      const suit = variable.initialSuit || SUIT_VALUES[0];
      return suit;
    } else if (variable.type === "rank") {
      const rank = variable.initialRank || "Ace";
      return rank;
    } else if (variable.type === "pokerhand") {
      const pokerHand = variable.initialPokerHand || POKER_HAND_VALUES[0];
      return pokerHand;
    } else {
      return variable.initialValue?.toString() || "0";
    }
  };

  const getVariableIcon = (
    type: "number" | "suit" | "rank" | "pokerhand" | undefined
  ) => {
    switch (type) {
      case "suit":
        return SparklesIcon;
      case "rank":
        return CubeIcon;
      case "pokerhand":
        return RectangleStackIcon;
      default:
        return HashtagIcon;
    }
  };

  const getVariableColor = (
    type: "number" | "suit" | "rank" | "pokerhand" | undefined
  ) => {
    switch (type) {
      case "suit":
        return "text-purple-400";
      case "rank":
        return "text-blue-400";
      case "pokerhand":
        return "text-green-400";
      default:
        return "text-mint";
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="w-80 bg-black-dark backdrop-blur-md border-2 border-black-lighter rounded-lg shadow-2xl z-40"
    >
      <div
        className="flex items-center justify-between p-4 border-b border-black-lighter cursor-grab active:cursor-grabbing"
        {...attributes}
        {...listeners}
      >
        <div className="flex items-center gap-3">
          <Bars3Icon className="h-4 w-4 text-white-darker" />
          <CommandLineIcon className="h-5 w-5 text-white-light" />
          <div>
            <h3 className="text-white-light text-sm font-medium tracking-wider">
              Variables
            </h3>
            <p className="text-white-darker text-xs">
              {userVariables.length} variable
              {userVariables.length !== 1 ? "s" : ""}
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="p-1 text-white-darker hover:text-white transition-colors cursor-pointer"
        >
          <XMarkIcon className="h-4 w-4" />
        </button>
      </div>

      <div className="p-4">
        <div className="max-h-96 overflow-y-auto custom-scrollbar space-y-2 mb-4">
          {userVariables.length === 0 && !showAddForm ? (
            <div className="text-center py-8">
              <CommandLineIcon className="h-12 w-12 text-white-darker mx-auto mb-3 opacity-50" />
              <p className="text-white-darker text-sm">
                No variables created yet
              </p>
              <p className="text-white-darker text-xs mt-1">
                Create variables to store and modify values in your joker
              </p>
            </div>
          ) : (
            userVariables.map((variable) => {
              const usageInfo = getUsageInfo(variable.name);
              const isEditing = editingVariable === variable.id;
              const VariableIcon = getVariableIcon(variable.type);
              const colorClass = getVariableColor(variable.type);

              return (
                <div
                  key={variable.id}
                  className="bg-black-darker border border-black-lighter rounded-lg p-3"
                >
                  {isEditing ? (
                    <div className="space-y-3">
                      <div>
                        <InputField
                          value={editingName}
                          onChange={(e) => {
                            setEditingName(e.target.value);
                            if (editValidationError) {
                              validateEditVariableName(
                                e.target.value,
                                variable.id
                              );
                            }
                          }}
                          label="Name"
                          size="sm"
                        />
                        {editValidationError && (
                          <div className="flex items-center gap-2 mt-1 text-balatro-red text-sm">
                            <ExclamationTriangleIcon className="h-4 w-4" />
                            <span>{editValidationError}</span>
                          </div>
                        )}
                      </div>

                      <InputDropdown
                        label="Type"
                        value={editingType}
                        onChange={(value) =>
                          setEditingType(
                            value as "number" | "suit" | "rank" | "pokerhand"
                          )
                        }
                        options={VARIABLE_TYPE_OPTIONS}
                        size="sm"
                      />

                      {editingType === "number" && (
                        <InputField
                          value={editingValue.toString()}
                          onChange={(e) => {
                            const value = parseFloat(e.target.value) || 0;
                            setEditingValue(value);
                          }}
                          type="number"
                          label="Initial Value"
                          size="sm"
                        />
                      )}

                      {editingType === "suit" && (
                        <InputDropdown
                          label="Initial Suit"
                          value={editingSuit}
                          onChange={(value) =>
                            setEditingSuit(value as SuitValue)
                          }
                          options={SUIT_OPTIONS}
                          size="sm"
                        />
                      )}

                      {editingType === "rank" && (
                        <InputDropdown
                          label="Initial Rank"
                          value={editingRank}
                          onChange={(value) =>
                            setEditingRank(value as RankLabel)
                          }
                          options={RANK_OPTIONS}
                          size="sm"
                        />
                      )}

                      {editingType === "pokerhand" && (
                        <InputDropdown
                          label="Initial Poker Hand"
                          value={editingPokerHand}
                          onChange={(value) =>
                            setEditingPokerHand(value as PokerHandValue)
                          }
                          options={POKER_HAND_OPTIONS}
                          size="sm"
                        />
                      )}

                      <div className="flex gap-2">
                        <Button
                          variant="primary"
                          size="sm"
                          onClick={() => handleSaveEdit(variable.id)}
                          disabled={!!editValidationError}
                          className="cursor-pointer flex-1"
                        >
                          Save
                        </Button>
                        <Button
                          variant="secondary"
                          size="sm"
                          onClick={handleCancelEdit}
                          className="cursor-pointer"
                        >
                          Cancel
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <div>
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <VariableIcon className={`h-4 w-4 ${colorClass}`} />
                          <span
                            className={`text-sm font-mono font-medium ${colorClass}`}
                          >
                            ${variable.name}
                          </span>
                        </div>

                        <div className="flex items-center gap-1">
                          <button
                            onClick={() => handleStartEdit(variable)}
                            className="p-1 text-white-darker hover:text-white transition-colors cursor-pointer"
                            title="Edit"
                          >
                            <PencilIcon className="h-3 w-3" />
                          </button>
                          <button
                            onClick={() => handleDeleteVariable(variable.id)}
                            className="p-1 text-balatro-red hover:text-white transition-colors cursor-pointer"
                            title="Delete"
                          >
                            <TrashIcon className="h-3 w-3" />
                          </button>
                        </div>
                      </div>

                      <div className="flex items-center justify-between text-sm">
                        <span className="text-white-darker">
                          {variable.type === "number" ? "Initial:" : "Value:"}{" "}
                          {getVariableDisplayValue(variable)}
                        </span>
                        {usageInfo.count > 0 && (
                          <div className="flex items-center gap-1">
                            <span className="text-white-darker text-xs">
                              Used in:
                            </span>
                            {usageInfo.rules.map((ruleNum) => (
                              <span
                                key={ruleNum}
                                className={
                                  "bg-opacity-20 text-xs px-1.5 py-0.5 rounded text-white"
                                }
                              >
                                {ruleNum + 1}
                              </span>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              );
            })
          )}

          {showAddForm && (
            <div className="bg-black-darker border-2 border-mint/50 rounded-lg p-3">
              <div className="space-y-3">
                <div>
                  <InputField
                    value={newVariableName}
                    onChange={(e) => {
                      setNewVariableName(e.target.value);
                      validateNewVariableName(e.target.value);
                    }}
                    placeholder="myVariable"
                    label="Name"
                    size="sm"
                  />
                  {nameValidationError && (
                    <div className="flex items-center gap-2 mt-1 text-balatro-red text-sm">
                      <ExclamationTriangleIcon className="h-4 w-4" />
                      <span>{nameValidationError}</span>
                    </div>
                  )}
                </div>

                <InputDropdown
                  label="Type"
                  value={newVariableType}
                  onChange={(value) =>
                    setNewVariableType(
                      value as "number" | "suit" | "rank" | "pokerhand"
                    )
                  }
                  options={VARIABLE_TYPE_OPTIONS}
                  size="sm"
                />

                {newVariableType === "number" && (
                  <InputField
                    value={newVariableValue}
                    onChange={(e) => setNewVariableValue(e.target.value)}
                    placeholder="0"
                    label="Initial Value"
                    type="number"
                    size="sm"
                  />
                )}

                {newVariableType === "suit" && (
                  <InputDropdown
                    label="Initial Suit"
                    value={newVariableSuit}
                    onChange={(value) => setNewVariableSuit(value as SuitValue)}
                    options={SUIT_OPTIONS}
                    size="sm"
                  />
                )}

                {newVariableType === "rank" && (
                  <InputDropdown
                    label="Initial Rank"
                    value={newVariableRank}
                    onChange={(value) => setNewVariableRank(value as RankLabel)}
                    options={RANK_OPTIONS}
                    size="sm"
                  />
                )}

                {newVariableType === "pokerhand" && (
                  <InputDropdown
                    label="Initial Poker Hand"
                    value={newVariablePokerHand}
                    onChange={(value) =>
                      setNewVariablePokerHand(value as PokerHandValue)
                    }
                    options={POKER_HAND_OPTIONS}
                    size="sm"
                  />
                )}

                <div className="flex gap-2">
                  <Button
                    variant="primary"
                    size="sm"
                    onClick={handleAddVariable}
                    disabled={!newVariableName.trim() || !!nameValidationError}
                    className="cursor-pointer flex-1"
                  >
                    Create
                  </Button>
                  <Button
                    variant="secondary"
                    size="sm"
                    onClick={() => {
                      setShowAddForm(false);
                      setNewVariableName("");
                      setNewVariableValue("0");
                      setNewVariableSuit(SUIT_VALUES[0]);
                      setNewVariableRank("Ace");
                      setNewVariablePokerHand(POKER_HAND_VALUES[0]);
                      setNewVariableType("number");
                      setNameValidationError("");
                    }}
                    className="cursor-pointer"
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            </div>
          )}
        </div>

        {!showAddForm && (
          <Button
            variant="secondary"
            size="sm"
            fullWidth
            onClick={() => setShowAddForm(true)}
            icon={<PlusIcon className="h-4 w-4" />}
            className="cursor-pointer"
          >
            Add Variable
          </Button>
        )}
      </div>
    </div>
  );
};

export default Variables;

```

### src\components\Sidebar.tsx

```
import React, { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  HomeIcon,
  DocumentTextIcon,
  PuzzlePieceIcon,
  FolderIcon,
  //HeartIcon,
  ArrowUpTrayIcon,
  ArrowDownTrayIcon,
  BookmarkIcon,
  CodeBracketIcon,
  LinkIcon,
  CakeIcon,
  ChatBubbleLeftRightIcon,
  GiftIcon,
  StarIcon,
  CpuChipIcon,
  ChevronDownIcon,
  EllipsisHorizontalIcon,
  KeyIcon,
  SparklesIcon,
  MusicalNoteIcon,
} from "@heroicons/react/24/solid";
import { JokerData } from "./data/BalatroUtils";

interface SidebarProps {
  selectedSection?: string;
  onSectionChange?: (section: string) => void;
  projectName?: string;
  onExport?: () => Promise<void>;
  onExportJSON?: () => void;
  onImportJSON?: () => Promise<void>;
  exportLoading?: boolean;
  jokers?: JokerData[];
  modName?: string;
  authorName?: string;
}

const Sidebar: React.FC<SidebarProps> = ({
  selectedSection = "overview",
  onSectionChange,
  projectName = "mycustommod",
  onExport,
  onExportJSON,
  onImportJSON,
  exportLoading = false,
}) => {
  const isExpanded =
    selectedSection === "overview" ||
    selectedSection === "" ||
    !selectedSection;
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  const version: string = "v0.6.4";

  const handleSectionClick = (section: string) => {
    if (section === "github") {
      window.open("https://github.com/Jayd-H/joker-forge", "_blank");
      return;
    }

    if (section === "docs") {
      window.open("https://github.com/Jayd-H/joker-forge/wiki", "_blank");
      return;
    }

    if (section === "discord") {
      window.open("https://discord.gg/eRBByq9AZX", "_blank");
      return;
    }

    //if (section === "support") {
    //  window.open("https://ko-fi.com/jaydchw", "_blank");
    //  return;
    //}

    onSectionChange?.(section);
  };

  const handleExport = async () => {
    if (onExport) {
      await onExport();
    }
  };

  const handleExportJSON = () => {
    if (onExportJSON) {
      onExportJSON();
    }
  };

  const handleImportJSON = async () => {
    if (onImportJSON) {
      await onImportJSON();
    }
  };

  const navigationItems = [
    { id: "overview", label: "Overview", icon: HomeIcon },
    { id: "metadata", label: "Mod Metadata", icon: DocumentTextIcon },
    { id: "jokers", label: "Jokers", icon: PuzzlePieceIcon },
    { id: "consumables", label: "Consumables", icon: CakeIcon },
    { id: "boosters", label: "Booster Packs", icon: GiftIcon },
    { id: "enhancements", label: "Enhancements", icon: StarIcon },
    { id: "seals", label: "Seals", icon: CpuChipIcon },
    { id: "editions", label: "Editions", icon: SparklesIcon },
    { id: "sounds", label: "Sounds", icon: MusicalNoteIcon },
  ];

  const visibleResourceItems = [
    //{ id: "support", label: "Support", icon: HeartIcon },
    { id: "vanilla", label: "Vanilla Reforged", icon: FolderIcon },
  ];

  const dropdownResourceItems = [
    { id: "docs", label: "Docs", icon: DocumentTextIcon },
    { id: "github", label: "GitHub Repository", icon: LinkIcon },
    { id: "discord", label: "Discord Server", icon: ChatBubbleLeftRightIcon },
    { id: "acknowledgements", label: "Acknowledgements", icon: StarIcon },
    { id: "keys", label: "Keys Reference", icon: KeyIcon },
  ];

  const actionItems = [
    {
      id: "import",
      label: "Import Mod",
      icon: ArrowDownTrayIcon,
      onClick: handleImportJSON,
      disabled: false,
    },
    {
      id: "save",
      label: "Save Mod",
      icon: BookmarkIcon,
      onClick: handleExportJSON,
      disabled: false,
    },
    {
      id: "export",
      label: exportLoading ? "Exporting..." : "Export Mod",
      icon: ArrowUpTrayIcon,
      onClick: handleExport,
      disabled: exportLoading,
    },
  ];

  if (isExpanded) {
    return (
      <motion.div
        key="expanded"
        initial={{ width: 80 }}
        animate={{ width: 320 }}
        exit={{ width: 80 }}
        transition={{
          type: "spring",
          stiffness: 400,
          damping: 40,
          mass: 1,
        }}
        className="w-80 rounded-xl m-4 flex flex-col font-lexend"
      >
        <div className="p-6">
          <div className="flex gap-3 justify-center -ml-6">
            <div className="w-6 h-6 rounded-lg flex items-center my-auto justify-center">
              <CodeBracketIcon className="h-5 w-5 text-white" />
            </div>
            <motion.h1
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.1 }}
              className="text-white font-light tracking-widest"
            >
              Joker Forge
            </motion.h1>
          </div>
        </div>

        <div className="border-b -mt-1 mb-2 border-black-light"></div>

        <div className="flex-1 flex flex-col">
          <nav className="flex-1 px-4">
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.1 }}
              className="flex justify-between py-3"
            >
              <div className="text-xs text-white-darker tracking-wider uppercase">
                Project
              </div>
              <div className="text-xs text-white-dark tracking-widest">
                {projectName}
              </div>
            </motion.div>

            <div className="space-y-2">
              {navigationItems.map((item, index) => {
                const Icon = item.icon;
                const isActive = selectedSection === item.id;

                return (
                  <motion.button
                    key={item.id}
                    initial={{ opacity: 0, x: -10 }}
                    animate={{ opacity: 1, x: 0 }}
                    transition={{ delay: 0.05 * index }}
                    onClick={() => handleSectionClick(item.id)}
                    className={`w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors cursor-pointer ${
                      isActive
                        ? "bg-mint-light text-black-dark font-medium"
                        : "text-white-light hover:bg-black-light hover:text-white-lighter"
                    }`}
                  >
                    <Icon className="h-5 w-5 flex-shrink-0" />
                    <span className="text-sm tracking-wide">{item.label}</span>
                  </motion.button>
                );
              })}
            </div>

            <div className="mt-8">
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="text-xs text-white-darker mb-3 tracking-wider uppercase"
              >
                Resources
              </motion.div>
              <div className="space-y-1">
                {visibleResourceItems.map((item, index) => {
                  const Icon = item.icon;
                  const isActive = selectedSection === item.id;

                  return (
                    <motion.button
                      key={item.id}
                      initial={{ opacity: 0, x: -10 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: 0.25 + 0.05 * index }}
                      onClick={() => handleSectionClick(item.id)}
                      className={`w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors cursor-pointer ${
                        isActive
                          ? "bg-mint-light text-black-dark font-medium"
                          : "text-white-dark hover:text-white-light hover:bg-black-light"
                      }`}
                    >
                      <Icon
                        className={`h-4 w-4 flex-shrink-0 ${
                          item.id === "vanilla" && !isActive
                            ? "text-mint-light"
                            : ""
                        }`}
                      />
                      <span className="text-sm tracking-wide">
                        {item.label}
                      </span>
                    </motion.button>
                  );
                })}

                <motion.div
                  initial={{ opacity: 0, x: -10 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: 0.35 }}
                  className="relative"
                >
                  <button
                    onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                    className="w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors cursor-pointer text-white-dark hover:text-white-light hover:bg-black-light"
                  >
                    <EllipsisHorizontalIcon className="h-4 w-4 flex-shrink-0" />
                    <span className="text-sm tracking-wide">More</span>
                    <motion.div
                      animate={{ rotate: isDropdownOpen ? 180 : 0 }}
                      transition={{ duration: 0.2 }}
                      className="ml-auto"
                    >
                      <ChevronDownIcon className="h-4 w-4" />
                    </motion.div>
                  </button>

                  <AnimatePresence>
                    {isDropdownOpen && (
                      <motion.div
                        initial={{ opacity: 0, height: 0 }}
                        animate={{ opacity: 1, height: "auto" }}
                        exit={{ opacity: 0, height: 0 }}
                        transition={{ duration: 0.2 }}
                        className="overflow-hidden"
                      >
                        <div className="pl-4 pt-1 space-y-1">
                          {dropdownResourceItems.map((item, index) => {
                            const Icon = item.icon;
                            const isActive = selectedSection === item.id;

                            return (
                              <motion.button
                                key={item.id}
                                initial={{ opacity: 0, x: -10 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ delay: 0.05 * index }}
                                onClick={() => handleSectionClick(item.id)}
                                className={`w-full flex items-center gap-3 px-3 py-2 rounded-lg text-left transition-colors cursor-pointer ${
                                  isActive
                                    ? "bg-mint-light text-black-dark font-medium"
                                    : "text-white-darker hover:text-white-light hover:bg-black-light"
                                }`}
                              >
                                <Icon className="h-4 w-4 flex-shrink-0" />
                                <span className="text-sm tracking-wide">
                                  {item.label}
                                </span>
                              </motion.button>
                            );
                          })}
                        </div>
                      </motion.div>
                    )}
                  </AnimatePresence>
                </motion.div>
              </div>
            </div>
          </nav>

          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
            className="p-4 border-t border-black-light space-y-3"
          >
            <button
              onClick={handleImportJSON}
              className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-black-darker border-2 border-black-lighter rounded-lg text-white-light hover:border-mint hover:text-mint transition-colors cursor-pointer"
            >
              <ArrowDownTrayIcon className="h-4 w-4" />
              <span className="text-sm font-medium tracking-wide">
                Import Mod{" "}
              </span>
              <span className="text-xs">(JOKERFORGE)</span>
            </button>

            <button
              onClick={handleExportJSON}
              className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-black-darker border-2 border-black-lighter rounded-lg text-white-light hover:border-mint hover:text-mint transition-colors cursor-pointer"
            >
              <BookmarkIcon className="h-4 w-4" />
              <span className="text-sm font-medium tracking-wide">
                Save Mod
              </span>
              <span className="text-xs">(JOKERFORGE)</span>
            </button>

            <button
              onClick={handleExport}
              disabled={exportLoading}
              className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-black-darker border-2 border-mint-dark rounded-lg text-mint-light hover:text-black-dark font-medium hover:bg-mint hover:border-mint-darker transition-colors cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <ArrowUpTrayIcon className="h-4 w-4" />
              <span className="text-sm tracking-wide">
                {exportLoading ? "Exporting..." : "Export Mod Files"}
              </span>
            </button>

            <div className="text-center mt-4">
              <span className="text-xs text-mint font-medium tracking-widest">
                {version}
              </span>
            </div>
          </motion.div>
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      key="collapsed"
      initial={{ width: 320 }}
      animate={{ width: 80 }}
      exit={{ width: 320 }}
      transition={{
        type: "spring",
        stiffness: 400,
        damping: 40,
        mass: 1,
      }}
      className="w-20 rounded-xl m-4 flex flex-col font-lexend relative"
    >
      <div className="p-4 flex justify-center">
        <div className="w-6 h-6 rounded-lg flex items-center justify-center">
          <CodeBracketIcon className="h-5 w-5 text-white" />
        </div>
      </div>

      <div className="flex-1 flex flex-col">
        <nav className="flex-1 px-3">
          <div className="space-y-2">
            {navigationItems.map((item, index) => {
              const Icon = item.icon;
              const isActive = selectedSection === item.id;
              const isHovered = hoveredItem === item.id;

              return (
                <div key={item.id} className="relative">
                  <motion.button
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 1, scale: 1 }}
                    transition={{ delay: 0.05 * index }}
                    onClick={() => handleSectionClick(item.id)}
                    onMouseEnter={() => setHoveredItem(item.id)}
                    onMouseLeave={() => setHoveredItem(null)}
                    className={`w-full flex items-center justify-center px-3 py-3 rounded-lg transition-colors cursor-pointer ${
                      isActive
                        ? "bg-mint-light text-black-dark font-medium"
                        : "text-white-light hover:bg-black-light hover:text-white-lighter"
                    }`}
                  >
                    <Icon className="h-5 w-5" />
                  </motion.button>

                  <AnimatePresence>
                    {isHovered && (
                      <motion.div
                        initial={{ opacity: 0, x: -10, scale: 0.9 }}
                        animate={{ opacity: 1, x: 0, scale: 1 }}
                        exit={{ opacity: 0, x: -10, scale: 0.9 }}
                        transition={{
                          type: "spring",
                          stiffness: 500,
                          damping: 30,
                        }}
                        className="absolute left-full top-1/2 transform -translate-y-1/2 ml-2 z-50"
                      >
                        <div className="bg-black-dark border border-black-lighter rounded-lg px-3 py-2 shadow-lg">
                          <span className="text-sm text-white-light tracking-wide whitespace-nowrap">
                            {item.label}
                          </span>
                        </div>
                      </motion.div>
                    )}
                  </AnimatePresence>
                </div>
              );
            })}
          </div>

          <div className="mt-6">
            <div className="space-y-1">
              {visibleResourceItems.map((item, index) => {
                const Icon = item.icon;
                const isActive = selectedSection === item.id;
                const isHovered = hoveredItem === item.id;

                return (
                  <div key={item.id} className="relative">
                    <motion.button
                      initial={{ opacity: 0, scale: 0.8 }}
                      animate={{ opacity: 1, scale: 1 }}
                      transition={{ delay: 0.2 + 0.05 * index }}
                      onClick={() => handleSectionClick(item.id)}
                      onMouseEnter={() => setHoveredItem(item.id)}
                      onMouseLeave={() => setHoveredItem(null)}
                      className={`w-full flex items-center justify-center px-3 py-3 rounded-lg transition-colors cursor-pointer ${
                        isActive
                          ? "bg-mint-light text-black-dark font-medium"
                          : "text-white-dark hover:text-white-light hover:bg-black-light"
                      }`}
                    >
                      <Icon
                        className={`h-4 w-4 ${
                          item.id === "vanilla" && !isActive
                            ? "text-mint-light"
                            : ""
                        }`}
                      />
                    </motion.button>

                    <AnimatePresence>
                      {isHovered && (
                        <motion.div
                          initial={{ opacity: 0, x: -10, scale: 0.9 }}
                          animate={{ opacity: 1, x: 0, scale: 1 }}
                          exit={{ opacity: 0, x: -10, scale: 0.9 }}
                          transition={{
                            type: "spring",
                            stiffness: 500,
                            damping: 30,
                          }}
                          className="absolute left-full top-1/2 transform -translate-y-1/2 ml-2 z-50"
                        >
                          <div className="bg-black-dark border border-black-lighter rounded-lg px-3 py-2 shadow-lg">
                            <span className="text-sm text-white-light tracking-wide whitespace-nowrap">
                              {item.label}
                            </span>
                          </div>
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </div>
                );
              })}

              <div className="relative">
                <motion.button
                  initial={{ opacity: 0, scale: 0.8 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ delay: 0.3 }}
                  onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                  onMouseEnter={() => setHoveredItem("more")}
                  onMouseLeave={() => setHoveredItem(null)}
                  className="w-full flex items-center justify-center px-3 py-3 rounded-lg transition-colors cursor-pointer text-white-dark hover:text-white-light hover:bg-black-light"
                >
                  <EllipsisHorizontalIcon className="h-4 w-4" />
                </motion.button>

                <AnimatePresence>
                  {hoveredItem === "more" && (
                    <motion.div
                      initial={{ opacity: 0, x: -10, scale: 0.9 }}
                      animate={{ opacity: 1, x: 0, scale: 1 }}
                      exit={{ opacity: 0, x: -10, scale: 0.9 }}
                      transition={{
                        type: "spring",
                        stiffness: 500,
                        damping: 30,
                      }}
                      className="absolute left-full top-1/2 transform -translate-y-1/2 ml-2 z-50"
                    >
                      <div className="bg-black-dark border border-black-lighter rounded-lg px-3 py-2 shadow-lg">
                        <span className="text-sm text-white-light tracking-wide whitespace-nowrap">
                          More Resources
                        </span>
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>

                <AnimatePresence>
                  {isDropdownOpen && (
                    <motion.div
                      initial={{ opacity: 0, scale: 0.9, x: -10 }}
                      animate={{ opacity: 1, scale: 1, x: 0 }}
                      exit={{ opacity: 0, scale: 0.9, x: -10 }}
                      transition={{
                        type: "spring",
                        stiffness: 500,
                        damping: 30,
                      }}
                      className="absolute left-full top-0 ml-2 z-50"
                    >
                      <div className="bg-black-dark border border-black-lighter rounded-lg shadow-lg overflow-hidden">
                        {dropdownResourceItems.map((item) => {
                          const Icon = item.icon;
                          const isActive = selectedSection === item.id;

                          return (
                            <button
                              key={item.id}
                              onClick={() => {
                                handleSectionClick(item.id);
                                setIsDropdownOpen(false);
                              }}
                              className={`w-full flex items-center gap-3 px-4 py-3 text-left transition-colors cursor-pointer whitespace-nowrap ${
                                isActive
                                  ? "bg-mint-light text-black-dark font-medium"
                                  : "text-white-light hover:bg-black-light hover:text-white-lighter"
                              }`}
                            >
                              <Icon className="h-4 w-4 flex-shrink-0" />
                              <span className="text-sm tracking-wide">
                                {item.label}
                              </span>
                            </button>
                          );
                        })}
                      </div>
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            </div>
          </div>
        </nav>

        <div className="px-3 pb-4 border-t border-black-light pt-4 mt-4">
          <div className="space-y-2">
            {actionItems.map((item, index) => {
              const Icon = item.icon;
              const isHovered = hoveredItem === item.id;

              return (
                <div key={item.id} className="relative">
                  <motion.button
                    initial={{ opacity: 0, scale: 0.8 }}
                    animate={{ opacity: 1, scale: 1 }}
                    transition={{ delay: 0.4 + 0.05 * index }}
                    onClick={item.onClick}
                    onMouseEnter={() => setHoveredItem(item.id)}
                    onMouseLeave={() => setHoveredItem(null)}
                    disabled={item.disabled}
                    className={`w-full flex items-center justify-center px-3 py-3 rounded-lg transition-colors cursor-pointer ${
                      item.disabled
                        ? "text-white-darker opacity-50 cursor-not-allowed"
                        : item.id === "export"
                        ? "text-mint-light hover:bg-mint-dark hover:text-black-darker"
                        : "text-white-light hover:bg-black-light hover:text-white-lighter"
                    }`}
                  >
                    <Icon className="h-4 w-4" />
                  </motion.button>

                  <AnimatePresence>
                    {isHovered && !item.disabled && (
                      <motion.div
                        initial={{ opacity: 0, x: -10, scale: 0.9 }}
                        animate={{ opacity: 1, x: 0, scale: 1 }}
                        exit={{ opacity: 0, x: -10, scale: 0.9 }}
                        transition={{
                          type: "spring",
                          stiffness: 500,
                          damping: 30,
                        }}
                        className="absolute left-full top-1/2 transform -translate-y-1/2 ml-2 z-50"
                      >
                        <div className="bg-black-dark border border-black-lighter rounded-lg px-3 py-2 shadow-lg">
                          <span className="text-sm text-white-light tracking-wide whitespace-nowrap">
                            {item.label}
                          </span>
                        </div>
                      </motion.div>
                    )}
                  </AnimatePresence>
                </div>
              );
            })}
          </div>

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5 }}
            className="text-center mt-4"
          >
            <span className="text-xs text-mint font-medium tracking-widest">
              {version}
            </span>
          </motion.div>
        </div>
      </div>
    </motion.div>
  );
};

export default Sidebar;

```

### src\index.css

```
@import url("https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap");
@import "tailwindcss";

@font-face {
  font-family: "m6x11plus";
  src: url("/fonts/m6x11plus.ttf") format("truetype");
}

body {
  background-color: #1e2b30;
  margin: 0;
  padding: 0;
}

html {
  background-color: #1e2b30;
}

@theme {
  --color-balatro-mult: #fe5f55;
  --color-balatro-chips: #009dff;
  --color-balatro-money: #f3b958;
  --color-balatro-attention: #ff9a00;
  --color-balatro-orange: #fda200;
  --color-balatro-gold: #eac058;
  --color-balatro-black: #374244;
  --color-balatro-light-black: #4f6367;
  --color-balatro-grey: #5f7377;
  --color-balatro-joker: #708b91;
  --color-balatro-tarot: #a782d1;
  --color-balatro-planet: #13afce;
  --color-balatro-spectral: #4584fa;
  --color-balatro-voucher: #fd682b;
  --color-balatro-edition: #4ca893;
  --color-balatro-enhanced: #8389dd;
  --color-balatro-red: #ff4c40;
  --color-balatro-redshadow: #a92b23;
  --color-balatro-blue: #009dff;
  --color-balatro-blueshadow: #005caa;
  --color-balatro-green: #35bd86;
  --color-balatro-greenshadow: #1b7954;
  --color-balatro-purple: #aa5bb5;
  --color-balatro-purpleshadow: #6d3574;
  --color-balatro-transparentblack: #00000060;
  --color-balatro-lightgrey: #b9c2d2;
  --color-balatro-lightgreyshadow: #777e89;
  --color-balatro-whiteshadow: #aaaaaa;
  --color-balatro-buttonshadow: #1e2f32;
  --color-balatro-blackshadow: #0b1415;
  --color-balatro-white: #ffffff;

  /* High contrast suit colors */
  --color-balatro-hearts: #fa2315;
  --color-balatro-clubs: #0081e6;
  --color-balatro-diamonds: #e18400;
  --color-balatro-spades: #3a17b3;

  --color-balatro-common: #0093ff;
  --color-balatro-uncommon: #35bd86;
  --color-balatro-rare: #ff4c40;
  --color-balatro-legendary: #aa5bb5;
  --color-balatro-enhanced-new: #757cdc;
  --color-balatro-edition-new: #fff5ce;
  --color-balatro-dark-edition: #6a6aed;
  --color-balatro-gold-new: #eaba44;
  --color-balatro-default: #3a5055;

  --color-mint-lighter: #6cb79a;
  --color-mint-light: #59a487;
  --color-mint: #469274;
  --color-mint-dark: #3c7f65;
  --color-mint-darker: #336d57;

  --color-white-lighter: #d8dfe8;
  --color-white-light: #cbd3de;
  --color-white: #bec7d4;
  --color-white-dark: #aab4c2;
  --color-white-darker: #96a1b0;

  --color-black-lighter: #3a4c53;
  --color-black-light: #2f4047;
  --color-black: #26353b;
  --color-black-dark: #1e2b30;
  --color-black-darker: #161e21;

  --color-effect: #c0a435;
  --color-condition: #1d7bde;
  --color-trigger: #31b166;

  --color-effect-dark: #9a8029;
  --color-condition-dark: #155bb8;
  --color-trigger-dark: #268a52;

  /* Cost display colors */
  --color-cost-border: #1e292c;
  --color-cost-bg: #2e393d;
  --color-cost-text: #e3af3e;
  --color-cost-shadow: #1c2225;

  /* Font family */
  --font-game: "m6x11plus", sans-serif;
  --font-lexend: "Lexend", sans-serif;
}

@layer utilities {
  .shadow-lightgrey {
    box-shadow: 0 8px 0 -2px var(--color-balatro-lightgreyshadow);
    transform: translateY(-4px);
    margin-bottom: 4px;
  }

  .shadow-red {
    box-shadow: 0 8px 0 -2px var(--color-balatro-redshadow);
    transform: translateY(-4px);
    margin-bottom: 4px;
  }

  .shadow-black {
    box-shadow: 0 8px 0 -2px var(--color-balatro-black);
    transform: translateY(-4px);
    margin-bottom: 4px;
  }

  .shadow-cardholder {
    box-shadow: 0 8px 0 -2px var(--color-balatro-blackshadow);
    transform: translateY(-4px);
    margin-bottom: 4px;
  }

  .shadow-button {
    box-shadow: 0 8px 0 -2px var(--color-balatro-buttonshadow);
    transform: translateY(-4px);
    margin-bottom: 4px;
  }

  .text-shadow-pixel {
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.5);
  }

  .text-shadow-cost {
    text-shadow: 0 1px 2px var(--color-cost-shadow);
  }

  .pixelated {
    image-rendering: pixelated;
  }

  .pixel-corners {
    clip-path: polygon(
      0px calc(100% - 24px),
      6px calc(100% - 24px),
      6px calc(100% - 12px),
      12px calc(100% - 12px),
      12px calc(100% - 6px),
      24px calc(100% - 6px),
      24px 100%,
      calc(100% - 24px) 100%,
      calc(100% - 24px) calc(100% - 6px),
      calc(100% - 12px) calc(100% - 6px),
      calc(100% - 12px) calc(100% - 12px),
      calc(100% - 6px) calc(100% - 12px),
      calc(100% - 6px) calc(100% - 24px),
      100% calc(100% - 24px),
      100% 24px,
      calc(100% - 6px) 24px,
      calc(100% - 6px) 12px,
      calc(100% - 12px) 12px,
      calc(100% - 12px) 6px,
      calc(100% - 24px) 6px,
      calc(100% - 24px) 0px,
      24px 0px,
      24px 6px,
      12px 6px,
      12px 12px,
      6px 12px,
      6px 24px,
      0px 24px
    );
  }

  .pixel-corners-small {
    clip-path: polygon(
      0px calc(100% - 8px),
      0px calc(100% - 4px),
      4px calc(100% - 4px),
      4px 100%,
      calc(100% - 4px) 100%,
      calc(100% - 4px) calc(100% - 4px),
      100% calc(100% - 4px),
      100% 4px,
      calc(100% - 4px) 4px,
      calc(100% - 4px) 0px,
      4px 0px,
      4px 4px,
      0px 4px
    );
  }

  .pixel-corners-medium {
    clip-path: polygon(
      0px calc(100% - 16px),
      4px calc(100% - 16px),
      4px calc(100% - 8px),
      8px calc(100% - 8px),
      8px calc(100% - 4px),
      16px calc(100% - 4px),
      16px 100%,
      calc(100% - 16px) 100%,
      calc(100% - 16px) calc(100% - 4px),
      calc(100% - 8px) calc(100% - 4px),
      calc(100% - 8px) calc(100% - 8px),
      calc(100% - 4px) calc(100% - 8px),
      calc(100% - 4px) calc(100% - 16px),
      100% calc(100% - 16px),
      100% 16px,
      calc(100% - 4px) 16px,
      calc(100% - 4px) 8px,
      calc(100% - 8px) 8px,
      calc(100% - 8px) 4px,
      calc(100% - 16px) 4px,
      calc(100% - 16px) 0px,
      16px 0px,
      16px 4px,
      8px 4px,
      8px 8px,
      4px 8px,
      4px 16px,
      0px 16px
    );
  }
}

.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.custom-scrollbar::-webkit-scrollbar-button {
  display: none;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-track-piece {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: rgba(126, 211, 181, 0.3);
  border-radius: 3px;
  transition: all 0.2s ease;
  border: none;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: rgba(126, 211, 181, 0.6);
}

.custom-scrollbar::-webkit-scrollbar-thumb:active {
  background: rgba(126, 211, 181, 0.8);
}

.custom-scrollbar::-webkit-scrollbar-corner {
  background: transparent;
}

/* Firefox scrollbar */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: rgba(126, 211, 181, 0.3) transparent;
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-4px);
  }
}

@keyframes bump {
  0%,
  100% {
    transform: translateY(0) scale(1);
  }
  50% {
    transform: translateY(-2px) scale(1.1);
  }
}

.animate-float {
  animation: float 2s ease-in-out infinite;
}

.animate-bump {
  animation: bump 0.8s ease-in-out infinite;
  animation-delay: calc(var(--char-index, 0) * 0.1s);
}

```

### src\main.tsx

```
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import ErrorBoundary from "./components/generic/ErrorBoundary.tsx";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);

```

### src\vite-env.d.ts

```
/// <reference types="vite/client" />

```

